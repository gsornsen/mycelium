# M05: Deployment Generation

## Overview

**Duration**: 2 days **Dependencies**: M02 (configuration system), M03 (service detection), M04 (interactive onboarding)
**Blocks**: M06 (coordination testing) **Lead Agent**: devops-engineer **Support Agents**: python-pro, platform-engineer

## Why This Milestone

Deployment generation transforms abstract user selections into concrete, executable infrastructure configurations. This
milestone bridges the gap between "what services do I want" (M04) and "how do I run them" (M06), generating
production-ready Docker Compose files or Justfiles with proper dependency ordering, healthchecks, volume management, and
secrets handling.

Well-generated deployments:

- Start services in correct dependency order
- Include healthchecks for coordination reliability
- Persist data appropriately
- Handle secrets securely
- Provide clear operation commands
- Support both development and production modes

## Requirements

### Functional Requirements (FR)

- **FR-5.1**: Generate Docker Compose v2 files with service definitions, networks, volumes
- **FR-5.2**: Generate Justfiles with sequential startup, status checks, logs access
- **FR-5.3**: Include healthchecks for all services with retry logic
- **FR-5.4**: Support environment variable overrides
- **FR-5.5**: Generate .env.example with documented variables
- **FR-5.6**: Create README with setup and operation instructions

### Technical Requirements (TR)

- **TR-5.1**: Use Jinja2 templates for flexible generation
- **TR-5.2**: Validate generated files for syntax correctness
- **TR-5.3**: Support version pinning for all service images
- **TR-5.4**: Generate idempotent configurations (safe to regenerate)
- **TR-5.5**: Include comments explaining configuration choices

### Integration Requirements (IR)

- **IR-5.1**: Read configuration from M02 MyceliumConfig
- **IR-5.2**: Use service info from M03 detection results where applicable
- **IR-5.3**: Generate files in M01 XDG-compliant locations
- **IR-5.4**: Integrate as `/mycelium-generate` slash command

### Compliance Requirements (CR)

- **CR-5.1**: Security - No hardcoded credentials, use secrets management
- **CR-5.2**: Best practices - Follow Docker Compose and Justfile conventions
- **CR-5.3**: Maintainability - Generated files should be human-readable and editable

## Tasks

### Task 5.1: Design Deployment Templates

**Agent**: devops-engineer (lead), platform-engineer (review) **Effort**: 4 hours

**Description**: Design Jinja2 templates for Docker Compose and Justfile with proper structure, comments, and
extensibility points.

**Implementation**:

```yaml
# mycelium_onboarding/templates/docker-compose.yml.j2
# Docker Compose template for Mycelium coordination infrastructure
# Generated by: /mycelium-onboarding
# Project: {{ config.project_name }}

version: '3.8'

services:
  {% if config.services.redis.enabled %}
  redis:
    image: redis:{{ redis_version | default('7-alpine') }}
    container_name: mycelium-redis
    ports:
      - "{{ config.services.redis.port }}:6379"
    {% if config.services.redis.persistence %}
    volumes:
      - redis-data:/data
    command: redis-server --appendonly yes --maxmemory {{ config.services.redis.max_memory }}
    {% endif %}
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 5s
      timeout: 3s
      retries: 5
      start_period: 10s
    restart: unless-stopped
    networks:
      - mycelium-net
  {% endif %}

  {% if config.services.postgres.enabled %}
  postgres:
    image: postgres:{{ postgres_version | default('16-alpine') }}
    container_name: mycelium-postgres
    ports:
      - "{{ config.services.postgres.port }}:5432"
    environment:
      POSTGRES_USER: ${POSTGRES_USER:-mycelium}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:?POSTGRES_PASSWORD required}
      POSTGRES_DB: ${POSTGRES_DB:-mycelium}
    volumes:
      - postgres-data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER:-mycelium}"]
      interval: 5s
      timeout: 3s
      retries: 5
      start_period: 10s
    restart: unless-stopped
    networks:
      - mycelium-net
  {% endif %}

  {% if config.services.temporal.enabled %}
  temporal:
    image: temporalio/auto-setup:{{ temporal_version | default('1.22.4') }}
    container_name: mycelium-temporal
    ports:
      - "{{ config.services.temporal.frontend_port }}:7233"
      - "{{ config.services.temporal.ui_port }}:8233"
    environment:
      - DB=postgresql
      - DB_PORT=5432
      - POSTGRES_USER=${POSTGRES_USER:-mycelium}
      - POSTGRES_PWD=${POSTGRES_PASSWORD:?POSTGRES_PASSWORD required}
      - POSTGRES_SEEDS=postgres
    depends_on:
      postgres:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "tctl", "--address", "temporal:7233", "cluster", "health"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s
    restart: unless-stopped
    networks:
      - mycelium-net
  {% endif %}

networks:
  mycelium-net:
    name: mycelium-network
    driver: bridge

{% if config.services.redis.persistence or config.services.postgres.enabled %}
volumes:
  {% if config.services.redis.persistence %}
  redis-data:
    name: mycelium-redis-data
  {% endif %}
  {% if config.services.postgres.enabled %}
  postgres-data:
    name: mycelium-postgres-data
  {% endif %}
{% endif %}
```

```justfile
# mycelium_onboarding/templates/Justfile.j2
# Justfile for Mycelium coordination infrastructure (bare-metal deployment)
# Generated by: /mycelium-onboarding
# Project: {{ config.project_name }}

# Configuration
REDIS_PORT := "{{ config.services.redis.port }}"
POSTGRES_PORT := "{{ config.services.postgres.port }}"
TEMPORAL_PORT := "{{ config.services.temporal.frontend_port }}"

# Default recipe (shows help)
default:
    @just --list

# Start all enabled services
up: {% if config.services.postgres.enabled %}start-postgres {% endif %}{% if config.services.redis.enabled %}start-redis {% endif %}{% if config.services.temporal.enabled %}start-temporal {% endif %}
    @echo "✓ All services started"

# Stop all services
down: {% if config.services.temporal.enabled %}stop-temporal {% endif %}{% if config.services.redis.enabled %}stop-redis {% endif %}{% if config.services.postgres.enabled %}stop-postgres {% endif %}
    @echo "✓ All services stopped"

{% if config.services.redis.enabled %}
# Start Redis
start-redis:
    @echo "Starting Redis on port {{ config.services.redis.port }}..."
    @redis-server --port {{ config.services.redis.port }} \
        {% if config.services.redis.persistence %}--appendonly yes \{% endif %}
        --maxmemory {{ config.services.redis.max_memory }} \
        --daemonize yes
    @sleep 2
    @redis-cli -p {{ config.services.redis.port }} ping > /dev/null && echo "✓ Redis healthy"

# Stop Redis
stop-redis:
    @redis-cli -p {{ config.services.redis.port }} shutdown nosave || true
    @echo "✓ Redis stopped"
{% endif %}

{% if config.services.postgres.enabled %}
# Start PostgreSQL
start-postgres:
    @echo "Starting PostgreSQL on port {{ config.services.postgres.port }}..."
    @pg_ctl -D ${PGDATA:-~/.local/share/mycelium/postgres} start
    @sleep 3
    @pg_isready -p {{ config.services.postgres.port }} && echo "✓ PostgreSQL healthy"

# Stop PostgreSQL
stop-postgres:
    @pg_ctl -D ${PGDATA:-~/.local/share/mycelium/postgres} stop
    @echo "✓ PostgreSQL stopped"
{% endif %}

# Check status of all services
status:
    {% if config.services.redis.enabled %}@just check-redis{% endif %}
    {% if config.services.postgres.enabled %}@just check-postgres{% endif %}
    {% if config.services.temporal.enabled %}@just check-temporal{% endif %}

{% if config.services.redis.enabled %}
# Check Redis status
check-redis:
    @redis-cli -p {{ config.services.redis.port }} ping > /dev/null && \
        echo "✓ Redis: Running" || echo "✗ Redis: Stopped"
{% endif %}

# View logs (if services support logging)
logs service:
    @echo "Viewing logs for {{ service }}..."
    @tail -f ~/.local/share/mycelium/logs/{{ service }}.log
```

**Acceptance Criteria**:

- [ ] Templates use Jinja2 syntax correctly
- [ ] All configuration options from MyceliumConfig supported
- [ ] Comments explain each section
- [ ] Templates validated by devops-engineer

### Task 5.2: Implement Docker Compose Generator

**Agent**: devops-engineer, python-pro **Effort**: 6 hours

**Description**: Create generator that renders Docker Compose template with proper dependency ordering, healthchecks,
and volume management.

**Implementation**:

```python
# mycelium_onboarding/generators/docker_compose.py
"""Docker Compose file generator."""

from pathlib import Path
from typing import Optional
import jinja2
import yaml

from mycelium_onboarding.config.schema import MyceliumConfig

class DockerComposeGenerator:
    """Generates Docker Compose configuration from MyceliumConfig."""

    TEMPLATE_NAME = "docker-compose.yml.j2"

    def __init__(self, template_dir: Optional[Path] = None):
        if template_dir is None:
            template_dir = Path(__file__).parent.parent / "templates"

        self.env = jinja2.Environment(
            loader=jinja2.FileSystemLoader(str(template_dir)),
            autoescape=False,  # YAML doesn't need escaping
            trim_blocks=True,
            lstrip_blocks=True,
        )

    def generate(self, config: MyceliumConfig) -> str:
        """
        Generate Docker Compose YAML from configuration.

        Args:
            config: Mycelium configuration

        Returns:
            Docker Compose YAML content as string
        """
        template = self.env.get_template(self.TEMPLATE_NAME)

        # Prepare context with version information
        context = {
            'config': config,
            'redis_version': '7-alpine',
            'postgres_version': '16-alpine',
            'temporal_version': '1.22.4',
        }

        rendered = template.render(**context)

        # Validate YAML syntax
        try:
            yaml.safe_load(rendered)
        except yaml.YAMLError as e:
            raise ValueError(f"Generated invalid YAML: {e}") from e

        return rendered

    def generate_to_file(
        self,
        config: MyceliumConfig,
        output_path: Path,
        overwrite: bool = False
    ) -> Path:
        """
        Generate Docker Compose file to disk.

        Args:
            config: Mycelium configuration
            output_path: Where to write docker-compose.yml
            overwrite: If True, overwrite existing file

        Returns:
            Path to generated file

        Raises:
            FileExistsError: If file exists and overwrite=False
        """
        if output_path.exists() and not overwrite:
            raise FileExistsError(
                f"{output_path} already exists. Use overwrite=True to replace."
            )

        content = self.generate(config)

        output_path.parent.mkdir(parents=True, exist_ok=True)
        output_path.write_text(content)

        return output_path

    def generate_env_example(self, config: MyceliumConfig) -> str:
        """
        Generate .env.example file with documented variables.

        Args:
            config: Mycelium configuration

        Returns:
            .env file content
        """
        lines = [
            "# Mycelium Environment Configuration",
            "# Copy this file to .env and fill in your values",
            "",
        ]

        if config.services.postgres.enabled:
            lines.extend([
                "# PostgreSQL Configuration",
                "POSTGRES_USER=mycelium",
                "POSTGRES_PASSWORD=<generate-secure-password>",
                "POSTGRES_DB=mycelium",
                "",
            ])

        if config.services.temporal.enabled:
            lines.extend([
                "# Temporal Configuration",
                "# (Uses PostgreSQL credentials above)",
                "",
            ])

        lines.extend([
            "# Project Configuration",
            f"PROJECT_NAME={config.project_name}",
            "",
        ])

        return "\n".join(lines)

def validate_docker_compose(compose_file: Path) -> tuple[bool, Optional[str]]:
    """
    Validate Docker Compose file using docker-compose config.

    Args:
        compose_file: Path to docker-compose.yml

    Returns:
        (is_valid, error_message) tuple
    """
    import subprocess

    try:
        result = subprocess.run(
            ['docker-compose', '-f', str(compose_file), 'config'],
            capture_output=True,
            text=True,
            check=True,
        )
        return True, None
    except subprocess.CalledProcessError as e:
        return False, e.stderr
    except FileNotFoundError:
        # docker-compose not installed
        return False, "docker-compose command not found"
```

**Test Plan**:

```python
# tests/test_docker_compose_generator.py
"""Tests for Docker Compose generator."""

import pytest
from pathlib import Path
import yaml

from mycelium_onboarding.generators.docker_compose import DockerComposeGenerator
from mycelium_onboarding.config.schema import MyceliumConfig

def test_generate_valid_yaml():
    """Generated content should be valid YAML."""
    config = MyceliumConfig()  # Default config
    generator = DockerComposeGenerator()

    content = generator.generate(config)

    # Should parse without errors
    parsed = yaml.safe_load(content)
    assert 'version' in parsed
    assert 'services' in parsed

def test_redis_service_included_when_enabled():
    """Redis service should be included when enabled."""
    config = MyceliumConfig()
    config.services.redis.enabled = True

    generator = DockerComposeGenerator()
    content = generator.generate(config)
    parsed = yaml.safe_load(content)

    assert 'redis' in parsed['services']
    assert parsed['services']['redis']['image'].startswith('redis:')

def test_healthchecks_included():
    """All services should have healthchecks."""
    config = MyceliumConfig()
    config.services.redis.enabled = True
    config.services.postgres.enabled = True

    generator = DockerComposeGenerator()
    content = generator.generate(config)
    parsed = yaml.safe_load(content)

    for service_name in ['redis', 'postgres']:
        assert 'healthcheck' in parsed['services'][service_name]
        hc = parsed['services'][service_name]['healthcheck']
        assert 'test' in hc
        assert 'interval' in hc
        assert 'retries' in hc

def test_volumes_created_for_persistence():
    """Volumes should be created when persistence enabled."""
    config = MyceliumConfig()
    config.services.redis.enabled = True
    config.services.redis.persistence = True

    generator = DockerComposeGenerator()
    content = generator.generate(config)
    parsed = yaml.safe_load(content)

    assert 'volumes' in parsed
    assert 'redis-data' in parsed['volumes']

def test_env_example_generation():
    """Should generate .env.example with required variables."""
    config = MyceliumConfig()
    config.services.postgres.enabled = True

    generator = DockerComposeGenerator()
    env_content = generator.generate_env_example(config)

    assert 'POSTGRES_USER' in env_content
    assert 'POSTGRES_PASSWORD' in env_content
    assert '<generate-secure-password>' in env_content
```

**Acceptance Criteria**:

- [ ] Generates syntactically valid Docker Compose v2 files
- [ ] Includes healthchecks with appropriate timeouts
- [ ] Uses depends_on with condition: service_healthy
- [ ] Creates volumes for persistent data
- [ ] Generates .env.example with all required variables
- [ ] Validates generated file with docker-compose config

### Task 5.3: Implement Justfile Generator

**Agent**: devops-engineer, platform-engineer **Effort**: 4 hours

**Description**: Create generator for Justfile with sequential service startup, status checks, and operation commands.

**Implementation**:

```python
# mycelium_onboarding/generators/justfile.py
"""Justfile generator for bare-metal deployments."""

from pathlib import Path
from typing import Optional
import jinja2

from mycelium_onboarding.config.schema import MyceliumConfig

class JustfileGenerator:
    """Generates Justfile configuration from MyceliumConfig."""

    TEMPLATE_NAME = "Justfile.j2"

    def __init__(self, template_dir: Optional[Path] = None):
        if template_dir is None:
            template_dir = Path(__file__).parent.parent / "templates"

        self.env = jinja2.Environment(
            loader=jinja2.FileSystemLoader(str(template_dir)),
            autoescape=False,
            trim_blocks=True,
            lstrip_blocks=True,
        )

    def generate(self, config: MyceliumConfig) -> str:
        """
        Generate Justfile from configuration.

        Args:
            config: Mycelium configuration

        Returns:
            Justfile content as string
        """
        template = self.env.get_template(self.TEMPLATE_NAME)

        context = {
            'config': config,
        }

        rendered = template.render(**context)
        return rendered

    def generate_to_file(
        self,
        config: MyceliumConfig,
        output_path: Path,
        overwrite: bool = False
    ) -> Path:
        """
        Generate Justfile to disk.

        Args:
            config: Mycelium configuration
            output_path: Where to write Justfile
            overwrite: If True, overwrite existing file

        Returns:
            Path to generated file

        Raises:
            FileExistsError: If file exists and overwrite=False
        """
        if output_path.exists() and not overwrite:
            raise FileExistsError(
                f"{output_path} already exists. Use overwrite=True to replace."
            )

        content = self.generate(config)

        output_path.parent.mkdir(parents=True, exist_ok=True)
        output_path.write_text(content)

        # Make executable
        output_path.chmod(0o755)

        return output_path

    def generate_service_scripts(self, config: MyceliumConfig, output_dir: Path) -> list[Path]:
        """
        Generate individual service management scripts.

        For bare-metal deployments, create helper scripts for each service.

        Args:
            config: Mycelium configuration
            output_dir: Directory for scripts

        Returns:
            List of generated script paths
        """
        scripts = []
        output_dir.mkdir(parents=True, exist_ok=True)

        if config.services.redis.enabled:
            redis_script = output_dir / "start-redis.sh"
            redis_script.write_text(self._generate_redis_script(config))
            redis_script.chmod(0o755)
            scripts.append(redis_script)

        if config.services.postgres.enabled:
            postgres_script = output_dir / "start-postgres.sh"
            postgres_script.write_text(self._generate_postgres_script(config))
            postgres_script.chmod(0o755)
            scripts.append(postgres_script)

        return scripts

    def _generate_redis_script(self, config: MyceliumConfig) -> str:
        """Generate standalone Redis startup script."""
        return f"""#!/usr/bin/env bash
# Redis startup script for Mycelium
# Generated by: /mycelium-onboarding

set -euo pipefail

REDIS_PORT={config.services.redis.port}
REDIS_CONF="${{XDG_CONFIG_HOME:-$HOME/.config}}/mycelium/redis.conf"
REDIS_LOG="${{XDG_DATA_HOME:-$HOME/.local/share}}/mycelium/logs/redis.log"

mkdir -p "$(dirname "$REDIS_LOG")"

redis-server \\
    --port "$REDIS_PORT" \\
    {"--appendonly yes \\" if config.services.redis.persistence else ""}\\
    --maxmemory {config.services.redis.max_memory} \\
    --logfile "$REDIS_LOG" \\
    --daemonize yes

sleep 2

if redis-cli -p "$REDIS_PORT" ping > /dev/null 2>&1; then
    echo "✓ Redis started successfully on port $REDIS_PORT"
else
    echo "✗ Redis failed to start. Check logs: $REDIS_LOG"
    exit 1
fi
"""

    def _generate_postgres_script(self, config: MyceliumConfig) -> str:
        """Generate standalone PostgreSQL startup script."""
        return f"""#!/usr/bin/env bash
# PostgreSQL startup script for Mycelium
# Generated by: /mycelium-onboarding

set -euo pipefail

POSTGRES_PORT={config.services.postgres.port}
PGDATA="${{XDG_DATA_HOME:-$HOME/.local/share}}/mycelium/postgres"

if [ ! -d "$PGDATA" ]; then
    echo "Initializing PostgreSQL data directory..."
    initdb -D "$PGDATA"
fi

pg_ctl -D "$PGDATA" -l "${{PGDATA}}/logfile" start

sleep 3

if pg_isready -p "$POSTGRES_PORT" > /dev/null 2>&1; then
    echo "✓ PostgreSQL started successfully on port $POSTGRES_PORT"
else
    echo "✗ PostgreSQL failed to start. Check logs: ${{PGDATA}}/logfile"
    exit 1
fi
"""
```

**Acceptance Criteria**:

- [ ] Generates valid Justfile syntax
- [ ] Includes recipes for up, down, status, logs
- [ ] Services start in dependency order
- [ ] Includes health check commands
- [ ] Helper scripts generated for complex services

### Task 5.4: Implement Secrets Management

**Agent**: devops-engineer, python-pro **Effort**: 3 hours

**Description**: Create secure secrets generation and management for passwords, API keys, and sensitive configuration.

**Implementation**:

```python
# mycelium_onboarding/generators/secrets.py
"""Secrets generation and management."""

import secrets
import string
from pathlib import Path
from typing import Optional
import os

def generate_password(length: int = 32, include_symbols: bool = True) -> str:
    """
    Generate cryptographically secure password.

    Args:
        length: Password length
        include_symbols: Include special characters

    Returns:
        Generated password
    """
    alphabet = string.ascii_letters + string.digits
    if include_symbols:
        alphabet += "!@#$%^&*()_+-=[]{}|;:,.<>?"

    password = ''.join(secrets.choice(alphabet) for _ in range(length))
    return password

def generate_env_file(
    config: 'MyceliumConfig',
    output_path: Path,
    overwrite: bool = False
) -> Path:
    """
    Generate .env file with secrets.

    Args:
        config: Mycelium configuration
        output_path: Where to write .env file
        overwrite: If True, overwrite existing file

    Returns:
        Path to generated .env file

    Raises:
        FileExistsError: If file exists and overwrite=False
    """
    if output_path.exists() and not overwrite:
        raise FileExistsError(
            f"{output_path} already exists. Use overwrite=True to replace."
        )

    lines = [
        "# Mycelium Environment Configuration",
        "# Generated by: /mycelium-generate",
        "# IMPORTANT: Keep this file secure and never commit to version control",
        "",
    ]

    if config.services.postgres.enabled:
        lines.extend([
            "# PostgreSQL Configuration",
            f"POSTGRES_USER=mycelium",
            f"POSTGRES_PASSWORD={generate_password(32, include_symbols=False)}",
            f"POSTGRES_DB=mycelium",
            "",
        ])

    if config.services.redis.enabled and config.services.redis.password_protected:
        lines.extend([
            "# Redis Configuration",
            f"REDIS_PASSWORD={generate_password(32, include_symbols=False)}",
            "",
        ])

    lines.extend([
        "# Project Configuration",
        f"PROJECT_NAME={config.project_name}",
        f"MYCELIUM_ENV=development",
        "",
    ])

    output_path.parent.mkdir(parents=True, exist_ok=True)
    output_path.write_text("\n".join(lines))

    # Set restrictive permissions
    output_path.chmod(0o600)

    return output_path

def load_env_file(env_path: Path) -> dict[str, str]:
    """
    Load environment variables from .env file.

    Args:
        env_path: Path to .env file

    Returns:
        Dictionary of environment variables
    """
    env_vars = {}

    if not env_path.exists():
        return env_vars

    for line in env_path.read_text().splitlines():
        line = line.strip()

        # Skip comments and empty lines
        if not line or line.startswith('#'):
            continue

        # Parse KEY=VALUE
        if '=' in line:
            key, value = line.split('=', 1)
            env_vars[key.strip()] = value.strip()

    return env_vars

def update_env_var(env_path: Path, key: str, value: str) -> None:
    """
    Update or add environment variable in .env file.

    Args:
        env_path: Path to .env file
        key: Environment variable name
        value: Environment variable value
    """
    env_vars = load_env_file(env_path)
    env_vars[key] = value

    lines = [f"{k}={v}" for k, v in env_vars.items()]
    env_path.write_text("\n".join(lines) + "\n")
```

**Acceptance Criteria**:

- [ ] Generates cryptographically secure passwords
- [ ] Creates .env file with restrictive permissions (0o600)
- [ ] Supports loading and updating environment variables
- [ ] Includes warnings about security in generated files

### Task 5.5: Create /mycelium-generate Command

**Agent**: claude-code-developer, devops-engineer **Effort**: 3 hours

**Description**: Integrate generators as `/mycelium-generate` command with options for Docker Compose or Justfile.

**Implementation**:

```markdown
# ~/.claude/plugins/mycelium-core/commands/mycelium-generate.md

# Mycelium Generate

Generate deployment files (Docker Compose or Justfile) from configuration.

## Usage

```

/mycelium-generate \[--method METHOD\] \[--output DIR\] \[--force\]

````

## Options

- `--method`: Deployment method ('docker-compose' or 'justfile', auto-detected from config)
- `--output`: Output directory (default: current directory)
- `--force`: Overwrite existing files
- `--no-secrets`: Skip .env file generation

## Examples

```bash
# Generate Docker Compose (default)
/mycelium-generate

# Generate Justfile
/mycelium-generate --method justfile

# Custom output directory
/mycelium-generate --output ~/mycelium-deploy

# Overwrite existing files
/mycelium-generate --force
````

## What This Command Does

1. Loads configuration from `/mycelium-configuration`
1. Generates deployment files based on selected method:
   - **Docker Compose**: `docker-compose.yml`, `.env`, `.env.example`
   - **Justfile**: `Justfile`, service scripts, `.env`
1. Validates generated files
1. Shows next steps for deployment

## Generated Files

### Docker Compose Mode

- `docker-compose.yml` - Service definitions
- `.env` - Secrets and configuration (gitignored)
- `.env.example` - Template for other users
- `README.md` - Setup and operation instructions

### Justfile Mode

- `Justfile` - Service management recipes
- `bin/start-*.sh` - Service startup scripts
- `.env` - Secrets and configuration
- `README.md` - Setup and operation instructions

## After Generation

### Docker Compose

```bash
# Start services
docker-compose up -d

# Check status
docker-compose ps

# View logs
docker-compose logs -f
```

### Justfile

```bash
# Start services
just up

# Check status
just status

# View logs
just logs redis
```

## Troubleshooting

### File Already Exists

```bash
# Use --force to overwrite
/mycelium-generate --force
```

### Invalid Configuration

```bash
# Validate configuration first
/mycelium-configuration validate
```

````

```python
# mycelium_onboarding/cli/generate.py
"""CLI command for deployment generation."""

import click
from pathlib import Path
from rich.console import Console
from rich.panel import Panel

from mycelium_onboarding.config.manager import ConfigManager
from mycelium_onboarding.generators.docker_compose import DockerComposeGenerator
from mycelium_onboarding.generators.justfile import JustfileGenerator
from mycelium_onboarding.generators.secrets import generate_env_file

console = Console()

@click.command()
@click.option(
    '--method',
    type=click.Choice(['docker-compose', 'justfile'], case_sensitive=False),
    help='Deployment method (auto-detected if not specified)'
)
@click.option(
    '--output',
    type=click.Path(),
    default='.',
    help='Output directory for generated files'
)
@click.option(
    '--force',
    is_flag=True,
    help='Overwrite existing files'
)
@click.option(
    '--no-secrets',
    is_flag=True,
    help='Skip .env file generation'
)
def generate(method: str, output: str, force: bool, no_secrets: bool):
    """Generate deployment files from configuration."""

    # Load configuration
    try:
        config = ConfigManager.load()
    except FileNotFoundError:
        console.print("[red]✗ No configuration found. Run /mycelium-onboarding first.[/red]")
        raise click.Abort()

    # Determine deployment method
    if method is None:
        method = config.deployment.method

    output_dir = Path(output).resolve()
    output_dir.mkdir(parents=True, exist_ok=True)

    console.print(f"[cyan]Generating {method} deployment...[/cyan]\n")

    # Generate based on method
    generated_files = []

    if method == 'docker-compose':
        generator = DockerComposeGenerator()

        compose_file = output_dir / 'docker-compose.yml'
        generator.generate_to_file(config, compose_file, overwrite=force)
        generated_files.append(compose_file)

        env_example = output_dir / '.env.example'
        env_example.write_text(generator.generate_env_example(config))
        generated_files.append(env_example)

    elif method == 'justfile':
        generator = JustfileGenerator()

        justfile = output_dir / 'Justfile'
        generator.generate_to_file(config, justfile, overwrite=force)
        generated_files.append(justfile)

        scripts = generator.generate_service_scripts(config, output_dir / 'bin')
        generated_files.extend(scripts)

    # Generate .env file with secrets
    if not no_secrets:
        env_file = output_dir / '.env'
        generate_env_file(config, env_file, overwrite=force)
        generated_files.append(env_file)

    # Show success message
    console.print(Panel(
        f"[bold green]✓ Deployment files generated![/bold green]\n\n"
        f"Output directory: [cyan]{output_dir}[/cyan]\n\n"
        f"Generated files:\n" +
        "\n".join(f"  • {f.relative_to(output_dir)}" for f in generated_files) +
        f"\n\nNext steps:\n"
        f"1. Review generated files\n"
        f"2. Start services: [bold]just up[/bold] or [bold]docker-compose up[/bold]\n"
        f"3. Test coordination: [bold]/mycelium-test[/bold]",
        border_style="green"
    ))

if __name__ == '__main__':
    generate()
````

**Acceptance Criteria**:

- [ ] Command generates correct files based on method
- [ ] Validates configuration before generating
- [ ] Shows clear success/error messages
- [ ] Supports custom output directories

## Exit Criteria

- [ ] Docker Compose generator creates valid v2 files
- [ ] Justfile generator creates functional recipes
- [ ] Both generators include proper healthchecks
- [ ] Secrets management implemented securely
- [ ] .env files created with restrictive permissions
- [ ] `/mycelium-generate` command functional
- [ ] Generated files validated (syntax, completeness)
- [ ] ≥80% test coverage for generators
- [ ] Documentation includes examples and troubleshooting
- [ ] Code reviewed and approved by devops-engineer + python-pro

## Deliverables

1. **Templates**:

   - `mycelium_onboarding/templates/docker-compose.yml.j2`
   - `mycelium_onboarding/templates/Justfile.j2`

1. **Generators**:

   - `mycelium_onboarding/generators/docker_compose.py`
   - `mycelium_onboarding/generators/justfile.py`
   - `mycelium_onboarding/generators/secrets.py`

1. **CLI**:

   - `mycelium_onboarding/cli/generate.py`
   - `~/.claude/plugins/mycelium-core/commands/mycelium-generate.md`

1. **Tests**:

   - `tests/unit/test_docker_compose_generator.py`
   - `tests/unit/test_justfile_generator.py`
   - `tests/unit/test_secrets_generation.py`
   - `tests/integration/test_generate_command.py`

1. **Documentation**:

   - `docs/guides/deployment-generation.md`
   - Example generated files in `examples/`

## Risk Assessment

| Risk                               | Probability | Impact | Mitigation                               |
| ---------------------------------- | ----------- | ------ | ---------------------------------------- |
| Docker Compose v1/v2 compatibility | Low         | Medium | Use version: '3.8', test both CLIs       |
| Template syntax errors             | Low         | High   | Comprehensive validation, test suite     |
| Insecure secret generation         | Low         | High   | Use secrets module, set file permissions |
| Service startup race conditions    | Medium      | High   | Proper depends_on with healthchecks      |

## Dependencies for Next Milestones

**M06 (Coordination Testing)** requires:

- Generated Docker Compose or Justfile
- Services deployable and healthy
- Configuration accessible for test orchestrator
- Deployment method known for test environment setup

______________________________________________________________________

**Milestone Owner**: devops-engineer **Reviewers**: platform-engineer, code-reviewer **Status**: Ready for
Implementation **Created**: 2025-10-13 **Target Completion**: Day 13 (2 days after M04)
