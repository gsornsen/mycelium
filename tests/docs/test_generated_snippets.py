"""Auto-generated tests for documentation code snippets.

This file is generated by scripts/extract_doc_snippets.py.
DO NOT EDIT MANUALLY - your changes will be overwritten.
"""

import ast

import pytest


def test_snippet_api_discovery_quickstart_1():
    """Test code snippet from api/discovery-quickstart.md (line 176)."""
    code = 'import requests\n\n# Step 1: Discover agents\nresponse = requests.post(\n    "http://localhost:8000/api/v1/agents/discover",\n    json={\n        "query": "secure API authentication implementation",\n        "limit": 3,\n        "threshold": 0.8\n    }\n)\n\nmatches = response.json()["matches"]\n\n# Step 2: Get top match\nif matches:\n    best_agent = matches[0]\n    print(f"Best match: {best_agent[\'agent\'][\'name\']}")\n    print(f"Confidence: {best_agent[\'confidence\']}")\n    print(f"Reason: {best_agent[\'match_reason\']}")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_api_discovery_quickstart_2():
    """Test code snippet from api/discovery-quickstart.md (line 201)."""
    code = 'import requests\n\n# Get all categories\nresponse = requests.get("http://localhost:8000/api/v1/agents/search?limit=100")\nagents = response.json()["agents"]\n\ncategories = set(agent["category"] for agent in agents)\n\n# Browse each category\nfor category in categories:\n    response = requests.get(\n        f"http://localhost:8000/api/v1/agents/search?category={category}"\n    )\n    print(f"\\n{category} ({response.json()[\'total_count\']} agents)")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_api_discovery_quickstart_3():
    """Test code snippet from api/discovery-quickstart.md (line 220)."""
    code = 'import requests\n\ndef discover_agent(query: str, min_confidence: float = 0.8):\n    """Discover agent with fallback to lower confidence."""\n\n    # Try high confidence first\n    response = requests.post(\n        "http://localhost:8000/api/v1/agents/discover",\n        json={"query": query, "threshold": min_confidence}\n    )\n\n    matches = response.json()["matches"]\n\n    if not matches and min_confidence > 0.5:\n        # Fallback to lower confidence\n        print(f"No high-confidence matches, trying threshold 0.5...")\n        return discover_agent(query, min_confidence=0.5)\n\n    return matches\n\n# Usage\nagents = discover_agent("machine learning model training")\nif agents:\n    print(f"Found {len(agents)} agents")\nelse:\n    print("No agents found for this query")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_api_discovery_quickstart_4():
    """Test code snippet from api/discovery-quickstart.md (line 261)."""
    code = '# Good: Specific limit\n{"query": "backend", "limit": 5}\n\n# Avoid: Excessive results\n{"query": "backend", "limit": 50}'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_api_discovery_quickstart_5():
    """Test code snippet from api/discovery-quickstart.md (line 286)."""
    code = 'from functools import lru_cache\nimport requests\n\n@lru_cache(maxsize=100)\ndef get_agent(agent_id: str):\n    response = requests.get(f"http://localhost:8000/api/v1/agents/{agent_id}")\n    return response.json()'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_api_discovery_quickstart_6():
    """Test code snippet from api/discovery-quickstart.md (line 306)."""
    code = 'import requests\nimport time\n\ndef discover_with_retry(query: str, max_retries: int = 3):\n    """Discover agents with rate limit retry."""\n\n    for attempt in range(max_retries):\n        response = requests.post(\n            "http://localhost:8000/api/v1/agents/discover",\n            json={"query": query}\n        )\n\n        if response.status_code == 429:\n            # Rate limited\n            retry_after = int(response.headers.get("Retry-After", 60))\n            print(f"Rate limited, waiting {retry_after}s...")\n            time.sleep(retry_after)\n            continue\n\n        return response.json()\n\n    raise Exception("Max retries exceeded")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_api_discovery_quickstart_7():
    """Test code snippet from api/discovery-quickstart.md (line 333)."""
    code = 'import asyncio\nimport aiohttp\n\nasync def discover_agents_async(query: str):\n    """Async agent discovery."""\n\n    async with aiohttp.ClientSession() as session:\n        async with session.post(\n            "http://localhost:8000/api/v1/agents/discover",\n            json={"query": query, "limit": 10}\n        ) as response:\n            return await response.json()\n\n# Usage\nresults = asyncio.run(discover_agents_async("python development"))\nprint(f"Found {results[\'total_count\']} agents")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_api_registry_api_1():
    """Test code snippet from api/registry-api.md (line 66)."""
    code = 'from registry import AgentRegistry\n\n# Initialize with connection string\nregistry = AgentRegistry(\n    connection_string="postgresql://localhost:5432/mycelium_registry"\n)\nawait registry.initialize()\n\n# Initialize with existing pool\nimport asyncpg\npool = await asyncpg.create_pool(connection_string)\nregistry = AgentRegistry(pool=pool)\nawait registry.initialize()\n\n# Use as context manager (recommended)\nasync with AgentRegistry(connection_string) as registry:\n    # Use registry\n    pass'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_api_registry_api_2():
    """Test code snippet from api/registry-api.md (line 100)."""
    code = 'async def create_agent(\n    agent_id: str,\n    agent_type: str,\n    name: str,\n    display_name: str,\n    category: str,\n    description: str,\n    file_path: str,\n    capabilities: Optional[List[str]] = None,\n    tools: Optional[List[str]] = None,\n    keywords: Optional[List[str]] = None,\n    embedding: Optional[List[float]] = None,\n    estimated_tokens: Optional[int] = None,\n    metadata: Optional[Dict[str, Any]] = None,\n) -> UUID'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_api_registry_api_3():
    """Test code snippet from api/registry-api.md (line 139)."""
    code = 'agent_uuid = await registry.create_agent(\n    agent_id="01-core-backend-developer",\n    agent_type="backend-developer",\n    name="Backend Developer",\n    display_name="Backend Developer",\n    category="Core Development",\n    description="Senior backend engineer for scalable API development",\n    file_path="plugins/mycelium-core/agents/01-core-backend-developer.md",\n    capabilities=["api-development", "database-design"],\n    tools=["Bash", "Docker", "PostgreSQL"],\n    keywords=["backend", "api", "database"],\n    estimated_tokens=1200,\n    metadata={"version": "1.0"}\n)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_api_registry_api_4():
    """Test code snippet from api/registry-api.md (line 163)."""
    code = 'async def get_agent_by_id(agent_id: str) -> Dict[str, Any]'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_api_registry_api_5():
    """Test code snippet from api/registry-api.md (line 176)."""
    code = 'agent = await registry.get_agent_by_id("01-core-backend-developer")\nprint(f"Agent: {agent[\'name\']}")\nprint(f"Description: {agent[\'description\']}")\nprint(f"Capabilities: {agent[\'capabilities\']}")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_api_registry_api_6():
    """Test code snippet from api/registry-api.md (line 190)."""
    code = 'async def get_agent_by_type(agent_type: str) -> Dict[str, Any]'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_api_registry_api_7():
    """Test code snippet from api/registry-api.md (line 203)."""
    code = 'agent = await registry.get_agent_by_type("backend-developer")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_api_registry_api_8():
    """Test code snippet from api/registry-api.md (line 214)."""
    code = 'async def get_agent_by_uuid(uuid: UUID) -> Dict[str, Any]'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_api_registry_api_9():
    """Test code snippet from api/registry-api.md (line 227)."""
    code = 'from uuid import UUID\nagent = await registry.get_agent_by_uuid(\n    UUID("550e8400-e29b-41d4-a716-446655440000")\n)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_api_registry_api_10():
    """Test code snippet from api/registry-api.md (line 241)."""
    code = 'async def update_agent(agent_id: str, **fields: Any) -> None'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_api_registry_api_11():
    """Test code snippet from api/registry-api.md (line 253)."""
    code = 'await registry.update_agent(\n    "01-core-backend-developer",\n    description="Updated description",\n    capabilities=["api-development", "microservices", "database-design"],\n    metadata={"version": "2.0", "updated": True}\n)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_api_registry_api_12():
    """Test code snippet from api/registry-api.md (line 269)."""
    code = 'async def delete_agent(agent_id: str) -> None'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_api_registry_api_13():
    """Test code snippet from api/registry-api.md (line 280)."""
    code = 'await registry.delete_agent("01-core-backend-developer")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_api_registry_api_14():
    """Test code snippet from api/registry-api.md (line 293)."""
    code = 'async def list_agents(\n    category: Optional[str] = None,\n    limit: int = 100,\n    offset: int = 0,\n) -> List[Dict[str, Any]]'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_api_registry_api_15():
    """Test code snippet from api/registry-api.md (line 309)."""
    code = '# Get all agents\nall_agents = await registry.list_agents()\n\n# Get agents in specific category\ncore_agents = await registry.list_agents(category="Core Development")\n\n# Get paginated results\npage1 = await registry.list_agents(limit=20, offset=0)\npage2 = await registry.list_agents(limit=20, offset=20)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_api_registry_api_16():
    """Test code snippet from api/registry-api.md (line 328)."""
    code = 'async def search_agents(\n    query: str,\n    limit: int = 10,\n) -> List[Dict[str, Any]]'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_api_registry_api_17():
    """Test code snippet from api/registry-api.md (line 342)."""
    code = '# Search for backend-related agents\nresults = await registry.search_agents("backend api development")\n\nfor agent in results:\n    print(f"{agent[\'name\']}: {agent[\'description\']}")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_api_registry_api_18():
    """Test code snippet from api/registry-api.md (line 357)."""
    code = 'async def similarity_search(\n    embedding: List[float],\n    limit: int = 10,\n    threshold: float = 0.5,\n) -> List[Tuple[Dict[str, Any], float]]'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_api_registry_api_19():
    """Test code snippet from api/registry-api.md (line 373)."""
    code = '# Generate embedding for query\nfrom sentence_transformers import SentenceTransformer\nmodel = SentenceTransformer(\'all-MiniLM-L6-v2\')\nquery_embedding = model.encode("backend API development").tolist()\n\n# Search for similar agents\nresults = await registry.similarity_search(\n    embedding=query_embedding,\n    limit=5,\n    threshold=0.7\n)\n\nfor agent, similarity in results:\n    print(f"{agent[\'name\']}: {similarity:.2%} match")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_api_registry_api_20():
    """Test code snippet from api/registry-api.md (line 397)."""
    code = 'async def get_agent_count(category: Optional[str] = None) -> int'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_api_registry_api_21():
    """Test code snippet from api/registry-api.md (line 407)."""
    code = 'total = await registry.get_agent_count()\nprint(f"Total agents: {total}")\n\ncore_count = await registry.get_agent_count(category="Core Development")\nprint(f"Core agents: {core_count}")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_api_registry_api_22():
    """Test code snippet from api/registry-api.md (line 422)."""
    code = 'async def get_categories() -> List[str]'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_api_registry_api_23():
    """Test code snippet from api/registry-api.md (line 429)."""
    code = 'categories = await registry.get_categories()\nprint("Available categories:", categories)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_api_registry_api_24():
    """Test code snippet from api/registry-api.md (line 443)."""
    code = 'async def bulk_insert_agents(\n    agents: List[Dict[str, Any]],\n    batch_size: int = 100,\n) -> int'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_api_registry_api_25():
    """Test code snippet from api/registry-api.md (line 459)."""
    code = 'agents_to_insert = [\n    {\n        "agent_id": "agent-1",\n        "agent_type": "type-1",\n        "name": "Agent 1",\n        "display_name": "Agent 1",\n        "category": "Test",\n        "description": "Test agent 1",\n        "file_path": "/path/to/agent1.md",\n    },\n    # ... more agents\n]\n\ncount = await registry.bulk_insert_agents(agents_to_insert)\nprint(f"Inserted {count} agents")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_api_registry_api_26():
    """Test code snippet from api/registry-api.md (line 486)."""
    code = 'async def health_check() -> Dict[str, Any]'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_api_registry_api_27():
    """Test code snippet from api/registry-api.md (line 493)."""
    code = 'health = await registry.health_check()\nprint(f"Status: {health[\'status\']}")\nprint(f"pgvector installed: {health[\'pgvector_installed\']}")\nprint(f"Agent count: {health[\'agent_count\']}")\nprint(f"Database size: {health[\'database_size\']}")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_api_registry_api_28():
    """Test code snippet from api/registry-api.md (line 510)."""
    code = 'async def load_agents_from_index(\n    index_path: str | Path,\n    registry: AgentRegistry,\n) -> int'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_api_registry_api_29():
    """Test code snippet from api/registry-api.md (line 527)."""
    code = 'from registry import load_agents_from_index\n\nasync with AgentRegistry(connection_string) as registry:\n    count = await load_agents_from_index(\n        "plugins/mycelium-core/agents/index.json",\n        registry\n    )\n    print(f"Loaded {count} agents")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_api_registry_api_30():
    """Test code snippet from api/registry-api.md (line 551)."""
    code = 'try:\n    agent = await registry.get_agent_by_id("nonexistent")\nexcept AgentNotFoundError as e:\n    print(f"Agent not found: {e}")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_api_registry_api_31():
    """Test code snippet from api/registry-api.md (line 563)."""
    code = 'try:\n    await registry.create_agent(...)\nexcept AgentAlreadyExistsError as e:\n    print(f"Agent already exists: {e}")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_api_registry_api_32():
    """Test code snippet from api/registry-api.md (line 576)."""
    code = 'import asyncio\nfrom registry import AgentRegistry, load_agents_from_index\n\nasync def main():\n    # Initialize registry\n    async with AgentRegistry() as registry:\n        # Load agents from index.json\n        count = await load_agents_from_index(\n            "plugins/mycelium-core/agents/index.json",\n            registry\n        )\n        print(f"Loaded {count} agents")\n\n        # Get agent count by category\n        categories = await registry.get_categories()\n        for category in categories:\n            count = await registry.get_agent_count(category=category)\n            print(f"{category}: {count} agents")\n\n        # Search for agents\n        results = await registry.search_agents("backend development")\n        print(f"\\nFound {len(results)} agents matching \'backend development\':")\n        for agent in results[:5]:\n            print(f"  - {agent[\'name\']}: {agent[\'description\']}")\n\n        # Get specific agent\n        agent = await registry.get_agent_by_type("backend-developer")\n        print(f"\\nAgent details:")\n        print(f"  Name: {agent[\'display_name\']}")\n        print(f"  Category: {agent[\'category\']}")\n        print(f"  Tools: {\', \'.join(agent[\'tools\'])}")\n        print(f"  Usage count: {agent[\'usage_count\']}")\n\nasyncio.run(main())'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_api_registry_api_33():
    """Test code snippet from api/registry-api.md (line 615)."""
    code = 'from sentence_transformers import SentenceTransformer\nfrom registry import AgentRegistry\n\nasync def semantic_agent_discovery(query: str):\n    # Initialize embedding model\n    model = SentenceTransformer(\'all-MiniLM-L6-v2\')\n\n    async with AgentRegistry() as registry:\n        # Generate query embedding\n        query_embedding = model.encode(query).tolist()\n\n        # Perform similarity search\n        results = await registry.similarity_search(\n            embedding=query_embedding,\n            limit=5,\n            threshold=0.6\n        )\n\n        print(f"Top agents for \'{query}\':")\n        for agent, similarity in results:\n            print(f"  {similarity:.1%} - {agent[\'name\']}: {agent[\'description\']}")\n\n# Usage\nimport asyncio\nasyncio.run(semantic_agent_discovery(\n    "I need to build a REST API with authentication"\n))'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_api_registry_api_34():
    """Test code snippet from api/registry-api.md (line 647)."""
    code = 'import time\nfrom registry import AgentRegistry\n\nasync def benchmark_queries():\n    async with AgentRegistry() as registry:\n        # Benchmark get_agent_by_id\n        start = time.time()\n        await registry.get_agent_by_id("01-core-backend-developer")\n        duration = (time.time() - start) * 1000\n        print(f"get_agent_by_id: {duration:.2f}ms")\n\n        # Benchmark search\n        start = time.time()\n        await registry.search_agents("backend")\n        duration = (time.time() - start) * 1000\n        print(f"search_agents: {duration:.2f}ms")\n\n        # Health check\n        health = await registry.health_check()\n        print(f"Health: {health[\'status\']}")\n        print(f"Agents: {health[\'agent_count\']}")\n        print(f"DB size: {health[\'database_size\']}")\n\nimport asyncio\nasyncio.run(benchmark_queries())'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_api_registry_api_35():
    """Test code snippet from api/registry-api.md (line 697)."""
    code = '# For high-concurrency workloads\npool = await asyncpg.create_pool(\n    connection_string,\n    min_size=10,\n    max_size=50,\n    command_timeout=30,\n)\nregistry = AgentRegistry(pool=pool)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_api_registry_api_36():
    """Test code snippet from api/registry-api.md (line 729)."""
    code = '# Increase pool size or timeout\npool = await asyncpg.create_pool(\n    connection_string,\n    max_size=20,\n    command_timeout=120\n)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_deployment_integration_1():
    """Test code snippet from deployment-integration.md (line 20)."""
    code = 'from mycelium_onboarding.config.schema import MyceliumConfig\nfrom mycelium_onboarding.deployment.generator import (\n    DeploymentGenerator,\n    DeploymentMethod\n)\n\ndef setup_deployment(project_name: str, services: dict) -> bool:\n    """Set up deployment for a project."""\n    try:\n        # Create configuration\n        config = MyceliumConfig(\n            project_name=project_name,\n            services=services,\n            deployment={"method": "docker-compose"}\n        )\n\n        # Generate deployment\n        generator = DeploymentGenerator(config)\n        result = generator.generate(DeploymentMethod.DOCKER_COMPOSE)\n\n        if result.success:\n            print(f"Deployment generated at: {result.output_dir}")\n            return True\n        else:\n            print(f"Errors: {result.errors}")\n            return False\n\n    except Exception as e:\n        print(f"Failed to generate deployment: {e}")\n        return False\n\n# Usage\nsuccess = setup_deployment(\n    project_name="my-microservice",\n    services={\n        "redis": {"enabled": True, "port": 6379},\n        "postgres": {"enabled": True}\n    }\n)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_deployment_integration_2():
    """Test code snippet from deployment-integration.md (line 66)."""
    code = 'from mycelium_onboarding.config.manager import ConfigManager\n\ndef load_and_generate():\n    """Load config from file and generate deployment."""\n    manager = ConfigManager()\n\n    try:\n        # Load configuration\n        config = manager.load()\n\n        # Generate deployment\n        generator = DeploymentGenerator(config)\n        result = generator.generate(\n            DeploymentMethod(config.deployment.method)\n        )\n\n        return result\n\n    except FileNotFoundError:\n        print("Configuration not found. Run: mycelium init")\n        return None'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_deployment_integration_3():
    """Test code snippet from deployment-integration.md (line 94)."""
    code = 'from pathlib import Path\n\ndef generate_environments(base_config: MyceliumConfig):\n    """Generate deployments for dev, staging, and production."""\n    environments = {\n        "dev": {\n            "method": DeploymentMethod.DOCKER_COMPOSE,\n            "output": Path("./deploy/dev"),\n            "modifications": {\n                "services": {\n                    "redis": {"max_memory": "128mb"},\n                    "postgres": {"max_connections": 50}\n                }\n            }\n        },\n        "staging": {\n            "method": DeploymentMethod.KUBERNETES,\n            "output": Path("./deploy/staging"),\n            "modifications": {\n                "services": {\n                    "redis": {"max_memory": "512mb"},\n                    "postgres": {"max_connections": 200}\n                }\n            }\n        },\n        "production": {\n            "method": DeploymentMethod.KUBERNETES,\n            "output": Path("./deploy/production"),\n            "modifications": {\n                "services": {\n                    "redis": {"max_memory": "2gb"},\n                    "postgres": {"max_connections": 500}\n                }\n            }\n        }\n    }\n\n    results = {}\n\n    for env_name, env_config in environments.items():\n        # Create environment-specific config\n        env_cfg = base_config.model_copy(deep=True)\n        env_cfg.project_name = f"{base_config.project_name}-{env_name}"\n\n        # Apply modifications\n        for key, value in env_config["modifications"]["services"].items():\n            service = getattr(env_cfg.services, key)\n            for attr, val in value.items():\n                setattr(service, attr, val)\n\n        # Generate deployment\n        generator = DeploymentGenerator(\n            env_cfg,\n            output_dir=env_config["output"]\n        )\n        results[env_name] = generator.generate(env_config["method"])\n\n    return results'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_deployment_integration_4():
    """Test code snippet from deployment-integration.md (line 159)."""
    code = 'import asyncio\nfrom concurrent.futures import ThreadPoolExecutor\n\nasync def generate_deployment_async(\n    config: MyceliumConfig,\n    method: DeploymentMethod\n) -> GenerationResult:\n    """Generate deployment asynchronously."""\n    loop = asyncio.get_event_loop()\n\n    def _generate():\n        generator = DeploymentGenerator(config)\n        return generator.generate(method)\n\n    # Run in thread pool to avoid blocking\n    with ThreadPoolExecutor() as executor:\n        result = await loop.run_in_executor(executor, _generate)\n\n    return result\n\n# Usage with FastAPI\nfrom fastapi import FastAPI, BackgroundTasks\n\napp = FastAPI()\n\n@app.post("/deploy/{project_name}")\nasync def create_deployment(\n    project_name: str,\n    config: dict,\n    background_tasks: BackgroundTasks\n):\n    """API endpoint to generate deployment."""\n    # Validate config\n    mycelium_config = MyceliumConfig(\n        project_name=project_name,\n        **config\n    )\n\n    # Generate asynchronously\n    result = await generate_deployment_async(\n        mycelium_config,\n        DeploymentMethod.DOCKER_COMPOSE\n    )\n\n    return {\n        "success": result.success,\n        "output_dir": str(result.output_dir),\n        "files": [str(f) for f in result.files_generated]\n    }'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_deployment_integration_5():
    """Test code snippet from deployment-integration.md (line 217)."""
    code = 'from mycelium_onboarding.deployment.renderer import TemplateRenderer\n\n# Point to custom templates\nrenderer = TemplateRenderer(\n    templates_dir=Path("./my-templates")\n)\n\n# Render with custom templates\ncontent = renderer.render_docker_compose(config)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_deployment_integration_6():
    """Test code snippet from deployment-integration.md (line 297)."""
    code = '# In Jinja2 templates, access:\n{{ config.project_name }}              # Project name\n{{ config.services.redis.enabled }}    # Service enabled status\n{{ config.services.redis.port }}       # Redis port\n{{ config.services.redis.max_memory }} # Redis memory limit\n{{ config.services.postgres.database }}# PostgreSQL database name\n{{ config.deployment.method }}         # Deployment method'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_deployment_integration_7():
    """Test code snippet from deployment-integration.md (line 311)."""
    code = 'from jinja2 import Environment, FileSystemLoader\n\ndef create_custom_renderer():\n    """Create renderer with custom filters."""\n    env = Environment(\n        loader=FileSystemLoader("./my-templates"),\n        trim_blocks=True,\n        lstrip_blocks=True\n    )\n\n    # Add custom filter\n    def to_memory_mb(memory_str: str) -> int:\n        """Convert memory string to MB."""\n        units = {\'kb\': 1/1024, \'mb\': 1, \'gb\': 1024}\n        value = int(\'\'.join(filter(str.isdigit, memory_str)))\n        unit = \'\'.join(filter(str.isalpha, memory_str)).lower()\n        return int(value * units.get(unit, 1))\n\n    env.filters[\'to_mb\'] = to_memory_mb\n\n    return env\n\n# Use in template:\n# Memory limit: {{ config.services.redis.max_memory|to_mb }} MB'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_deployment_integration_8():
    """Test code snippet from deployment-integration.md (line 344)."""
    code = '# In your code\nclass CustomDeploymentMethod(str, Enum):\n    DOCKER_SWARM = "docker-swarm"\n    NOMAD = "nomad"\n    LAMBDA = "lambda"'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_deployment_integration_9():
    """Test code snippet from deployment-integration.md (line 354)."""
    code = 'from mycelium_onboarding.deployment.generator import DeploymentGenerator\n\nclass ExtendedDeploymentGenerator(DeploymentGenerator):\n    """Extended generator with custom methods."""\n\n    def generate(self, method: DeploymentMethod) -> GenerationResult:\n        """Generate with support for custom methods."""\n        if method == "docker-swarm":\n            return self._generate_docker_swarm()\n        elif method == "nomad":\n            return self._generate_nomad()\n        else:\n            # Fall back to standard methods\n            return super().generate(method)\n\n    def _generate_docker_swarm(self) -> GenerationResult:\n        """Generate Docker Swarm stack file."""\n        self.output_dir.mkdir(parents=True, exist_ok=True)\n        files_generated = []\n\n        try:\n            # Render stack file\n            stack_file = self.output_dir / "docker-stack.yml"\n            content = self._render_swarm_stack()\n            stack_file.write_text(content)\n            files_generated.append(stack_file)\n\n            return GenerationResult(\n                success=True,\n                method="docker-swarm",\n                output_dir=self.output_dir,\n                files_generated=files_generated\n            )\n        except Exception as e:\n            return GenerationResult(\n                success=False,\n                method="docker-swarm",\n                output_dir=self.output_dir,\n                files_generated=files_generated,\n                errors=[str(e)]\n            )\n\n    def _render_swarm_stack(self) -> str:\n        """Render Docker Swarm stack."""\n        # Your rendering logic here\n        pass'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_deployment_integration_10():
    """Test code snippet from deployment-integration.md (line 405)."""
    code = 'config = MyceliumConfig(project_name="swarm-app")\ngenerator = ExtendedDeploymentGenerator(config)\nresult = generator.generate("docker-swarm")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_deployment_integration_11():
    """Test code snippet from deployment-integration.md (line 581)."""
    code = 'from mycelium_onboarding.deployment.secrets import SecretsManager\n\ndef deploy_production(config: MyceliumConfig):\n    """Production deployment with separate secrets."""\n    # Generate deployment files\n    generator = DeploymentGenerator(\n        config,\n        output_dir=Path("/secure/deployments")\n    )\n    result = generator.generate(DeploymentMethod.KUBERNETES)\n\n    # Generate secrets separately\n    secrets_mgr = SecretsManager(\n        config.project_name,\n        secrets_dir=Path("/secure/secrets")\n    )\n    secrets = secrets_mgr.generate_secrets(\n        postgres=config.services.postgres.enabled,\n        redis=config.services.redis.enabled\n    )\n    secrets_mgr.save_secrets(secrets)\n\n    return result'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_deployment_integration_12():
    """Test code snippet from deployment-integration.md (line 609)."""
    code = 'def validate_and_deploy(config: MyceliumConfig) -> bool:\n    """Validate configuration before deploying."""\n    # Validate configuration\n    generator = DeploymentGenerator(config)\n    errors = generator._validate_config(\n        DeploymentMethod(config.deployment.method)\n    )\n\n    if errors:\n        print("Validation errors:")\n        for error in errors:\n            print(f"  - {error}")\n        return False\n\n    # Generate deployment\n    result = generator.generate(\n        DeploymentMethod(config.deployment.method)\n    )\n\n    return result.success'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_deployment_integration_13():
    """Test code snippet from deployment-integration.md (line 634)."""
    code = 'import git\nfrom datetime import datetime\n\ndef version_deployment(config: MyceliumConfig):\n    """Version control generated deployments."""\n    timestamp = datetime.now(UTC).strftime("%Y%m%d-%H%M%S")\n    output_dir = Path(f"./deployments/{timestamp}")\n\n    # Generate deployment\n    generator = DeploymentGenerator(config, output_dir=output_dir)\n    result = generator.generate(\n        DeploymentMethod(config.deployment.method)\n    )\n\n    if result.success:\n        # Commit to git\n        repo = git.Repo(".")\n        repo.index.add([str(output_dir)])\n        repo.index.commit(\n            f"Generated deployment for {config.project_name} at {timestamp}"\n        )\n\n    return result'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_deployment_integration_14():
    """Test code snippet from deployment-integration.md (line 664)."""
    code = 'from mycelium_onboarding.deployment.secrets import SecretsError\nfrom mycelium_onboarding.config.manager import (\n    ConfigLoadError,\n    ConfigValidationError\n)\n\ndef safe_deployment_generation(project_name: str):\n    """Safely generate deployment with error handling."""\n    try:\n        # Load configuration\n        manager = ConfigManager()\n        config = manager.load()\n\n    except FileNotFoundError:\n        print("Error: Configuration file not found")\n        print("Run: mycelium init")\n        return None\n\n    except ConfigLoadError as e:\n        print(f"Error loading configuration: {e}")\n        return None\n\n    except ConfigValidationError as e:\n        print(f"Configuration validation failed: {e}")\n        return None\n\n    try:\n        # Generate deployment\n        generator = DeploymentGenerator(config)\n        result = generator.generate(\n            DeploymentMethod(config.deployment.method)\n        )\n\n        if not result.success:\n            print("Deployment generation failed:")\n            for error in result.errors:\n                print(f"  - {error}")\n            return None\n\n        # Generate secrets\n        secrets_mgr = SecretsManager(project_name)\n        secrets = secrets_mgr.generate_secrets(\n            postgres=config.services.postgres.enabled,\n            redis=config.services.redis.enabled\n        )\n        secrets_mgr.save_secrets(secrets)\n\n        return result\n\n    except SecretsError as e:\n        print(f"Secrets error: {e}")\n        return None\n\n    except Exception as e:\n        print(f"Unexpected error: {e}")\n        import traceback\n        traceback.print_exc()\n        return None'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_deployment_integration_15():
    """Test code snippet from deployment-integration.md (line 729)."""
    code = 'import pytest\nfrom pathlib import Path\n\ndef test_deployment_generation(tmp_path):\n    """Test deployment generation."""\n    config = MyceliumConfig(\n        project_name="test-app",\n        services={"redis": {"enabled": True}}\n    )\n\n    generator = DeploymentGenerator(config, output_dir=tmp_path)\n    result = generator.generate(DeploymentMethod.DOCKER_COMPOSE)\n\n    assert result.success\n    assert (tmp_path / "docker-compose.yml").exists()\n\ndef test_secrets_integration(tmp_path):\n    """Test secrets generation."""\n    manager = SecretsManager("test-app", secrets_dir=tmp_path)\n    secrets = manager.generate_secrets(postgres=True)\n    manager.save_secrets(secrets)\n\n    # Verify secrets were saved\n    assert (tmp_path / "test-app.json").exists()\n\n    # Verify secrets can be loaded\n    loaded = manager.load_secrets()\n    assert loaded.postgres_password == secrets.postgres_password'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_deployment_integration_16():
    """Test code snippet from deployment-integration.md (line 766)."""
    code = 'class DeploymentFactory:\n    """Factory for creating deployments."""\n\n    @staticmethod\n    def create_development(project_name: str) -> GenerationResult:\n        """Create development deployment."""\n        config = MyceliumConfig(\n            project_name=project_name,\n            services={\n                "redis": {"enabled": True, "max_memory": "128mb"},\n                "postgres": {"enabled": True, "max_connections": 50}\n            },\n            deployment={"method": "docker-compose"}\n        )\n\n        generator = DeploymentGenerator(config)\n        return generator.generate(DeploymentMethod.DOCKER_COMPOSE)\n\n    @staticmethod\n    def create_production(project_name: str) -> GenerationResult:\n        """Create production deployment."""\n        config = MyceliumConfig(\n            project_name=project_name,\n            services={\n                "redis": {"enabled": True, "max_memory": "2gb"},\n                "postgres": {"enabled": True, "max_connections": 500}\n            },\n            deployment={\n                "method": "kubernetes",\n                "healthcheck_timeout": 120\n            }\n        )\n\n        generator = DeploymentGenerator(config)\n        return generator.generate(DeploymentMethod.KUBERNETES)\n\n# Usage\ndev_result = DeploymentFactory.create_development("my-app")\nprod_result = DeploymentFactory.create_production("my-app")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_deployment_integration_17():
    """Test code snippet from deployment-integration.md (line 812)."""
    code = 'class DeploymentBuilder:\n    """Builder for deployment configurations."""\n\n    def __init__(self, project_name: str):\n        self.project_name = project_name\n        self.services = {}\n        self.deployment_config = {}\n\n    def with_redis(self, port: int = 6379, **kwargs) -> \'DeploymentBuilder\':\n        """Add Redis service."""\n        self.services["redis"] = {"enabled": True, "port": port, **kwargs}\n        return self\n\n    def with_postgres(self, database: str = "mydb", **kwargs) -> \'DeploymentBuilder\':\n        """Add PostgreSQL service."""\n        self.services["postgres"] = {\n            "enabled": True,\n            "database": database,\n            **kwargs\n        }\n        return self\n\n    def with_method(self, method: str) -> \'DeploymentBuilder\':\n        """Set deployment method."""\n        self.deployment_config["method"] = method\n        return self\n\n    def build(self) -> MyceliumConfig:\n        """Build configuration."""\n        return MyceliumConfig(\n            project_name=self.project_name,\n            services=self.services,\n            deployment=self.deployment_config\n        )\n\n    def generate(self) -> GenerationResult:\n        """Build and generate deployment."""\n        config = self.build()\n        generator = DeploymentGenerator(config)\n        return generator.generate(\n            DeploymentMethod(self.deployment_config.get("method", "docker-compose"))\n        )\n\n# Usage\nresult = (DeploymentBuilder("my-app")\n    .with_redis(port=6380, max_memory="512mb")\n    .with_postgres(database="production")\n    .with_method("kubernetes")\n    .generate())'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_deployment_integration_18():
    """Test code snippet from deployment-integration.md (line 868)."""
    code = 'def generate_with_monitoring(config: MyceliumConfig):\n    """Generate deployment with monitoring stack."""\n    # Generate base deployment\n    generator = DeploymentGenerator(config)\n    result = generator.generate(DeploymentMethod.DOCKER_COMPOSE)\n\n    if result.success:\n        # Add monitoring services\n        compose_file = result.output_dir / "docker-compose.yml"\n        compose_config = yaml.safe_load(compose_file.read_text())\n\n        # Add Prometheus\n        compose_config["services"]["prometheus"] = {\n            "image": "prom/prometheus:latest",\n            "ports": ["9090:9090"],\n            "volumes": ["./prometheus.yml:/etc/prometheus/prometheus.yml"]\n        }\n\n        # Add Grafana\n        compose_config["services"]["grafana"] = {\n            "image": "grafana/grafana:latest",\n            "ports": ["3000:3000"],\n            "environment": {\n                "GF_SECURITY_ADMIN_PASSWORD": "admin"\n            }\n        }\n\n        # Write updated config\n        compose_file.write_text(yaml.dump(compose_config))\n\n    return result'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_deployment_reference_1():
    """Test code snippet from deployment-reference.md (line 19)."""
    code = 'from mycelium_onboarding.deployment.generator import DeploymentGenerator, DeploymentMethod\nfrom mycelium_onboarding.config.schema import MyceliumConfig\n\nconfig = MyceliumConfig(project_name="my-app")\ngenerator = DeploymentGenerator(config)\nresult = generator.generate(DeploymentMethod.DOCKER_COMPOSE)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_deployment_reference_2():
    """Test code snippet from deployment-reference.md (line 30)."""
    code = 'def __init__(self, config: MyceliumConfig, output_dir: Path | None = None) -> None'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_deployment_reference_3():
    """Test code snippet from deployment-reference.md (line 40)."""
    code = '# Use default output directory\ngenerator = DeploymentGenerator(config)\n\n# Use custom output directory\ngenerator = DeploymentGenerator(config, output_dir=Path("/tmp/deploy"))'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_deployment_reference_4():
    """Test code snippet from deployment-reference.md (line 54)."""
    code = 'def generate(self, method: DeploymentMethod) -> GenerationResult'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_deployment_reference_5():
    """Test code snippet from deployment-reference.md (line 74)."""
    code = 'result = generator.generate(DeploymentMethod.DOCKER_COMPOSE)\n\nif result.success:\n    print(f"Generated {len(result.files_generated)} files")\n    print(f"Output: {result.output_dir}")\nelse:\n    print("Errors:", result.errors)\n\n# Check warnings\nif result.warnings:\n    for warning in result.warnings:\n        print(f"Warning: {warning}")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_deployment_reference_6():
    """Test code snippet from deployment-reference.md (line 93)."""
    code = 'def _validate_config(self, method: DeploymentMethod) -> list[str]'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_deployment_reference_7():
    """Test code snippet from deployment-reference.md (line 116)."""
    code = 'errors = generator._validate_config(DeploymentMethod.KUBERNETES)\nif errors:\n    for error in errors:\n        print(f"Validation error: {error}")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_deployment_reference_8():
    """Test code snippet from deployment-reference.md (line 127)."""
    code = '@dataclass\nclass GenerationResult:\n    success: bool\n    method: DeploymentMethod\n    output_dir: Path\n    files_generated: list[Path]\n    errors: list[str] = field(default_factory=list)\n    warnings: list[str] = field(default_factory=list)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_deployment_reference_9():
    """Test code snippet from deployment-reference.md (line 147)."""
    code = 'result = generator.generate(DeploymentMethod.KUBERNETES)\n\n# Check result\nif result.success:\n    print(f"Success! Generated {len(result.files_generated)} files:")\n    for file in result.files_generated:\n        print(f"  - {file.name}")\n\n    # Handle warnings\n    if result.warnings:\n        print("\\nWarnings:")\n        for warning in result.warnings:\n            print(f"  ! {warning}")\nelse:\n    print("Generation failed:")\n    for error in result.errors:\n        print(f"  × {error}")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_deployment_reference_10():
    """Test code snippet from deployment-reference.md (line 171)."""
    code = 'class DeploymentMethod(str, Enum):\n    DOCKER_COMPOSE = "docker-compose"\n    KUBERNETES = "kubernetes"\n    SYSTEMD = "systemd"\n    MANUAL = "manual"'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_deployment_reference_11():
    """Test code snippet from deployment-reference.md (line 180)."""
    code = 'from mycelium_onboarding.deployment.generator import DeploymentMethod\n\n# Use enum values\nmethod = DeploymentMethod.KUBERNETES\nprint(method.value)  # "kubernetes"\n\n# Create from string\nmethod = DeploymentMethod("docker-compose")\n\n# Compare\nif method == DeploymentMethod.DOCKER_COMPOSE:\n    print("Using Docker Compose")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_deployment_reference_12():
    """Test code snippet from deployment-reference.md (line 201)."""
    code = 'from mycelium_onboarding.deployment.secrets import SecretsManager\n\nmanager = SecretsManager("my-project")\nsecrets = manager.generate_secrets(postgres=True, redis=True)\nmanager.save_secrets(secrets)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_deployment_reference_13():
    """Test code snippet from deployment-reference.md (line 211)."""
    code = 'def __init__(self, project_name: str, secrets_dir: Path | None = None) -> None'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_deployment_reference_14():
    """Test code snippet from deployment-reference.md (line 221)."""
    code = '# Use default directory\nmanager = SecretsManager("my-app")\n\n# Use custom directory\nmanager = SecretsManager("my-app", secrets_dir=Path("/secure/location"))'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_deployment_reference_15():
    """Test code snippet from deployment-reference.md (line 235)."""
    code = 'def generate_secrets(\n    self,\n    postgres: bool = False,\n    redis: bool = False,\n    temporal: bool = False,\n    overwrite: bool = False,\n) -> DeploymentSecrets'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_deployment_reference_16():
    """Test code snippet from deployment-reference.md (line 255)."""
    code = '# Generate secrets for PostgreSQL and Redis\nsecrets = manager.generate_secrets(postgres=True, redis=True)\n\n# Preserve existing secrets (default)\nsecrets = manager.generate_secrets(postgres=True, overwrite=False)\n\n# Force regenerate all secrets\nsecrets = manager.generate_secrets(\n    postgres=True,\n    redis=True,\n    temporal=True,\n    overwrite=True\n)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_deployment_reference_17():
    """Test code snippet from deployment-reference.md (line 275)."""
    code = 'def save_secrets(self, secrets_obj: DeploymentSecrets) -> None'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_deployment_reference_18():
    """Test code snippet from deployment-reference.md (line 290)."""
    code = 'secrets = manager.generate_secrets(postgres=True)\n\ntry:\n    manager.save_secrets(secrets)\n    print("Secrets saved securely")\nexcept SecretsError as e:\n    print(f"Failed to save: {e}")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_deployment_reference_19():
    """Test code snippet from deployment-reference.md (line 304)."""
    code = 'def load_secrets(self) -> DeploymentSecrets | None'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_deployment_reference_20():
    """Test code snippet from deployment-reference.md (line 312)."""
    code = 'secrets = manager.load_secrets()\n\nif secrets:\n    print(f"Loaded secrets for: {secrets.project_name}")\n    env_vars = secrets.to_env_vars()\nelse:\n    print("No secrets found")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_deployment_reference_21():
    """Test code snippet from deployment-reference.md (line 326)."""
    code = 'def rotate_secret(self, secret_type: str) -> DeploymentSecrets'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_deployment_reference_22():
    """Test code snippet from deployment-reference.md (line 344)."""
    code = '# Rotate PostgreSQL password\ntry:\n    rotated = manager.rotate_secret("postgres")\n    print("Password rotated successfully")\nexcept ValueError as e:\n    print(f"Rotation failed: {e}")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_deployment_reference_23():
    """Test code snippet from deployment-reference.md (line 357)."""
    code = 'def delete_secrets(self) -> bool'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_deployment_reference_24():
    """Test code snippet from deployment-reference.md (line 365)."""
    code = 'if manager.delete_secrets():\n    print("Secrets deleted")\nelse:\n    print("No secrets to delete")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_deployment_reference_25():
    """Test code snippet from deployment-reference.md (line 376)."""
    code = '@dataclass\nclass DeploymentSecrets:\n    project_name: str\n    postgres_password: str | None = None\n    redis_password: str | None = None\n    temporal_admin_password: str | None = None'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_deployment_reference_26():
    """Test code snippet from deployment-reference.md (line 397)."""
    code = 'def to_env_vars(self) -> dict[str, str]'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_deployment_reference_27():
    """Test code snippet from deployment-reference.md (line 405)."""
    code = 'secrets = DeploymentSecrets(\n    project_name="my-app",\n    postgres_password="secret123",\n    redis_password="secret456"\n)\n\nenv_vars = secrets.to_env_vars()\n# {\n#     "POSTGRES_PASSWORD": "secret123",\n#     "REDIS_PASSWORD": "secret456"\n# }\n\n# Use in deployment\nimport os\nfor key, value in env_vars.items():\n    os.environ[key] = value'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_deployment_reference_28():
    """Test code snippet from deployment-reference.md (line 430)."""
    code = 'def generate_env_file(secrets: DeploymentSecrets, output_path: Path) -> None'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_deployment_reference_29():
    """Test code snippet from deployment-reference.md (line 442)."""
    code = 'from mycelium_onboarding.deployment.secrets import generate_env_file\n\nsecrets = manager.load_secrets()\ngenerate_env_file(secrets, Path(".env"))'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_deployment_reference_30():
    """Test code snippet from deployment-reference.md (line 453)."""
    code = 'class SecretsError(Exception):\n    pass'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_deployment_reference_31():
    """Test code snippet from deployment-reference.md (line 459)."""
    code = 'from mycelium_onboarding.deployment.secrets import SecretsError\n\ntry:\n    manager.save_secrets(secrets)\nexcept SecretsError as e:\n    print(f"Secrets operation failed: {e}")\n    # Handle error...'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_deployment_reference_32():
    """Test code snippet from deployment-reference.md (line 475)."""
    code = 'from mycelium_onboarding.deployment.renderer import TemplateRenderer\n\nrenderer = TemplateRenderer()\ncontent = renderer.render_docker_compose(config)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_deployment_reference_33():
    """Test code snippet from deployment-reference.md (line 484)."""
    code = 'def __init__(self, templates_dir: Path | None = None) -> None'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_deployment_reference_34():
    """Test code snippet from deployment-reference.md (line 493)."""
    code = '# Use built-in templates\nrenderer = TemplateRenderer()\n\n# Use custom templates\nrenderer = TemplateRenderer(templates_dir=Path("./my-templates"))'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_deployment_reference_35():
    """Test code snippet from deployment-reference.md (line 507)."""
    code = 'def render_docker_compose(self, config: MyceliumConfig) -> str'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_deployment_reference_36():
    """Test code snippet from deployment-reference.md (line 518)."""
    code = 'config = MyceliumConfig(\n    project_name="my-app",\n    services={"redis": {"enabled": True}}\n)\n\ncompose_yaml = renderer.render_docker_compose(config)\nPath("docker-compose.yml").write_text(compose_yaml)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_deployment_reference_37():
    """Test code snippet from deployment-reference.md (line 532)."""
    code = 'def render_kubernetes(self, config: MyceliumConfig) -> dict[str, str]'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_deployment_reference_38():
    """Test code snippet from deployment-reference.md (line 543)."""
    code = 'manifests = renderer.render_kubernetes(config)\n\nfor filename, content in manifests.items():\n    output_path = Path(f"kubernetes/{filename}")\n    output_path.write_text(content)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_deployment_reference_39():
    """Test code snippet from deployment-reference.md (line 555)."""
    code = 'def render_systemd(self, config: MyceliumConfig) -> dict[str, str]'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_deployment_reference_40():
    """Test code snippet from deployment-reference.md (line 566)."""
    code = 'services = renderer.render_systemd(config)\n\nfor service_name, content in services.items():\n    output_path = Path(f"systemd/{service_name}")\n    output_path.write_text(content)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_deployment_reference_41():
    """Test code snippet from deployment-reference.md (line 578)."""
    code = 'from mycelium_onboarding.config.schema import MyceliumConfig\nfrom mycelium_onboarding.deployment.generator import (\n    DeploymentGenerator,\n    DeploymentMethod\n)\n\n# Create configuration\nconfig = MyceliumConfig(\n    project_name="my-app",\n    services={\n        "redis": {"enabled": True, "port": 6379},\n        "postgres": {"enabled": True, "database": "mydb"}\n    },\n    deployment={"method": "docker-compose"}\n)\n\n# Generate deployment\ngenerator = DeploymentGenerator(config)\nresult = generator.generate(DeploymentMethod.DOCKER_COMPOSE)\n\nif result.success:\n    print(f"Generated files in: {result.output_dir}")\n    for file in result.files_generated:\n        print(f"  - {file}")\nelse:\n    print(f"Failed: {result.errors}")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_deployment_reference_42():
    """Test code snippet from deployment-reference.md (line 609)."""
    code = 'from mycelium_onboarding.deployment.secrets import SecretsManager\n\n# Initialize manager\nmanager = SecretsManager("my-app")\n\n# Generate secrets\nsecrets = manager.generate_secrets(\n    postgres=True,\n    redis=True,\n    temporal=True\n)\n\n# Save securely\nmanager.save_secrets(secrets)\n\n# Load later\nloaded = manager.load_secrets()\nif loaded:\n    env_vars = loaded.to_env_vars()\n    print("Environment variables:", env_vars.keys())'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_deployment_reference_43():
    """Test code snippet from deployment-reference.md (line 634)."""
    code = 'from pathlib import Path\n\nconfig = MyceliumConfig(project_name="multi-deploy")\n\n# Generate Docker Compose\ngenerator = DeploymentGenerator(config, output_dir=Path("./compose"))\ncompose_result = generator.generate(DeploymentMethod.DOCKER_COMPOSE)\n\n# Generate Kubernetes\ngenerator = DeploymentGenerator(config, output_dir=Path("./k8s"))\nk8s_result = generator.generate(DeploymentMethod.KUBERNETES)\n\n# Generate systemd\ngenerator = DeploymentGenerator(config, output_dir=Path("./systemd"))\nsystemd_result = generator.generate(DeploymentMethod.SYSTEMD)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_deployment_reference_44():
    """Test code snippet from deployment-reference.md (line 654)."""
    code = 'from mycelium_onboarding.deployment.renderer import TemplateRenderer\n\nrenderer = TemplateRenderer()\n\n# Render Docker Compose\ncompose_content = renderer.render_docker_compose(config)\n\n# Render Kubernetes\nk8s_manifests = renderer.render_kubernetes(config)\n\n# Process manifests\nfor name, content in k8s_manifests.items():\n    print(f"Manifest: {name}")\n    print(f"Size: {len(content)} bytes")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_deployment_reference_45():
    """Test code snippet from deployment-reference.md (line 673)."""
    code = 'from mycelium_onboarding.deployment.secrets import SecretsError\n\ntry:\n    # Generate deployment\n    result = generator.generate(DeploymentMethod.KUBERNETES)\n\n    if not result.success:\n        print("Validation errors:")\n        for error in result.errors:\n            print(f"  - {error}")\n        sys.exit(1)\n\n    # Generate secrets\n    manager = SecretsManager(config.project_name)\n    secrets = manager.generate_secrets(postgres=True)\n    manager.save_secrets(secrets)\n\nexcept SecretsError as e:\n    print(f"Secrets error: {e}")\nexcept Exception as e:\n    print(f"Unexpected error: {e}")\n    raise'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_deployment_reference_46():
    """Test code snippet from deployment-reference.md (line 700)."""
    code = 'from __future__ import annotations\n\nfrom pathlib import Path\nfrom typing import Any\n\nfrom mycelium_onboarding.config.schema import (\n    MyceliumConfig,\n    DeploymentMethod,\n    ServicesConfig,\n)\nfrom mycelium_onboarding.deployment.generator import (\n    DeploymentGenerator,\n    GenerationResult,\n)\nfrom mycelium_onboarding.deployment.secrets import (\n    SecretsManager,\n    DeploymentSecrets,\n    SecretsError,\n    generate_env_file,\n)\nfrom mycelium_onboarding.deployment.renderer import TemplateRenderer'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_detection_integration_1():
    """Test code snippet from detection-integration.md (line 37)."""
    code = 'from mycelium_onboarding.detection import detect_all\n\ndef check_services():\n    """Check if required services are available."""\n    summary = detect_all()\n\n    if not summary.has_docker:\n        raise RuntimeError("Docker is required but not available")\n\n    if not summary.has_redis:\n        raise RuntimeError("Redis is required but not available")\n\n    print("All required services available")\n    return True\n\n# Run check\ncheck_services()'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_detection_integration_2():
    """Test code snippet from detection-integration.md (line 61)."""
    code = 'from mycelium_onboarding.detection import detect_all\n\ndef initialize_caching():\n    """Initialize caching with Redis if available, else use memory cache."""\n    summary = detect_all()\n\n    if summary.has_redis:\n        # Use Redis for distributed caching\n        import redis\n        redis_instance = summary.redis[0]\n        cache = redis.Redis(\n            host=redis_instance.host,\n            port=redis_instance.port\n        )\n        print(f"Using Redis cache on port {redis_instance.port}")\n    else:\n        # Fallback to in-memory cache\n        from cachetools import TTLCache\n        cache = TTLCache(maxsize=1000, ttl=300)\n        print("Using in-memory cache (Redis not available)")\n\n    return cache\n\ncache = initialize_caching()'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_detection_integration_3():
    """Test code snippet from detection-integration.md (line 92)."""
    code = 'from mycelium_onboarding.detection import detect_all\nfrom packaging import version\n\ndef check_postgres_version(min_version="15.0"):\n    """Ensure PostgreSQL meets minimum version requirement."""\n    summary = detect_all()\n\n    if not summary.has_postgres:\n        raise RuntimeError("PostgreSQL not available")\n\n    pg_instance = summary.postgres[0]\n    if pg_instance.version:\n        detected_version = version.parse(pg_instance.version)\n        required_version = version.parse(min_version)\n\n        if detected_version < required_version:\n            raise RuntimeError(\n                f"PostgreSQL {min_version}+ required, found {pg_instance.version}"\n            )\n\n    print(f"PostgreSQL {pg_instance.version} meets requirements")\n    return True\n\ncheck_postgres_version()'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_detection_integration_4():
    """Test code snippet from detection-integration.md (line 123)."""
    code = 'from mycelium_onboarding.detection import detect_all\n\ndef select_redis_instance(prefer_authenticated=True):\n    """Select appropriate Redis instance based on preferences."""\n    summary = detect_all()\n\n    if not summary.has_redis:\n        return None\n\n    # Filter instances based on preferences\n    if prefer_authenticated:\n        auth_instances = [r for r in summary.redis if r.password_required]\n        if auth_instances:\n            return auth_instances[0]\n\n    # Default to first available\n    return summary.redis[0]\n\nredis_instance = select_redis_instance()\nif redis_instance:\n    print(f"Using Redis on port {redis_instance.port}")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_detection_integration_5():
    """Test code snippet from detection-integration.md (line 153)."""
    code = 'import asyncio\nfrom mycelium_onboarding.detection import detect_all_async\n\nasync def async_service_check():\n    """Async service availability check."""\n    summary = await detect_all_async()\n\n    services = {\n        "docker": summary.has_docker,\n        "redis": summary.has_redis,\n        "postgres": summary.has_postgres,\n        "temporal": summary.has_temporal,\n        "gpu": summary.has_gpu,\n    }\n\n    return services\n\n# Run in async context\nservices = asyncio.run(async_service_check())\nprint(f"Available services: {services}")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_detection_integration_6():
    """Test code snippet from detection-integration.md (line 180)."""
    code = 'from fastapi import FastAPI, HTTPException\nfrom mycelium_onboarding.detection import detect_all_async\n\napp = FastAPI()\n\n@app.get("/health")\nasync def health_check():\n    """Health check endpoint with service detection."""\n    summary = await detect_all_async()\n\n    return {\n        "status": "healthy",\n        "services": {\n            "docker": summary.has_docker,\n            "redis": summary.has_redis,\n            "postgres": summary.has_postgres,\n            "temporal": summary.has_temporal,\n            "gpu": summary.has_gpu,\n        },\n        "detection_time": summary.detection_time,\n    }\n\n@app.get("/health/detailed")\nasync def detailed_health():\n    """Detailed health check with version info."""\n    summary = await detect_all_async()\n\n    details = {\n        "docker": {\n            "available": summary.has_docker,\n            "version": summary.docker.version if summary.has_docker else None,\n        },\n        "redis": {\n            "available": summary.has_redis,\n            "instances": len(summary.redis),\n        },\n        "postgres": {\n            "available": summary.has_postgres,\n            "instances": len(summary.postgres),\n        },\n    }\n\n    return details\n\n@app.on_event("startup")\nasync def startup_event():\n    """Check required services on startup."""\n    summary = await detect_all_async()\n\n    if not summary.has_redis:\n        raise RuntimeError("Redis is required but not available")\n\n    print(f"Startup checks passed in {summary.detection_time:.2f}s")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_detection_integration_7():
    """Test code snippet from detection-integration.md (line 240)."""
    code = 'import asyncio\nfrom mycelium_onboarding.detection import detect_all_async\n\nasync def load_config():\n    """Load application configuration."""\n    await asyncio.sleep(1)  # Simulate config loading\n    return {"app": "myapp", "version": "1.0"}\n\nasync def initialize_database():\n    """Initialize database connection."""\n    await asyncio.sleep(1)  # Simulate DB init\n    return "db_connection"\n\nasync def startup_sequence():\n    """Run multiple startup tasks concurrently."""\n    # Run all tasks in parallel\n    config, db, summary = await asyncio.gather(\n        load_config(),\n        initialize_database(),\n        detect_all_async()\n    )\n\n    print(f"Config: {config}")\n    print(f"Database: {db}")\n    print(f"Services: {summary.has_docker}, {summary.has_redis}")\n\n    return config, db, summary\n\nasyncio.run(startup_sequence())'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_detection_integration_8():
    """Test code snippet from detection-integration.md (line 278)."""
    code = 'from mycelium_onboarding.detection import detect_all, update_config_from_detection\nfrom mycelium_onboarding.config.manager import ConfigManager\n\ndef auto_configure():\n    """Automatically configure services based on detection."""\n    # Detect services\n    print("Detecting services...")\n    summary = detect_all()\n\n    # Load existing config or create new\n    manager = ConfigManager()\n    try:\n        base_config = manager.load()\n        print("Loaded existing configuration")\n    except FileNotFoundError:\n        base_config = None\n        print("Creating new configuration")\n\n    # Update config with detected values\n    config = update_config_from_detection(summary, base_config)\n\n    # Save updated config\n    manager.save(config)\n    print("Configuration updated successfully")\n\n    # Report changes\n    if summary.has_redis:\n        print(f"  Redis: enabled on port {config.services.redis.port}")\n    if summary.has_postgres:\n        print(f"  PostgreSQL: enabled on port {config.services.postgres.port}")\n    if summary.has_temporal:\n        print(f"  Temporal: enabled on ports {config.services.temporal.ui_port}/{config.services.temporal.frontend_port}")\n\n    return config\n\nconfig = auto_configure()'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_detection_integration_9():
    """Test code snippet from detection-integration.md (line 321)."""
    code = 'from mycelium_onboarding.detection import detect_all\nfrom mycelium_onboarding.config.manager import ConfigManager\n\ndef update_redis_config_only():\n    """Update only Redis configuration from detection."""\n    summary = detect_all()\n    manager = ConfigManager()\n    config = manager.load()\n\n    if summary.has_redis:\n        redis_instance = summary.redis[0]\n        config.services.redis.enabled = True\n        config.services.redis.port = redis_instance.port\n\n        if redis_instance.version:\n            config.services.redis.version = redis_instance.version\n\n        manager.save(config)\n        print(f"Updated Redis config: port {redis_instance.port}")\n    else:\n        print("Redis not detected, config unchanged")\n\nupdate_redis_config_only()'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_detection_integration_10():
    """Test code snippet from detection-integration.md (line 351)."""
    code = 'from mycelium_onboarding.detection import detect_all\nfrom mycelium_onboarding.config.manager import ConfigManager\n\ndef validate_config_against_detection():\n    """Validate that configured services are actually available."""\n    manager = ConfigManager()\n    config = manager.load()\n    summary = detect_all()\n\n    issues = []\n\n    # Check Redis\n    if config.services.redis.enabled and not summary.has_redis:\n        issues.append("Redis is enabled in config but not detected")\n\n    # Check PostgreSQL\n    if config.services.postgres.enabled and not summary.has_postgres:\n        issues.append("PostgreSQL is enabled in config but not detected")\n\n    # Check Temporal\n    if config.services.temporal.enabled and not summary.has_temporal:\n        issues.append("Temporal is enabled in config but not detected")\n\n    # Check port mismatches\n    if summary.has_redis:\n        configured_port = config.services.redis.port\n        detected_ports = [r.port for r in summary.redis]\n        if configured_port not in detected_ports:\n            issues.append(\n                f"Redis configured on port {configured_port} but detected on {detected_ports}"\n            )\n\n    if issues:\n        print("Configuration validation issues:")\n        for issue in issues:\n            print(f"  - {issue}")\n        return False\n    else:\n        print("Configuration validated successfully")\n        return True\n\nvalidate_config_against_detection()'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_detection_integration_11():
    """Test code snippet from detection-integration.md (line 402)."""
    code = 'from mycelium_onboarding.detection import detect_all\n\ndef initialize_services_with_fallback():\n    """Initialize services with fallback strategies."""\n    summary = detect_all()\n    services = {}\n\n    # Docker - required\n    if not summary.has_docker:\n        raise RuntimeError(\n            "Docker is required for this application. "\n            "Please install Docker and try again."\n        )\n    services["docker"] = summary.docker\n\n    # Redis - optional with fallback\n    if summary.has_redis:\n        services["cache"] = "redis"\n        print("Using Redis for caching")\n    else:\n        services["cache"] = "memory"\n        print("Warning: Redis not available, using in-memory cache")\n\n    # PostgreSQL - optional with fallback\n    if summary.has_postgres:\n        services["database"] = "postgresql"\n        print("Using PostgreSQL database")\n    else:\n        services["database"] = "sqlite"\n        print("Warning: PostgreSQL not available, using SQLite")\n\n    return services\n\ntry:\n    services = initialize_services_with_fallback()\nexcept RuntimeError as e:\n    print(f"Fatal error: {e}")\n    exit(1)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_detection_integration_12():
    """Test code snippet from detection-integration.md (line 447)."""
    code = 'from mycelium_onboarding.detection import detect_all\n\ndef diagnose_service_issues():\n    """Diagnose and report service availability issues."""\n    summary = detect_all()\n\n    print("Service Diagnostics:")\n    print("=" * 60)\n\n    # Docker\n    if not summary.has_docker:\n        print("❌ Docker: Not Available")\n        if summary.docker.error_message:\n            print(f"   Error: {summary.docker.error_message}")\n        print("   Solution: Install Docker or start Docker daemon")\n    else:\n        print(f"✓ Docker: {summary.docker.version}")\n\n    # Redis\n    if not summary.has_redis:\n        print("❌ Redis: Not Available")\n        print("   Solution: Start Redis on port 6379, 6380, or 6381")\n    else:\n        print(f"✓ Redis: {len(summary.redis)} instance(s)")\n        for redis in summary.redis:\n            auth = " (auth required)" if redis.password_required else ""\n            print(f"   - Port {redis.port}: {redis.version}{auth}")\n\n    # PostgreSQL\n    if not summary.has_postgres:\n        print("❌ PostgreSQL: Not Available")\n        print("   Solution: Start PostgreSQL on port 5432 or 5433")\n    else:\n        print(f"✓ PostgreSQL: {len(summary.postgres)} instance(s)")\n        for pg in summary.postgres:\n            print(f"   - Port {pg.port}: {pg.version}")\n\n    # Temporal\n    if not summary.has_temporal:\n        print("❌ Temporal: Not Available")\n        if summary.temporal.error_message:\n            print(f"   Error: {summary.temporal.error_message}")\n        print("   Solution: Start Temporal server")\n    else:\n        print(f"✓ Temporal: {summary.temporal.version}")\n\n    # GPU\n    if not summary.has_gpu:\n        print("ℹ️  GPU: Not Available (optional)")\n        if summary.gpu.error_message:\n            print(f"   Info: {summary.gpu.error_message}")\n    else:\n        print(f"✓ GPU: {len(summary.gpu.gpus)} device(s)")\n\ndiagnose_service_issues()'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_detection_integration_13():
    """Test code snippet from detection-integration.md (line 509)."""
    code = 'import time\nfrom mycelium_onboarding.detection import detect_all\n\ndef wait_for_services(required_services, max_wait=60, check_interval=5):\n    """Wait for required services to become available."""\n    start_time = time.time()\n\n    while time.time() - start_time < max_wait:\n        summary = detect_all()\n\n        # Check all required services\n        all_available = True\n        for service in required_services:\n            if service == "docker" and not summary.has_docker:\n                all_available = False\n            elif service == "redis" and not summary.has_redis:\n                all_available = False\n            elif service == "postgres" and not summary.has_postgres:\n                all_available = False\n            elif service == "temporal" and not summary.has_temporal:\n                all_available = False\n\n        if all_available:\n            print(f"All required services available after {time.time() - start_time:.1f}s")\n            return True\n\n        print(f"Waiting for services... ({time.time() - start_time:.1f}s)")\n        time.sleep(check_interval)\n\n    print(f"Timeout: Services not available after {max_wait}s")\n    return False\n\n# Wait for services\nrequired = ["docker", "redis", "postgres"]\nif wait_for_services(required):\n    print("Starting application...")\nelse:\n    print("Cannot start: Required services unavailable")\n    exit(1)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_detection_integration_14():
    """Test code snippet from detection-integration.md (line 557)."""
    code = 'import time\nfrom functools import wraps\nfrom mycelium_onboarding.detection import detect_all\n\n# Simple cache with TTL\n_detection_cache = None\n_cache_timestamp = 0\n_cache_ttl = 60  # seconds\n\ndef cached_detect_all(ttl=60):\n    """Detect all services with caching."""\n    global _detection_cache, _cache_timestamp, _cache_ttl\n\n    _cache_ttl = ttl\n    current_time = time.time()\n\n    # Return cached result if still valid\n    if _detection_cache and (current_time - _cache_timestamp) < _cache_ttl:\n        return _detection_cache\n\n    # Run detection and cache result\n    _detection_cache = detect_all()\n    _cache_timestamp = current_time\n\n    return _detection_cache\n\n# Usage\nsummary1 = cached_detect_all(ttl=60)  # Runs detection\nsummary2 = cached_detect_all(ttl=60)  # Returns cached (fast)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_detection_integration_15():
    """Test code snippet from detection-integration.md (line 593)."""
    code = 'from mycelium_onboarding.detection.docker_detector import detect_docker\nfrom mycelium_onboarding.detection.redis_detector import detect_redis\n\ndef quick_check():\n    """Quick check of only critical services."""\n    docker = detect_docker()\n    redis = detect_redis()\n\n    if not docker.available:\n        raise RuntimeError("Docker required")\n\n    print(f"Docker: {docker.version}")\n    print(f"Redis: {\'available\' if redis.available else \'unavailable\'}")\n\nquick_check()'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_detection_integration_16():
    """Test code snippet from detection-integration.md (line 615)."""
    code = 'import threading\nfrom mycelium_onboarding.detection import detect_all\n\nclass BackgroundDetector:\n    """Run detection in background with periodic updates."""\n\n    def __init__(self, interval=60):\n        self.interval = interval\n        self.summary = None\n        self.running = False\n        self.thread = None\n\n    def start(self):\n        """Start background detection."""\n        self.running = True\n        self.thread = threading.Thread(target=self._run, daemon=True)\n        self.thread.start()\n\n    def stop(self):\n        """Stop background detection."""\n        self.running = False\n        if self.thread:\n            self.thread.join()\n\n    def _run(self):\n        """Background detection loop."""\n        while self.running:\n            self.summary = detect_all()\n            time.sleep(self.interval)\n\n    def get_summary(self):\n        """Get latest detection summary."""\n        if self.summary is None:\n            self.summary = detect_all()\n        return self.summary\n\n# Usage\ndetector = BackgroundDetector(interval=30)\ndetector.start()\n\n# Later...\nsummary = detector.get_summary()\nprint(f"Services: {summary.has_docker}, {summary.has_redis}")\n\n# Cleanup\ndetector.stop()'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_detection_integration_17():
    """Test code snippet from detection-integration.md (line 670)."""
    code = 'from mycelium_onboarding.detection import detect_all\n\ndef preflight_checks():\n    """Run pre-flight service checks."""\n    print("Running pre-flight checks...")\n\n    summary = detect_all()\n\n    # Define requirements\n    requirements = {\n        "docker": ("required", summary.has_docker),\n        "redis": ("required", summary.has_redis),\n        "postgres": ("required", summary.has_postgres),\n        "temporal": ("optional", summary.has_temporal),\n        "gpu": ("optional", summary.has_gpu),\n    }\n\n    # Check requirements\n    failed_required = []\n    missing_optional = []\n\n    for service, (level, available) in requirements.items():\n        if level == "required" and not available:\n            failed_required.append(service)\n        elif level == "optional" and not available:\n            missing_optional.append(service)\n\n    # Report\n    if failed_required:\n        print(f"❌ Missing required services: {\', \'.join(failed_required)}")\n        return False\n\n    if missing_optional:\n        print(f"⚠️  Missing optional services: {\', \'.join(missing_optional)}")\n\n    print(f"✓ Pre-flight checks passed in {summary.detection_time:.2f}s")\n    return True\n\nif __name__ == "__main__":\n    if preflight_checks():\n        # Start application\n        print("Starting application...")\n    else:\n        print("Cannot start application")\n        exit(1)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_detection_integration_18():
    """Test code snippet from detection-integration.md (line 722)."""
    code = 'from mycelium_onboarding.detection import detect_all\nimport redis\nimport psycopg2\n\ndef connect_to_services():\n    """Connect to detected services."""\n    summary = detect_all()\n    connections = {}\n\n    # Connect to Redis\n    if summary.has_redis:\n        redis_instance = summary.redis[0]\n        connections["redis"] = redis.Redis(\n            host=redis_instance.host,\n            port=redis_instance.port,\n            decode_responses=True\n        )\n        print(f"Connected to Redis on port {redis_instance.port}")\n\n    # Connect to PostgreSQL\n    if summary.has_postgres:\n        pg_instance = summary.postgres[0]\n        connections["postgres"] = psycopg2.connect(\n            host=pg_instance.host,\n            port=pg_instance.port,\n            dbname="postgres",\n            user="postgres"\n        )\n        print(f"Connected to PostgreSQL on port {pg_instance.port}")\n\n    return connections\n\nconnections = connect_to_services()'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_detection_integration_19():
    """Test code snippet from detection-integration.md (line 762)."""
    code = 'from mycelium_onboarding.detection import detect_all\n\ndef determine_environment():\n    """Determine environment type based on detected services."""\n    summary = detect_all()\n\n    # Development environment\n    if summary.has_docker and summary.has_redis and summary.has_postgres:\n        if len(summary.redis) == 1 and len(summary.postgres) == 1:\n            return "development"\n\n    # Production environment\n    if summary.has_redis and summary.has_postgres and summary.has_temporal:\n        if len(summary.redis) > 1 or len(summary.postgres) > 1:\n            return "production"\n\n    # CI environment\n    if summary.has_docker and not summary.has_gpu:\n        return "ci"\n\n    return "unknown"\n\nenv = determine_environment()\nprint(f"Detected environment: {env}")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_detection_integration_20():
    """Test code snippet from detection-integration.md (line 793)."""
    code = 'from flask import Flask, jsonify\nfrom mycelium_onboarding.detection import detect_all\n\napp = Flask(__name__)\n\n@app.route("/health")\ndef health():\n    """Health check endpoint."""\n    summary = detect_all()\n    return jsonify({\n        "status": "healthy",\n        "services": {\n            "docker": summary.has_docker,\n            "redis": summary.has_redis,\n            "postgres": summary.has_postgres,\n        }\n    })\n\n@app.before_first_request\ndef check_services():\n    """Check services before handling first request."""\n    summary = detect_all()\n    if not summary.has_redis:\n        app.logger.warning("Redis not available")\n\nif __name__ == "__main__":\n    app.run()'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_detection_integration_21():
    """Test code snippet from detection-integration.md (line 825)."""
    code = '# myapp/apps.py\nfrom django.apps import AppConfig\nfrom mycelium_onboarding.detection import detect_all\n\nclass MyAppConfig(AppConfig):\n    name = "myapp"\n\n    def ready(self):\n        """Check services on Django startup."""\n        summary = detect_all()\n\n        if not summary.has_redis:\n            import warnings\n            warnings.warn("Redis not available, some features will be disabled")\n\n        # Store in Django cache\n        from django.core.cache import cache\n        cache.set("service_detection", {\n            "docker": summary.has_docker,\n            "redis": summary.has_redis,\n            "postgres": summary.has_postgres,\n        }, 60)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_detection_integration_22():
    """Test code snippet from detection-integration.md (line 852)."""
    code = '# celery.py\nfrom celery import Celery\nfrom mycelium_onboarding.detection import detect_all\n\napp = Celery("myapp")\n\n@app.on_after_configure.connect\ndef check_broker(sender, **kwargs):\n    """Check if broker (Redis) is available."""\n    summary = detect_all()\n\n    if not summary.has_redis:\n        raise RuntimeError("Redis broker not available")\n\n    print(f"Using Redis broker on port {summary.redis[0].port}")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_detection_integration_23():
    """Test code snippet from detection-integration.md (line 876)."""
    code = '# test_myapp.py\nimport pytest\nfrom unittest.mock import patch\nfrom mycelium_onboarding.detection.docker_detector import DockerDetectionResult\n\ndef test_with_docker_available():\n    """Test behavior when Docker is available."""\n    with patch("mycelium_onboarding.detection.detect_docker") as mock:\n        mock.return_value = DockerDetectionResult(\n            available=True,\n            version="24.0.5",\n            socket_path="/var/run/docker.sock",\n            error_message=None\n        )\n\n        # Your test code here\n        from myapp import check_docker\n        assert check_docker() == True\n\ndef test_with_docker_unavailable():\n    """Test behavior when Docker is unavailable."""\n    with patch("mycelium_onboarding.detection.detect_docker") as mock:\n        mock.return_value = DockerDetectionResult(\n            available=False,\n            version=None,\n            socket_path=None,\n            error_message="Docker not running"\n        )\n\n        # Your test code here\n        from myapp import check_docker\n        with pytest.raises(RuntimeError):\n            check_docker()'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_detection_integration_24():
    """Test code snippet from detection-integration.md (line 916)."""
    code = '# conftest.py\nimport pytest\nfrom mycelium_onboarding.detection import DetectionSummary\nfrom mycelium_onboarding.detection.docker_detector import DockerDetectionResult\n# ... import other result types\n\n@pytest.fixture\ndef all_services_available():\n    """Fixture with all services available."""\n    return DetectionSummary(\n        docker=DockerDetectionResult(available=True, version="24.0.5", socket_path="/var/run/docker.sock", error_message=None),\n        redis=[RedisDetectionResult(available=True, host="localhost", port=6379, version="7.2.3", password_required=False, error_message=None)],\n        postgres=[PostgresDetectionResult(available=True, host="localhost", port=5432, version="15.4", authentication_method="trust", error_message=None)],\n        temporal=TemporalDetectionResult(available=True, frontend_port=7233, ui_port=8233, version="1.22.3", error_message=None),\n        gpu=GPUDetectionResult(available=False, gpus=[], total_memory_mb=0, error_message="No GPU"),\n        detection_time=2.0\n    )\n\n# Use in tests\ndef test_with_services(all_services_available):\n    """Test using the fixture."""\n    assert all_services_available.has_docker\n    assert all_services_available.has_redis'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_detection_integration_25():
    """Test code snippet from detection-integration.md (line 948)."""
    code = 'from fastapi import FastAPI, status\nfrom mycelium_onboarding.detection import detect_all\n\napp = FastAPI()\n\n@app.get("/health/liveness")\nasync def liveness():\n    """Liveness probe - is the application running?"""\n    return {"status": "alive"}\n\n@app.get("/health/readiness")\nasync def readiness():\n    """Readiness probe - can the application serve traffic?"""\n    summary = detect_all()\n\n    # Check critical services\n    if not summary.has_redis or not summary.has_postgres:\n        return JSONResponse(\n            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,\n            content={"status": "not ready", "reason": "required services unavailable"}\n        )\n\n    return {"status": "ready"}\n\n@app.get("/health/startup")\nasync def startup():\n    """Startup probe - has initialization completed?"""\n    # Perform full detection\n    summary = detect_all()\n\n    if summary.detection_time > 10.0:\n        return JSONResponse(\n            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,\n            content={"status": "starting", "reason": "detection too slow"}\n        )\n\n    return {"status": "started"}'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_detection_integration_26():
    """Test code snippet from detection-integration.md (line 992)."""
    code = 'from prometheus_client import Gauge, Counter\nfrom mycelium_onboarding.detection import detect_all\n\n# Define metrics\ndocker_available = Gauge("mycelium_docker_available", "Docker availability")\nredis_available = Gauge("mycelium_redis_available", "Redis availability")\ndetection_time = Gauge("mycelium_detection_time_seconds", "Detection time")\ndetection_count = Counter("mycelium_detection_total", "Total detections")\n\ndef update_metrics():\n    """Update Prometheus metrics from detection."""\n    summary = detect_all()\n\n    docker_available.set(1 if summary.has_docker else 0)\n    redis_available.set(1 if summary.has_redis else 0)\n    detection_time.set(summary.detection_time)\n    detection_count.inc()\n\n# Run periodically\nimport schedule\nschedule.every(60).seconds.do(update_metrics)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_detection_integration_27():
    """Test code snippet from detection-integration.md (line 1020)."""
    code = 'import signal\nimport sys\nfrom mycelium_onboarding.detection import detect_all\n\nclass Application:\n    def __init__(self):\n        self.running = True\n        self.services = None\n\n    def startup(self):\n        """Application startup."""\n        print("Detecting services...")\n        summary = detect_all()\n        self.services = summary\n\n        # Register signal handlers\n        signal.signal(signal.SIGINT, self.shutdown)\n        signal.signal(signal.SIGTERM, self.shutdown)\n\n    def shutdown(self, signum, frame):\n        """Graceful shutdown."""\n        print("Shutting down...")\n        self.running = False\n        sys.exit(0)\n\n    def run(self):\n        """Application main loop."""\n        self.startup()\n        while self.running:\n            # Application logic\n            time.sleep(1)\n\napp = Application()\napp.run()'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_detection_reference_1():
    """Test code snippet from detection-reference.md (line 22)."""
    code = 'from mycelium_onboarding.detection import (\n    detect_all,\n    detect_all_async,\n    DetectionSummary,\n    generate_detection_report,\n    update_config_from_detection,\n)\n\nfrom mycelium_onboarding.detection.docker_detector import detect_docker\nfrom mycelium_onboarding.detection.redis_detector import detect_redis, scan_common_redis_ports\nfrom mycelium_onboarding.detection.postgres_detector import detect_postgres, scan_common_postgres_ports\nfrom mycelium_onboarding.detection.temporal_detector import detect_temporal\nfrom mycelium_onboarding.detection.gpu_detector import detect_gpus'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_detection_reference_2():
    """Test code snippet from detection-reference.md (line 47)."""
    code = 'def detect_all() -> DetectionSummary'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_detection_reference_3():
    """Test code snippet from detection-reference.md (line 60)."""
    code = 'from mycelium_onboarding.detection import detect_all\n\nsummary = detect_all()\n\nif summary.has_docker:\n    print(f"Docker {summary.docker.version} available")\n\nif summary.has_redis:\n    for redis in summary.redis:\n        print(f"Redis instance on port {redis.port}")\n\nprint(f"Detection completed in {summary.detection_time:.2f}s")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_detection_reference_4():
    """Test code snippet from detection-reference.md (line 87)."""
    code = 'async def detect_all_async() -> DetectionSummary'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_detection_reference_5():
    """Test code snippet from detection-reference.md (line 95)."""
    code = 'import asyncio\nfrom mycelium_onboarding.detection import detect_all_async\n\nasync def main():\n    summary = await detect_all_async()\n    print(f"Found {len(summary.redis)} Redis instances")\n\nasyncio.run(main())'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_detection_reference_6():
    """Test code snippet from detection-reference.md (line 118)."""
    code = 'def generate_detection_report(\n    summary: DetectionSummary,\n    format: str = "text"\n) -> str'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_detection_reference_7():
    """Test code snippet from detection-reference.md (line 136)."""
    code = 'from mycelium_onboarding.detection import detect_all, generate_detection_report\n\nsummary = detect_all()\n\n# Human-readable text\ntext_report = generate_detection_report(summary, format="text")\nprint(text_report)\n\n# Machine-readable JSON\njson_report = generate_detection_report(summary, format="json")\nimport json\ndata = json.loads(json_report)\n\n# YAML for config management\nyaml_report = generate_detection_report(summary, format="yaml")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_detection_reference_8():
    """Test code snippet from detection-reference.md (line 161)."""
    code = 'def update_config_from_detection(\n    summary: DetectionSummary,\n    base_config: MyceliumConfig | None = None\n) -> MyceliumConfig'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_detection_reference_9():
    """Test code snippet from detection-reference.md (line 182)."""
    code = 'from mycelium_onboarding.detection import detect_all, update_config_from_detection\nfrom mycelium_onboarding.config.manager import ConfigManager\n\n# Detect services\nsummary = detect_all()\n\n# Load existing config\nmanager = ConfigManager()\nexisting_config = manager.load()\n\n# Update config with detected values\nupdated_config = update_config_from_detection(summary, existing_config)\n\n# Save updated config\nmanager.save(updated_config)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_detection_reference_10():
    """Test code snippet from detection-reference.md (line 207)."""
    code = '@dataclass\nclass DetectionSummary:\n    docker: DockerDetectionResult\n    redis: list[RedisDetectionResult]\n    postgres: list[PostgresDetectionResult]\n    temporal: TemporalDetectionResult\n    gpu: GPUDetectionResult\n    detection_time: float  # Total time in seconds'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_detection_reference_11():
    """Test code snippet from detection-reference.md (line 220)."""
    code = '@property\ndef has_docker(self) -> bool:\n    """Check if Docker is available."""\n    return self.docker.available\n\n@property\ndef has_redis(self) -> bool:\n    """Check if at least one Redis instance is available."""\n    return any(r.available for r in self.redis)\n\n@property\ndef has_postgres(self) -> bool:\n    """Check if at least one PostgreSQL instance is available."""\n    return any(p.available for p in self.postgres)\n\n@property\ndef has_temporal(self) -> bool:\n    """Check if Temporal is available."""\n    return self.temporal.available\n\n@property\ndef has_gpu(self) -> bool:\n    """Check if at least one GPU is available."""\n    return self.gpu.available'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_detection_reference_12():
    """Test code snippet from detection-reference.md (line 248)."""
    code = 'summary = detect_all()\n\n# Check availability\nif summary.has_docker:\n    print(f"Docker version: {summary.docker.version}")\n\n# Access multiple instances\nif summary.has_redis:\n    print(f"Found {len(summary.redis)} Redis instance(s)")\n    for i, redis in enumerate(summary.redis, 1):\n        print(f"  {i}. {redis.host}:{redis.port}")\n\n# Check detection performance\nif summary.detection_time > 5.0:\n    print("Warning: Detection took longer than expected")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_detection_reference_13():
    """Test code snippet from detection-reference.md (line 273)."""
    code = 'def detect_docker() -> DockerDetectionResult'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_detection_reference_14():
    """Test code snippet from detection-reference.md (line 287)."""
    code = 'from mycelium_onboarding.detection.docker_detector import detect_docker\n\nresult = detect_docker()\n\nif result.available:\n    print(f"Docker {result.version} available at {result.socket_path}")\nelse:\n    print(f"Docker unavailable: {result.error_message}")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_detection_reference_15():
    """Test code snippet from detection-reference.md (line 303)."""
    code = 'def verify_docker_permissions() -> tuple[bool, str]'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_detection_reference_16():
    """Test code snippet from detection-reference.md (line 315)."""
    code = 'from mycelium_onboarding.detection.docker_detector import verify_docker_permissions\n\nhas_perms, message = verify_docker_permissions()\nif not has_perms:\n    print(f"Permission issue: {message}")\n    print("Try: sudo usermod -aG docker $USER")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_detection_reference_17():
    """Test code snippet from detection-reference.md (line 329)."""
    code = '@dataclass\nclass DockerDetectionResult:\n    available: bool\n    version: str | None\n    socket_path: str | None\n    error_message: str | None'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_detection_reference_18():
    """Test code snippet from detection-reference.md (line 353)."""
    code = 'def scan_common_redis_ports(\n    host: str = "localhost",\n    ports: list[int] | None = None,\n    timeout: float = 1.0\n) -> list[RedisDetectionResult]'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_detection_reference_19():
    """Test code snippet from detection-reference.md (line 370)."""
    code = 'from mycelium_onboarding.detection.redis_detector import scan_common_redis_ports\n\n# Scan default ports\ninstances = scan_common_redis_ports()\nfor redis in instances:\n    print(f"Redis {redis.version} on port {redis.port}")\n\n# Scan custom ports\ncustom_instances = scan_common_redis_ports(\n    host="localhost",\n    ports=[6379, 6400, 6500],\n    timeout=2.0\n)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_detection_reference_20():
    """Test code snippet from detection-reference.md (line 393)."""
    code = 'def detect_redis(\n    host: str = "localhost",\n    port: int = 6379,\n    timeout: float = 1.0\n) -> RedisDetectionResult'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_detection_reference_21():
    """Test code snippet from detection-reference.md (line 410)."""
    code = 'from mycelium_onboarding.detection.redis_detector import detect_redis\n\nresult = detect_redis(host="localhost", port=6379)\nif result.available:\n    if result.password_required:\n        print("Redis requires authentication")\n    else:\n        print(f"Redis {result.version} accessible")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_detection_reference_22():
    """Test code snippet from detection-reference.md (line 426)."""
    code = '@dataclass\nclass RedisDetectionResult:\n    available: bool\n    host: str\n    port: int\n    version: str | None\n    password_required: bool\n    error_message: str | None'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_detection_reference_23():
    """Test code snippet from detection-reference.md (line 454)."""
    code = 'def scan_common_postgres_ports(\n    host: str = "localhost",\n    ports: list[int] | None = None,\n    timeout: float = 2.0\n) -> list[PostgresDetectionResult]'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_detection_reference_24():
    """Test code snippet from detection-reference.md (line 471)."""
    code = 'from mycelium_onboarding.detection.postgres_detector import scan_common_postgres_ports\n\ninstances = scan_common_postgres_ports()\nfor pg in instances:\n    print(f"PostgreSQL {pg.version} on port {pg.port}")\n    print(f"  Auth method: {pg.authentication_method}")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_detection_reference_25():
    """Test code snippet from detection-reference.md (line 487)."""
    code = 'def detect_postgres(\n    host: str = "localhost",\n    port: int = 5432,\n    timeout: float = 2.0\n) -> PostgresDetectionResult'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_detection_reference_26():
    """Test code snippet from detection-reference.md (line 504)."""
    code = 'from mycelium_onboarding.detection.postgres_detector import detect_postgres\n\nresult = detect_postgres(host="localhost", port=5432)\nif result.available:\n    print(f"PostgreSQL {result.version}")\n    print(f"Authentication: {result.authentication_method}")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_detection_reference_27():
    """Test code snippet from detection-reference.md (line 518)."""
    code = '@dataclass\nclass PostgresDetectionResult:\n    available: bool\n    host: str\n    port: int\n    version: str | None\n    authentication_method: str | None\n    error_message: str | None'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_detection_reference_28():
    """Test code snippet from detection-reference.md (line 544)."""
    code = 'def detect_temporal(\n    host: str = "localhost",\n    frontend_port: int = 7233,\n    ui_port: int = 8233,\n    timeout: float = 2.0\n) -> TemporalDetectionResult'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_detection_reference_29():
    """Test code snippet from detection-reference.md (line 568)."""
    code = 'from mycelium_onboarding.detection.temporal_detector import detect_temporal\n\nresult = detect_temporal()\n\nif result.available:\n    print(f"Temporal {result.version} available")\n    print(f"  Frontend: localhost:{result.frontend_port}")\n    print(f"  UI: http://localhost:{result.ui_port}")\nelse:\n    print(f"Temporal unavailable: {result.error_message}")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_detection_reference_30():
    """Test code snippet from detection-reference.md (line 586)."""
    code = '@dataclass\nclass TemporalDetectionResult:\n    available: bool\n    frontend_port: int\n    ui_port: int\n    version: str | None\n    error_message: str | None'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_detection_reference_31():
    """Test code snippet from detection-reference.md (line 612)."""
    code = 'def detect_gpus() -> GPUDetectionResult'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_detection_reference_32():
    """Test code snippet from detection-reference.md (line 625)."""
    code = 'from mycelium_onboarding.detection.gpu_detector import detect_gpus\n\nresult = detect_gpus()\n\nif result.available:\n    print(f"Found {len(result.gpus)} GPU(s)")\n    print(f"Total memory: {result.total_memory_mb} MB")\n\n    for gpu in result.gpus:\n        print(f"\\n{gpu.vendor.value.upper()}: {gpu.model}")\n        print(f"  Memory: {gpu.memory_mb} MB")\n        print(f"  Driver: {gpu.driver_version}")\n\n        if gpu.cuda_version:\n            print(f"  CUDA: {gpu.cuda_version}")\n        if gpu.rocm_version:\n            print(f"  ROCm: {gpu.rocm_version}")\nelse:\n    print(f"No GPUs detected: {result.error_message}")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_detection_reference_33():
    """Test code snippet from detection-reference.md (line 652)."""
    code = '@dataclass\nclass GPUDetectionResult:\n    available: bool\n    gpus: list[GPU]\n    total_memory_mb: int\n    error_message: str | None'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_detection_reference_34():
    """Test code snippet from detection-reference.md (line 672)."""
    code = '@dataclass\nclass GPU:\n    vendor: GPUVendor\n    model: str\n    memory_mb: int | None\n    driver_version: str | None\n    cuda_version: str | None\n    rocm_version: str | None\n    index: int'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_detection_reference_35():
    """Test code snippet from detection-reference.md (line 698)."""
    code = 'class GPUVendor(str, Enum):\n    NVIDIA = "nvidia"\n    AMD = "amd"\n    INTEL = "intel"\n    UNKNOWN = "unknown"'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_detection_reference_36():
    """Test code snippet from detection-reference.md (line 741)."""
    code = 'from typing import Protocol\n\nclass Detector(Protocol):\n    """Protocol for all detector functions."""\n\n    def __call__(self) -> DetectionResult:\n        """Run detection and return result."""\n        ...\n\n# Type aliases\nDetectionResult = Union[\n    DockerDetectionResult,\n    RedisDetectionResult,\n    PostgresDetectionResult,\n    TemporalDetectionResult,\n    GPUDetectionResult,\n]\n\n# Format types\nOutputFormat = Literal["text", "json", "yaml"]'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_detection_reference_37():
    """Test code snippet from detection-reference.md (line 768)."""
    code = 'result = detect_docker()\nif not result.available:\n    # Handle unavailable service\n    print(f"Error: {result.error_message}")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_detection_reference_38():
    """Test code snippet from detection-reference.md (line 786)."""
    code = 'from mycelium_onboarding.detection import detect_all\n\n# Simple detection\nsummary = detect_all()\nprint(f"Services available: {summary.has_docker}, {summary.has_redis}")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_detection_reference_39():
    """Test code snippet from detection-reference.md (line 796)."""
    code = 'import asyncio\nfrom mycelium_onboarding.detection import detect_all_async\n\nasync def check_services():\n    summary = await detect_all_async()\n    return summary.has_docker and summary.has_redis\n\n# In async context\nresult = await check_services()'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_detection_reference_40():
    """Test code snippet from detection-reference.md (line 810)."""
    code = 'from mycelium_onboarding.detection import detect_all, update_config_from_detection\nfrom mycelium_onboarding.config.manager import ConfigManager\n\n# Detect and update config\nsummary = detect_all()\nconfig = update_config_from_detection(summary)\n\n# Save config\nmanager = ConfigManager()\nmanager.save(config)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_detection_reference_41():
    """Test code snippet from detection-reference.md (line 825)."""
    code = 'from mycelium_onboarding.detection import detect_all, generate_detection_report\nimport json\n\n# Generate JSON report\nsummary = detect_all()\njson_report = generate_detection_report(summary, format="json")\ndata = json.loads(json_report)\n\n# Access specific values\ndocker_version = data["docker"]["version"]\nredis_instances = len(data["redis"]["instances"])'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_detection_reference_42():
    """Test code snippet from detection-reference.md (line 861)."""
    code = 'import time\nfrom functools import lru_cache\n\n@lru_cache(maxsize=1)\ndef cached_detect_all():\n    return detect_all()\n\n# Clear cache every 60 seconds\nlast_detection = time.time()\nif time.time() - last_detection > 60:\n    cached_detect_all.cache_clear()\n    last_detection = time.time()'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_environment_activation_1():
    """Test code snippet from environment-activation.md (line 650)."""
    code = 'from mycelium_onboarding.env_validator import is_environment_active, validate_environment\n\n# Quick boolean check\nif is_environment_active():\n    print("Environment is active")\n\n# Comprehensive validation (raises exception if invalid)\ntry:\n    validate_environment()\n    print("Environment is valid")\nexcept EnvironmentValidationError as e:\n    print(f"Environment error: {e}")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_guides_coordination_best_practices_1():
    """Test code snippet from guides/coordination-best-practices.md (line 28)."""
    code = '# ✅ GOOD: Clear single purpose per step\nworkflow = coordinate_workflow(\n    steps=[\n        {\n            "agent": "data-validator",\n            "task": "Validate CSV data format and completeness",\n            "params": {"file": "data.csv", "schema": "schema.json"}\n        },\n        {\n            "agent": "data-transformer",\n            "task": "Transform validated data to JSON format",\n            "depends_on": ["step-0"],\n            "params": {"input": "data.csv", "output": "data.json"}\n        },\n        {\n            "agent": "data-loader",\n            "task": "Load transformed data into PostgreSQL",\n            "depends_on": ["step-1"],\n            "params": {"file": "data.json", "table": "users"}\n        }\n    ]\n)\n\n# ❌ BAD: Vague, multi-purpose steps\nworkflow = coordinate_workflow(\n    steps=[\n        {\n            "agent": "data-engineer",\n            "task": "Process data",  # Too vague\n            "params": {"file": "data.csv"}\n        },\n        {\n            "agent": "backend-developer",\n            "task": "Do database stuff",  # Unclear purpose\n            "depends_on": ["step-0"]\n        }\n    ]\n)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_guides_coordination_best_practices_2():
    """Test code snippet from guides/coordination-best-practices.md (line 75)."""
    code = '# ✅ GOOD: Explicit dependencies with clear reasons\nworkflow = coordinate_workflow(\n    steps=[\n        {\n            "agent": "backend-developer",\n            "task": "Implement API endpoints",\n            "params": {"spec": "api-spec.yaml"}\n        },\n        {\n            "agent": "database-architect",\n            "task": "Design database schema for API",\n            "params": {"entities": ["User", "Order", "Product"]}\n        },\n        {\n            "agent": "backend-developer",\n            "task": "Connect API endpoints to database",\n            "depends_on": ["step-0", "step-1"],  # Needs both complete\n            "params": {"orm": "SQLAlchemy"}\n        },\n        {\n            "agent": "qa-expert",\n            "task": "Integration testing of API with database",\n            "depends_on": ["step-2"],  # Only needs implementation done\n            "params": {"test_cases": "tests/integration/"}\n        }\n    ]\n)\n\n# ❌ BAD: Implicit or missing dependencies\nworkflow = coordinate_workflow(\n    steps=[\n        {"agent": "backend-developer", "task": "Implement API"},\n        {"agent": "database-architect", "task": "Design schema"},\n        {"agent": "backend-developer", "task": "Connect them"},  # Missing depends_on!\n        {"agent": "qa-expert", "task": "Test everything"}  # Missing depends_on!\n    ]\n)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_guides_coordination_best_practices_3():
    """Test code snippet from guides/coordination-best-practices.md (line 121)."""
    code = '# ✅ GOOD: Balanced granularity\nworkflow = coordinate_workflow(\n    steps=[\n        {\n            "agent": "code-analyzer",\n            "task": "Analyze code complexity and identify refactoring candidates",\n            "params": {"threshold": "complexity > 10"}\n        },\n        {\n            "agent": "refactoring-expert",\n            "task": "Refactor complex functions",\n            "depends_on": ["step-0"],\n            "params": {"focus": "reduce_complexity"}\n        },\n        {\n            "agent": "test-generator",\n            "task": "Generate tests for refactored code",\n            "depends_on": ["step-1"],\n            "params": {"coverage_target": 90}\n        }\n    ]\n)\n\n# ❌ BAD: Too fine-grained (micro-steps)\nworkflow = coordinate_workflow(\n    steps=[\n        {"agent": "analyzer", "task": "Load code"},\n        {"agent": "analyzer", "task": "Parse AST"},\n        {"agent": "analyzer", "task": "Calculate metrics"},\n        {"agent": "analyzer", "task": "Format report"},\n        {"agent": "refactor", "task": "Find function A"},\n        {"agent": "refactor", "task": "Simplify function A"},\n        # ... 20 more micro-steps\n    ]\n)\n\n# ❌ BAD: Too coarse-grained (mega-steps)\nworkflow = coordinate_workflow(\n    steps=[\n        {\n            "agent": "full-stack-developer",\n            "task": "Analyze, refactor, test, and deploy entire codebase",\n            "params": {"everything": True}\n        }\n    ]\n)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_guides_coordination_best_practices_4():
    """Test code snippet from guides/coordination-best-practices.md (line 182)."""
    code = '# ✅ GOOD: Specific, targeted queries\n# For API performance issues\nagents = discover_agents("API performance optimization latency reduction")\n\n# For database design\nagents = discover_agents("PostgreSQL schema design normalization")\n\n# For security audit\nagents = discover_agents("web application security OWASP authentication")\n\n# ❌ BAD: Generic queries\nagents = discover_agents("development")  # Too vague\nagents = discover_agents("help")  # No useful information\nagents = discover_agents("computer stuff")  # Meaningless'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_guides_coordination_best_practices_5():
    """Test code snippet from guides/coordination-best-practices.md (line 205)."""
    code = '# ✅ GOOD: Multi-stage discovery\nasync def find_optimal_team(task_description):\n    # Stage 1: Find primary agent\n    primary = discover_agents(task_description, limit=1)\n\n    # Stage 2: Get primary agent\'s details to understand needs\n    details = get_agent_details(primary["agents"][0]["id"])\n\n    # Stage 3: Find complementary agents based on dependencies\n    team = [primary["agents"][0]]\n    for dependency in details["metadata"]["dependencies"]:\n        agent = discover_agents(f"{dependency} specialist", limit=1)\n        team.append(agent["agents"][0])\n\n    return team\n\n# ❌ BAD: One-shot discovery without refinement\nagents = discover_agents("complex task requiring multiple specialists")\n# Hope for the best with top 5 results'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_guides_coordination_best_practices_6():
    """Test code snippet from guides/coordination-best-practices.md (line 233)."""
    code = '# ✅ GOOD: Confidence-aware selection\nagents = discover_agents("machine learning model deployment", limit=10)\n\n# High-confidence agent for critical task\nif agents["agents"][0]["confidence"] > 0.9:\n    primary_agent = agents["agents"][0]\nelse:\n    # Get human approval if no high-confidence match\n    primary_agent = await get_human_selection(agents["agents"])\n\n# Multiple agents for collaborative task\ncollaborators = [\n    agent for agent in agents["agents"]\n    if agent["confidence"] > 0.7\n]\n\n# ❌ BAD: Ignoring confidence scores\nagents = discover_agents("some task")\nchosen = agents["agents"][0]  # Blindly use first result'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_guides_coordination_best_practices_7():
    """Test code snippet from guides/coordination-best-practices.md (line 265)."""
    code = '# ✅ GOOD: Minimal, relevant context\ncontext = {\n    "files": ["auth.py", "models/user.py"],  # Only relevant files\n    "focus_areas": ["password_hashing", "session_management"],\n    "security_standard": "OWASP_ASVS_4.0",\n    "current_issues": [\n        "Password stored without salt",\n        "Session tokens not rotating"\n    ]\n}\n\nresult = handoff_to_agent(\n    target_agent="security-expert",\n    task="Security audit of authentication system",\n    context=context\n)\n\n# ❌ BAD: Excessive context\ncontext = {\n    "entire_codebase": read_all_files(),  # Unnecessary\n    "git_history": get_full_git_log(),  # Too much\n    "dependency_tree": get_all_dependencies(),  # Irrelevant\n    "random_notes": "check security maybe?",  # Unstructured\n    "last_10_conversations": [...],  # Historical clutter\n}'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_guides_coordination_best_practices_8():
    """Test code snippet from guides/coordination-best-practices.md (line 299)."""
    code = '# ✅ GOOD: Structured context with schema\nSECURITY_AUDIT_CONTEXT = {\n    "files": List[str],           # Files to audit\n    "focus_areas": List[str],     # Security domains\n    "standards": str,             # Compliance standard\n    "known_issues": List[Dict],   # Previous findings\n    "constraints": Dict           # Time, scope, etc.\n}\n\ncontext = {\n    "files": ["auth.py", "api/endpoints.py"],\n    "focus_areas": ["authentication", "authorization", "input_validation"],\n    "standards": "OWASP_ASVS_4.0",\n    "known_issues": [\n        {\n            "type": "SQL_INJECTION",\n            "file": "api/search.py",\n            "line": 42,\n            "severity": "CRITICAL"\n        }\n    ],\n    "constraints": {\n        "time_limit_hours": 2,\n        "scope": "authentication_only"\n    }\n}\n\n# ❌ BAD: Unstructured context\ncontext = {\n    "stuff": "some files and things",\n    "info": ["random", "data", 123, None, True],\n    "notes": "check security things I guess",\n}'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_guides_coordination_best_practices_9():
    """Test code snippet from guides/coordination-best-practices.md (line 341)."""
    code = '# ✅ GOOD: Compressed context with references\ncontext = {\n    "database_schema": "file://database/schema.sql",  # Reference\n    "slow_queries_log": "file://logs/slow_queries.txt",  # Reference\n    "summary": {\n        "tables_affected": ["users", "orders", "products"],\n        "slowest_query_time_ms": 5000,\n        "p95_latency_ms": 1200,\n        "daily_query_volume": 1000000\n    },\n    "sample_queries": [\n        "SELECT * FROM users WHERE created_at > ?",  # Example\n        "SELECT COUNT(*) FROM orders GROUP BY user_id"  # Example\n    ]\n}\n\n# ❌ BAD: Embedded large data\ncontext = {\n    "schema": read_file("schema.sql"),  # 500KB embedded\n    "all_queries": read_file("logs/queries.txt"),  # 50MB embedded\n    "every_table": [...]  # Huge array\n}'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_guides_coordination_best_practices_10():
    """Test code snippet from guides/coordination-best-practices.md (line 376)."""
    code = '# ✅ GOOD: Critical deployment - abort on failure\ndeployment_workflow = coordinate_workflow(\n    steps=[\n        {"agent": "build-engineer", "task": "Build application"},\n        {"agent": "qa-expert", "task": "Run integration tests"},\n        {"agent": "devops-engineer", "task": "Deploy to production"}\n    ],\n    failure_strategy="abort"  # Critical - stop if any step fails\n)\n\n# ✅ GOOD: Best-effort analysis - continue on failure\nanalysis_workflow = coordinate_workflow(\n    steps=[\n        {"agent": "code-analyzer", "task": "Analyze code quality"},\n        {"agent": "security-scanner", "task": "Security scan"},\n        {"agent": "dependency-checker", "task": "Check outdated dependencies"}\n    ],\n    failure_strategy="continue"  # Non-critical - collect all results\n)\n\n# ✅ GOOD: Fallback for production service\nservice_workflow = coordinate_workflow(\n    steps=[\n        {\n            "agent": "ml-engineer",\n            "task": "Deploy new ML model",\n            "fallback": {\n                "agent": "ml-engineer",\n                "task": "Rollback to previous model version"\n            }\n        }\n    ],\n    failure_strategy="fallback"\n)\n\n# ❌ BAD: Wrong strategy for critical workflow\ndeployment_workflow = coordinate_workflow(\n    steps=[...],\n    failure_strategy="continue"  # Dangerous! Could deploy broken code\n)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_guides_coordination_best_practices_11():
    """Test code snippet from guides/coordination-best-practices.md (line 430)."""
    code = '# ✅ GOOD: Idempotent steps\nworkflow = coordinate_workflow(\n    steps=[\n        {\n            "agent": "database-admin",\n            "task": "Create users table if not exists",\n            "params": {"ddl": "CREATE TABLE IF NOT EXISTS users (...)"}\n        },\n        {\n            "agent": "data-loader",\n            "task": "Load data with upsert (insert or update)",\n            "params": {"mode": "upsert", "key": "user_id"}\n        }\n    ]\n)\n\n# ❌ BAD: Non-idempotent steps\nworkflow = coordinate_workflow(\n    steps=[\n        {\n            "agent": "database-admin",\n            "task": "Create users table",  # Fails if table exists\n            "params": {"ddl": "CREATE TABLE users (...)"}\n        },\n        {\n            "agent": "data-loader",\n            "task": "Insert all data",  # Fails if data exists\n            "params": {"mode": "insert"}\n        }\n    ]\n)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_guides_coordination_best_practices_12():
    """Test code snippet from guides/coordination-best-practices.md (line 470)."""
    code = '# ✅ GOOD: Rich error context\ntry:\n    workflow = coordinate_workflow(steps=[...])\nexcept WorkflowExecutionError as e:\n    # Get detailed failure information\n    events = get_coordination_events(\n        workflow_id=e.workflow_id,\n        event_type="failure"\n    )\n\n    for event in events["events"]:\n        print(f"Failed Step: {event[\'metadata\'][\'step\']}")\n        print(f"Agent: {event[\'metadata\'][\'agent\']}")\n        print(f"Error: {event[\'metadata\'][\'error\']}")\n        print(f"Context: {event[\'metadata\'][\'context\']}")\n        print(f"Timestamp: {event[\'timestamp\']}")\n\n        # Log to monitoring system\n        logger.error(\n            "Workflow step failed",\n            extra={\n                "workflow_id": e.workflow_id,\n                "step": event[\'metadata\'][\'step\'],\n                "agent": event[\'metadata\'][\'agent\'],\n                "error": event[\'metadata\'][\'error\']\n            }\n        )\n\n# ❌ BAD: Minimal error handling\ntry:\n    workflow = coordinate_workflow(steps=[...])\nexcept Exception as e:\n    print(f"Failed: {e}")  # No context, hard to debug'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_guides_coordination_best_practices_13():
    """Test code snippet from guides/coordination-best-practices.md (line 516)."""
    code = '# ✅ GOOD: Parallel independent tasks\nworkflow = coordinate_workflow(\n    steps=[\n        # These can run in parallel\n        {\n            "agent": "frontend-developer",\n            "task": "Build React components"\n        },\n        {\n            "agent": "backend-developer",\n            "task": "Implement API endpoints"\n        },\n        {\n            "agent": "database-architect",\n            "task": "Design database schema"\n        },\n        # This waits for all three\n        {\n            "agent": "integration-engineer",\n            "task": "Connect frontend, backend, and database",\n            "depends_on": ["step-0", "step-1", "step-2"]\n        }\n    ],\n    execution_mode="parallel"\n)\n\n# ❌ BAD: Unnecessary sequential execution\nworkflow = coordinate_workflow(\n    steps=[\n        {"agent": "frontend-developer", "task": "Build components"},\n        {\n            "agent": "backend-developer",\n            "task": "Implement API",\n            "depends_on": ["step-0"]  # Not actually dependent!\n        },\n        {\n            "agent": "database-architect",\n            "task": "Design schema",\n            "depends_on": ["step-1"]  # Not actually dependent!\n        }\n    ],\n    execution_mode="sequential"\n)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_guides_coordination_best_practices_14():
    """Test code snippet from guides/coordination-best-practices.md (line 568)."""
    code = '# ✅ GOOD: Reuse discovered agents\nasync def code_review_pipeline(files):\n    # Discover agents once\n    reviewer = discover_agents("code review", limit=1)["agents"][0]\n    security = discover_agents("security audit", limit=1)["agents"][0]\n\n    # Reuse for multiple files\n    results = []\n    for file in files:\n        workflow = coordinate_workflow(\n            steps=[\n                {"agent": reviewer["id"], "task": f"Review {file}"},\n                {\n                    "agent": security["id"],\n                    "task": f"Security scan {file}",\n                    "depends_on": ["step-0"]\n                }\n            ]\n        )\n        results.append(workflow)\n\n    return results\n\n# ❌ BAD: Rediscover agents for each file\nasync def code_review_pipeline(files):\n    results = []\n    for file in files:\n        # Wasteful rediscovery\n        reviewer = discover_agents("code review")["agents"][0]\n        security = discover_agents("security audit")["agents"][0]\n\n        workflow = coordinate_workflow(\n            steps=[\n                {"agent": reviewer["id"], "task": f"Review {file}"},\n                {"agent": security["id"], "task": f"Security scan {file}"}\n            ]\n        )\n        results.append(workflow)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_guides_coordination_best_practices_15():
    """Test code snippet from guides/coordination-best-practices.md (line 615)."""
    code = '# ✅ GOOD: Batch similar tasks\nworkflow = coordinate_workflow(\n    steps=[\n        {\n            "agent": "test-generator",\n            "task": "Generate tests for multiple modules",\n            "params": {\n                "modules": ["auth.py", "api.py", "models.py"],  # Batch\n                "coverage_target": 90\n            }\n        }\n    ]\n)\n\n# ❌ BAD: Individual workflows for each task\nfor module in ["auth.py", "api.py", "models.py"]:\n    workflow = coordinate_workflow(\n        steps=[\n            {\n                "agent": "test-generator",\n                "task": f"Generate tests for {module}",\n                "params": {"module": module}\n            }\n        ]\n    )'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_guides_coordination_best_practices_16():
    """Test code snippet from guides/coordination-best-practices.md (line 653)."""
    code = '# ✅ GOOD: Minimal access\ncontext = {\n    "files": ["specific/file.py"],  # Only files needed\n    "permissions": ["read"],  # Read-only\n    "scope": "security_audit_only"  # Limited scope\n}\n\nresult = handoff_to_agent(\n    target_agent="security-expert",\n    task="Audit authentication in file.py",\n    context=context\n)\n\n# ❌ BAD: Excessive access\ncontext = {\n    "files": get_all_files(),  # Everything\n    "permissions": ["read", "write", "execute"],  # Too much\n    "scope": "unlimited"  # No boundaries\n}'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_guides_coordination_best_practices_17():
    """Test code snippet from guides/coordination-best-practices.md (line 681)."""
    code = '# ✅ GOOD: Reference sensitive data indirectly\ncontext = {\n    "database_config_path": "config/database.yml",  # Reference\n    "credentials_source": "vault://prod/db-credentials",  # Secure vault\n    "redacted_query_log": "logs/queries_redacted.txt"  # Pre-redacted\n}\n\n# ❌ BAD: Sensitive data in context\ncontext = {\n    "database_password": "super_secret_123",  # Exposed!\n    "api_keys": ["key1", "key2", "key3"],  # Exposed!\n    "user_data": [\n        {"email": "user@example.com", "ssn": "123-45-6789"}  # PII!\n    ]\n}'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_guides_coordination_best_practices_18():
    """Test code snippet from guides/coordination-best-practices.md (line 705)."""
    code = '# ✅ GOOD: Comprehensive audit logging\nasync def audited_workflow(workflow_spec):\n    # Log workflow initiation\n    audit_log.record({\n        "event": "workflow_started",\n        "workflow_spec": workflow_spec,\n        "user": get_current_user(),\n        "timestamp": datetime.now(UTC)\n    })\n\n    try:\n        workflow = coordinate_workflow(**workflow_spec)\n\n        # Log completion\n        audit_log.record({\n            "event": "workflow_completed",\n            "workflow_id": workflow["workflow_id"],\n            "duration_ms": workflow["total_duration_ms"],\n            "timestamp": datetime.now(UTC)\n        })\n\n        return workflow\n\n    except Exception as e:\n        # Log failure\n        audit_log.record({\n            "event": "workflow_failed",\n            "error": str(e),\n            "timestamp": datetime.now(UTC)\n        })\n        raise\n\n# Get audit trail\nevents = get_coordination_events(workflow_id="wf-123")\nfor event in events["events"]:\n    audit_log.record(event)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_guides_coordination_best_practices_19():
    """Test code snippet from guides/coordination-best-practices.md (line 754)."""
    code = '# ✅ GOOD: Incremental testing\ndef test_code_review_workflow():\n    # Test step 1 alone\n    step1 = coordinate_workflow(\n        steps=[\n            {"agent": "python-pro", "task": "Review code style"}\n        ]\n    )\n    assert step1["status"] == "completed"\n\n    # Test steps 1-2\n    step1_2 = coordinate_workflow(\n        steps=[\n            {"agent": "python-pro", "task": "Review code style"},\n            {\n                "agent": "security-expert",\n                "task": "Security audit",\n                "depends_on": ["step-0"]\n            }\n        ]\n    )\n    assert step1_2["status"] == "completed"\n    assert len(step1_2["results"]) == 2\n\n    # Test full workflow\n    full_workflow = coordinate_workflow(\n        steps=[...all_steps]\n    )\n    assert full_workflow["status"] == "completed"\n\n# ❌ BAD: Test everything at once\ndef test_code_review_workflow():\n    workflow = coordinate_workflow(\n        steps=[...20_complex_steps]\n    )\n    assert workflow["status"] == "completed"  # Hard to debug if fails'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_guides_coordination_best_practices_20():
    """Test code snippet from guides/coordination-best-practices.md (line 799)."""
    code = '# ✅ GOOD: Mock agents for testing\nfrom unittest.mock import Mock, patch\n\ndef test_workflow_coordination_logic():\n    # Mock agent discovery\n    mock_discover = Mock(return_value={\n        "agents": [\n            {"id": "mock-agent-1", "confidence": 0.95},\n            {"id": "mock-agent-2", "confidence": 0.90}\n        ]\n    })\n\n    # Mock workflow execution\n    mock_coordinate = Mock(return_value={\n        "workflow_id": "test-wf-123",\n        "status": "completed",\n        "results": [...]\n    })\n\n    with patch(\'discover_agents\', mock_discover):\n        with patch(\'coordinate_workflow\', mock_coordinate):\n            # Test your logic\n            result = my_workflow_function()\n            assert result["status"] == "completed"\n            mock_discover.assert_called_once()\n            mock_coordinate.assert_called_once()'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_guides_coordination_best_practices_21():
    """Test code snippet from guides/coordination-best-practices.md (line 834)."""
    code = '# ✅ GOOD: Validation before execution\ndef validate_workflow_spec(steps):\n    """Validate workflow structure."""\n    if not steps:\n        raise ValueError("Workflow must have at least one step")\n\n    step_ids = [f"step-{i}" for i in range(len(steps))]\n\n    for step in steps:\n        # Required fields\n        if "agent" not in step:\n            raise ValueError("Each step must have \'agent\'")\n        if "task" not in step:\n            raise ValueError("Each step must have \'task\'")\n\n        # Validate dependencies\n        for dep in step.get("depends_on", []):\n            if dep not in step_ids:\n                raise ValueError(f"Invalid dependency: {dep}")\n\n    # Check for circular dependencies\n    if has_circular_dependencies(steps):\n        raise ValueError("Circular dependencies detected")\n\n    return True\n\n# Use validation\nworkflow_spec = {...}\nvalidate_workflow_spec(workflow_spec["steps"])\nworkflow = coordinate_workflow(**workflow_spec)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_guides_coordination_best_practices_22():
    """Test code snippet from guides/coordination-best-practices.md (line 877)."""
    code = '# ❌ ANTI-PATTERN: Excessive handoffs\nasync def process_files(files):\n    for file in files:\n        # Handoff for each file - wasteful!\n        await handoff_to_agent(\n            "file-processor",\n            f"Process {file}"\n        )\n\n# ✅ SOLUTION: Batch processing\nasync def process_files(files):\n    await handoff_to_agent(\n        "file-processor",\n        "Process files in batch",\n        context={"files": files}  # Single handoff\n    )'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_guides_coordination_best_practices_23():
    """Test code snippet from guides/coordination-best-practices.md (line 902)."""
    code = '# ❌ ANTI-PATTERN: Monolithic workflow\nworkflow = coordinate_workflow(\n    steps=[\n        # 50 steps covering entire application lifecycle\n        {"agent": "...", "task": "..."},\n        # ...\n        {"agent": "...", "task": "..."}\n    ]\n)\n\n# ✅ SOLUTION: Compose smaller workflows\nfrontend_workflow = coordinate_workflow(steps=[...5_frontend_steps])\nbackend_workflow = coordinate_workflow(steps=[...5_backend_steps])\ndeployment_workflow = coordinate_workflow(steps=[...3_deployment_steps])\n\n# Compose results\nfull_result = {\n    "frontend": frontend_workflow,\n    "backend": backend_workflow,\n    "deployment": deployment_workflow\n}'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_guides_coordination_best_practices_24():
    """Test code snippet from guides/coordination-best-practices.md (line 932)."""
    code = '# ❌ ANTI-PATTERN: Implicit state via files\nworkflow = coordinate_workflow(\n    steps=[\n        {\n            "agent": "data-processor",\n            "task": "Process data and write to /tmp/result.json"  # Side effect\n        },\n        {\n            "agent": "analyzer",\n            "task": "Analyze data in /tmp/result.json",  # Implicit dependency\n            "depends_on": ["step-0"]\n        }\n    ]\n)\n\n# ✅ SOLUTION: Explicit state passing\nworkflow = coordinate_workflow(\n    steps=[\n        {\n            "agent": "data-processor",\n            "task": "Process data",\n            "params": {"output_file": "result.json"}\n        },\n        {\n            "agent": "analyzer",\n            "task": "Analyze processed data",\n            "depends_on": ["step-0"],\n            "params": {\n                "input": "{{step-0.output_file}}"  # Explicit reference\n            }\n        }\n    ]\n)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_guides_coordination_best_practices_25():
    """Test code snippet from guides/coordination-best-practices.md (line 974)."""
    code = '# ❌ ANTI-PATTERN: No error handling\nworkflow = coordinate_workflow(\n    steps=[\n        {"agent": "...", "task": "..."},\n        {"agent": "...", "task": "..."}\n    ]\n)\n# Hope nothing fails!\n\n# ✅ SOLUTION: Comprehensive failure handling\nworkflow = coordinate_workflow(\n    steps=[\n        {"agent": "...", "task": "..."},\n        {\n            "agent": "...",\n            "task": "...",\n            "depends_on": ["step-0"],\n            "fallback": {\n                "agent": "...",\n                "task": "Fallback action"\n            }\n        }\n    ],\n    failure_strategy="fallback"\n)\n\n# Monitor and handle failures\ntry:\n    result = workflow\nexcept WorkflowExecutionError as e:\n    handle_failure(e)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_guides_discovery_coordination_quickstart_1():
    """Test code snippet from guides/discovery-coordination-quickstart.md (line 59)."""
    code = 'from mcp.tools.discovery_tools import discover_agents\n\n# Natural language query\nresult = discover_agents(\n    query="optimize slow API performance and reduce latency",\n    limit=5\n)\n\n# View results\nfor agent in result["agents"]:\n    print(f"{agent[\'name\']} (confidence: {agent[\'confidence\']})")\n    print(f"  → {agent[\'reason\']}")\n    print()\n\n# Example output:\n# Performance Engineer (confidence: 0.94)\n#   → Matches keywords: API, performance, latency\n#\n# API Designer (confidence: 0.89)\n#   → Matches keywords: API, optimization\n#\n# Backend Developer (confidence: 0.82)\n#   → Matches keywords: API'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_guides_discovery_coordination_quickstart_2():
    """Test code snippet from guides/discovery-coordination-quickstart.md (line 87)."""
    code = 'from mcp.tools.discovery_tools import get_agent_details\n\n# Get full details on top match\nagent_id = result["agents"][0]["id"]\ndetails = get_agent_details(agent_id)\n\nprint(f"Agent: {details[\'agent\'][\'name\']}")\nprint(f"Capabilities: {\', \'.join(details[\'agent\'][\'capabilities\'])}")\nprint(f"Tools: {\', \'.join(details[\'agent\'][\'tools\'])}")\nprint(f"Success Rate: {details[\'agent\'][\'success_rate\']*100}%")\n\n# Example output:\n# Agent: Performance Engineer\n# Capabilities: Performance profiling, Load testing, Query optimization\n# Tools: pytest-benchmark, locust, py-spy\n# Success Rate: 95%'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_guides_discovery_coordination_quickstart_3():
    """Test code snippet from guides/discovery-coordination-quickstart.md (line 114)."""
    code = 'from mcp.tools.coordination_tools import handoff_to_agent\n\n# Hand off to database specialist\nresult = handoff_to_agent(\n    target_agent="postgres-pro",\n    task="Optimize slow queries in user_analytics table",\n    context={\n        "schema": "database/schema.sql",\n        "slow_queries": [\n            "SELECT * FROM user_analytics WHERE created_at > NOW() - INTERVAL \'7 days\'",\n            "SELECT user_id, COUNT(*) FROM events GROUP BY user_id"\n        ],\n        "performance_targets": {\n            "p95_latency_ms": 100,\n            "queries_per_second": 1000\n        }\n    }\n)\n\nprint(f"Handoff Status: {result[\'status\']}")\nprint(f"Result: {result[\'result\'][\'message\']}")\nprint(f"Duration: {result[\'duration_ms\']}ms")\n\n# Example output:\n# Handoff Status: completed\n# Result: Optimized 2 slow queries - added indexes, rewrote GROUP BY\n# Duration: 2300ms'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_guides_discovery_coordination_quickstart_4():
    """Test code snippet from guides/discovery-coordination-quickstart.md (line 152)."""
    code = 'from mcp.tools.coordination_tools import coordinate_workflow\n\n# Create a code review workflow\nworkflow = coordinate_workflow(\n    steps=[\n        {\n            "agent": "python-pro",\n            "task": "Review Python code style and best practices",\n            "params": {"file": "api/endpoints.py"}\n        },\n        {\n            "agent": "security-expert",\n            "task": "Security audit focusing on injection and auth",\n            "depends_on": ["step-0"],\n            "params": {"file": "api/endpoints.py"}\n        },\n        {\n            "agent": "performance-optimizer",\n            "task": "Performance analysis and optimization recommendations",\n            "depends_on": ["step-0"],\n            "params": {"file": "api/endpoints.py"}\n        }\n    ],\n    execution_mode="sequential",\n    failure_strategy="retry"\n)\n\nprint(f"Workflow ID: {workflow[\'workflow_id\']}")\nprint(f"Status: {workflow[\'status\']}")\nprint(f"Completed {workflow[\'steps_completed\']}/{workflow[\'steps_total\']} steps")\nprint(f"Total Duration: {workflow[\'total_duration_ms\']}ms")\nprint()\n\n# View results\nfor result in workflow["results"]:\n    print(f"{result[\'agent\']}:")\n    print(f"  {result[\'output\']}")\n    print(f"  (took {result[\'duration_ms\']}ms)")\n    print()\n\n# Example output:\n# Workflow ID: wf-abc-123\n# Status: completed\n# Completed 3/3 steps\n# Total Duration: 4500ms\n#\n# python-pro:\n#   Found 3 style issues: inconsistent naming, missing docstrings\n#   (took 1200ms)\n#\n# security-expert:\n#   Found 1 critical issue: SQL injection vulnerability in search endpoint\n#   (took 1800ms)\n#\n# performance-optimizer:\n#   Found 2 optimization opportunities: add caching, use bulk operations\n#   (took 1500ms)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_guides_discovery_coordination_quickstart_5():
    """Test code snippet from guides/discovery-coordination-quickstart.md (line 214)."""
    code = 'from mcp.tools.coordination_tools import get_workflow_status\nimport time\n\n# Monitor long-running workflow\nworkflow_id = "wf-abc-123"\n\nwhile True:\n    status = get_workflow_status(workflow_id, include_steps=False)\n\n    if status["status"] == "completed":\n        print(f"\\n✓ Workflow completed in {status[\'total_duration_ms\']}ms")\n        break\n    elif status["status"] == "failed":\n        print(f"\\n✗ Workflow failed at step {status[\'current_step\']}")\n        break\n    else:\n        print(f"Progress: {status[\'progress_percent\']}% (step {status[\'current_step\']}/{status[\'steps_total\']})")\n        time.sleep(2)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_guides_discovery_coordination_quickstart_6():
    """Test code snippet from guides/discovery-coordination-quickstart.md (line 243)."""
    code = 'from mcp.tools.discovery_tools import discover_agents\nfrom mcp.tools.coordination_tools import coordinate_workflow\n\n# 1. Discover agents for each phase\ndesign_agents = discover_agents("API design REST best practices", limit=1)\nbackend_agents = discover_agents("Python FastAPI development", limit=1)\ndb_agents = discover_agents("PostgreSQL database schema design", limit=1)\ntest_agents = discover_agents("API testing integration tests", limit=1)\n\n# 2. Build workflow\nworkflow = coordinate_workflow(\n    steps=[\n        {\n            "agent": design_agents["agents"][0]["id"],\n            "task": "Design REST API for user management (CRUD operations)",\n            "params": {\n                "requirements": ["create user", "update user", "delete user", "list users"],\n                "standards": "REST best practices, OpenAPI 3.0"\n            }\n        },\n        {\n            "agent": db_agents["agents"][0]["id"],\n            "task": "Design database schema for user management",\n            "depends_on": ["step-0"],\n            "params": {\n                "tables": ["users", "user_profiles"],\n                "requirements": ["email uniqueness", "soft deletes"]\n            }\n        },\n        {\n            "agent": backend_agents["agents"][0]["id"],\n            "task": "Implement API endpoints based on design",\n            "depends_on": ["step-0", "step-1"],\n            "params": {\n                "framework": "FastAPI",\n                "database": "PostgreSQL",\n                "include": ["validation", "error handling"]\n            }\n        },\n        {\n            "agent": test_agents["agents"][0]["id"],\n            "task": "Create integration tests for API endpoints",\n            "depends_on": ["step-2"],\n            "params": {\n                "test_framework": "pytest",\n                "coverage_target": 90\n            }\n        }\n    ],\n    execution_mode="sequential",\n    failure_strategy="retry"\n)\n\n# 3. Review deliverables\nprint("API Development Workflow Complete!")\nprint(f"Duration: {workflow[\'total_duration_ms\']/1000:.1f}s")\nprint(f"Agents involved: {len(workflow[\'results\'])}")\nprint()\n\nfor step in workflow["results"]:\n    print(f"✓ {step[\'agent\']}: {step[\'output\']}")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_guides_discovery_coordination_quickstart_7():
    """Test code snippet from guides/discovery-coordination-quickstart.md (line 313)."""
    code = '# Generic search\nagents = discover_agents("your task description")\n\n# Category-specific search\nagents = discover_agents(\n    "database optimization",\n    category_filter="infrastructure"\n)\n\n# High-confidence matches only\nagents = discover_agents(\n    "security audit",\n    threshold=0.8,\n    limit=3\n)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_guides_discovery_coordination_quickstart_8():
    """Test code snippet from guides/discovery-coordination-quickstart.md (line 333)."""
    code = '# Sequential workflow (one after another)\nworkflow = coordinate_workflow(\n    steps=[step1, step2, step3],\n    execution_mode="sequential"\n)\n\n# Parallel workflow (independent tasks)\nworkflow = coordinate_workflow(\n    steps=[task_a, task_b, task_c, merge_step],\n    execution_mode="parallel"\n)\n\n# Explicit handoff\nresult = handoff_to_agent(\n    target_agent="specialist-id",\n    task="specific task",\n    context={"relevant": "data"}\n)\n\n# Check status\nstatus = get_workflow_status(workflow_id)\n\n# Review history\nevents = get_coordination_events(workflow_id=workflow_id)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_guides_discovery_coordination_quickstart_9():
    """Test code snippet from guides/discovery-coordination-quickstart.md (line 366)."""
    code = '# Problem: Empty results\nresult = discover_agents("very specific niche task")\n# result["agents"] == []\n\n# Solution 1: Broaden query\nresult = discover_agents("general category task")\n\n# Solution 2: Lower threshold\nresult = discover_agents("specific task", threshold=0.4)\n\n# Solution 3: Check all categories\nresult = discover_agents("task", limit=20)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_guides_discovery_coordination_quickstart_10():
    """Test code snippet from guides/discovery-coordination-quickstart.md (line 383)."""
    code = '# Problem: Workflow not progressing\nstatus = get_workflow_status("wf-123")\n# status["status"] == "in_progress" for too long\n\n# Solution 1: Check events\nevents = get_coordination_events(\n    workflow_id="wf-123",\n    event_type="failure"\n)\nfor event in events["events"]:\n    print(f"Error: {event[\'metadata\']}")\n\n# Solution 2: Verify agent availability\nfrom agent_discovery import check_discovery_health\nhealth = check_discovery_health()\n\n# Solution 3: Retry with different agent\n# Manually abort and restart with fallback agent'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_guides_discovery_coordination_quickstart_11():
    """Test code snippet from guides/discovery-coordination-quickstart.md (line 406)."""
    code = '# Problem: Target agent missing context\nresult = handoff_to_agent("agent", "task", context=large_object)\n# result["context_preserved"] == False\n\n# Solution: Use file references instead\nresult = handoff_to_agent(\n    "agent",\n    "task",\n    context={\n        "files": ["path/to/data.json"],  # Reference, not embed\n        "summary": "key points only"  # Small, structured\n    }\n)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_guides_discovery_coordination_quickstart_12():
    """Test code snippet from guides/discovery-coordination-quickstart.md (line 455)."""
    code = '# Find agents\ndiscover_agents(query, limit=5, threshold=0.6)\n\n# Get details\nget_agent_details(agent_id)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_guides_discovery_coordination_quickstart_13():
    """Test code snippet from guides/discovery-coordination-quickstart.md (line 465)."""
    code = '# Run workflow\ncoordinate_workflow(steps, execution_mode="sequential")\n\n# Handoff\nhandoff_to_agent(target_agent, task, context={})\n\n# Monitor\nget_workflow_status(workflow_id)\n\n# Debug\nget_coordination_events(workflow_id)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_guides_discovery_coordination_quickstart_14():
    """Test code snippet from guides/discovery-coordination-quickstart.md (line 481)."""
    code = 'from mcp.tools.discovery_tools import (\n    discover_agents,\n    get_agent_details\n)\n\nfrom mcp.tools.coordination_tools import (\n    coordinate_workflow,\n    handoff_to_agent,\n    get_workflow_status,\n    get_coordination_events\n)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_migration_guide_1():
    """Test code snippet from migration-guide.md (line 57)."""
    code = 'from mycelium_onboarding.config.manager import ConfigManager\n\nmanager = ConfigManager()\nconfig = manager.load_and_migrate()  # Auto-migrates to latest'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_migration_guide_2():
    """Test code snippet from migration-guide.md (line 346)."""
    code = 'from mycelium_onboarding.config.migrations import Migration\nfrom typing import Any\n\nclass Migration_1_2_to_1_3(Migration):\n    """Migrate from version 1.2 to 1.3.\n\n    Changes:\n    - Add security configuration section\n    - Add SSL/TLS settings\n    """\n\n    @property\n    def from_version(self) -> str:\n        return "1.2"\n\n    @property\n    def to_version(self) -> str:\n        return "1.3"\n\n    @property\n    def description(self) -> str:\n        return "Add security and SSL/TLS configuration"\n\n    def migrate(self, config_dict: dict[str, Any]) -> dict[str, Any]:\n        """Perform migration."""\n        # Add security section\n        config_dict["security"] = {\n            "ssl_enabled": False,\n            "tls_version": "1.3",\n            "cert_path": None,\n            "key_path": None,\n        }\n\n        # Update version\n        config_dict["version"] = self.to_version\n\n        return config_dict'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_migration_guide_3():
    """Test code snippet from migration-guide.md (line 392)."""
    code = 'def migrate(self, config_dict: dict[str, Any]) -> dict[str, Any]:\n    # BAD: Overwrites user customization\n    config_dict["redis"]["port"] = 6379\n\n    # GOOD: Preserves existing value\n    if "redis" not in config_dict:\n        config_dict["redis"] = {}\n    if "port" not in config_dict["redis"]:\n        config_dict["redis"]["port"] = 6379\n\n    return config_dict'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_migration_guide_4():
    """Test code snippet from migration-guide.md (line 410)."""
    code = 'def migrate(self, config_dict: dict[str, Any]) -> dict[str, Any]:\n    # Check if section exists\n    if "deployment" in config_dict:\n        # Safe to access\n        if "auto_start" not in config_dict["deployment"]:\n            config_dict["deployment"]["auto_start"] = True\n    else:\n        # Create section with defaults\n        config_dict["deployment"] = {\n            "method": "docker-compose",\n            "auto_start": True,\n        }\n\n    return config_dict'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_migration_guide_5():
    """Test code snippet from migration-guide.md (line 431)."""
    code = 'def migrate(self, config_dict: dict[str, Any]) -> dict[str, Any]:\n    # Rename field while preserving value\n    if "deployment" in config_dict:\n        if "log_level" in config_dict["deployment"]:\n            # Get old value\n            old_value = config_dict["deployment"].pop("log_level")\n            # Set new field with old value\n            config_dict["deployment"]["logging_level"] = old_value\n\n    return config_dict'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_migration_guide_6():
    """Test code snippet from migration-guide.md (line 448)."""
    code = 'def migrate(self, config_dict: dict[str, Any]) -> dict[str, Any]:\n    # Add new feature disabled by default (safe)\n    config_dict["monitoring"] = {\n        "enabled": False,  # Disabled by default\n        "metrics_port": 9090,\n        "interval": 30,\n    }\n\n    # User can enable explicitly\n    return config_dict'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_migration_guide_7():
    """Test code snippet from migration-guide.md (line 465)."""
    code = 'import logging\n\nlogger = logging.getLogger(__name__)\n\ndef migrate(self, config_dict: dict[str, Any]) -> dict[str, Any]:\n    logger.info("Adding monitoring configuration")\n\n    config_dict["monitoring"] = {\n        "enabled": False,\n        "metrics_port": 9090,\n    }\n\n    logger.debug("Monitoring config: %s", config_dict["monitoring"])\n\n    return config_dict'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_migration_guide_8():
    """Test code snippet from migration-guide.md (line 487)."""
    code = '# In mycelium_onboarding/config/migrations.py\n\ndef get_default_registry() -> MigrationRegistry:\n    """Get default migration registry with all migrations."""\n    registry = MigrationRegistry()\n\n    # Existing migrations\n    registry.register(Migration_1_0_to_1_1())\n    registry.register(Migration_1_1_to_1_2())\n\n    # Your custom migration\n    registry.register(Migration_1_2_to_1_3())\n\n    return registry'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_migration_guide_9():
    """Test code snippet from migration-guide.md (line 508)."""
    code = 'import pytest\nfrom mycelium_onboarding.config.migrations import Migration_1_2_to_1_3\n\ndef test_migration_1_2_to_1_3():\n    """Test migration from 1.2 to 1.3."""\n    # Setup: 1.2 config\n    config_1_2 = {\n        "version": "1.2",\n        "project_name": "test",\n        "deployment": {"method": "docker-compose"},\n    }\n\n    # Execute migration\n    migration = Migration_1_2_to_1_3()\n    migrated = migration.migrate(config_1_2.copy())\n\n    # Verify: security section added\n    assert "security" in migrated\n    assert migrated["security"]["ssl_enabled"] is False\n\n    # Verify: version updated\n    assert migrated["version"] == "1.3"\n\n    # Verify: existing fields preserved\n    assert migrated["project_name"] == "test"\n    assert migrated["deployment"]["method"] == "docker-compose"'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_operations_coordination_tracking_1():
    """Test code snippet from operations/coordination-tracking.md (line 127)."""
    code = 'from coordination.tracker import CoordinationTracker\nimport asyncpg\n\n# Create database connection pool\npool = await asyncpg.create_pool(\n    "postgresql://localhost:5432/mycelium_registry",\n    min_size=2,\n    max_size=10,\n)\n\n# Initialize tracker\ntracker = CoordinationTracker(pool=pool)\nawait tracker.initialize()'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_operations_coordination_tracking_2():
    """Test code snippet from operations/coordination-tracking.md (line 147)."""
    code = 'from coordination.tracker import (\n    CoordinationEvent,\n    EventType,\n    AgentInfo,\n    ErrorInfo,\n    PerformanceMetrics,\n)\n\n# Create handoff event\nevent = CoordinationEvent(\n    event_type=EventType.HANDOFF,\n    workflow_id="workflow-123",\n    task_id="task-456",\n    source_agent=AgentInfo("agent-001", "backend-developer"),\n    target_agent=AgentInfo("agent-002", "frontend-developer"),\n    context={"task_description": "Build REST API"},\n    metadata={"priority": "high"},\n)\n\nevent_id = await tracker.track_event(event)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_operations_coordination_tracking_3():
    """Test code snippet from operations/coordination-tracking.md (line 172)."""
    code = 'from coordination.tracker import (\n    track_handoff,\n    track_task_execution,\n    track_failure,\n)\n\n# Track handoff\nawait track_handoff(\n    tracker,\n    workflow_id="workflow-123",\n    source_agent_id="agent-001",\n    source_agent_type="backend-developer",\n    target_agent_id="agent-002",\n    target_agent_type="frontend-developer",\n    task_id="task-456",\n)\n\n# Track task execution\nawait track_task_execution(\n    tracker,\n    workflow_id="workflow-123",\n    task_id="task-456",\n    agent_id="agent-001",\n    agent_type="backend-developer",\n    status="completed",\n    duration_ms=1523.5,\n    result_summary="API endpoints created",\n)\n\n# Track failure\nawait track_failure(\n    tracker,\n    workflow_id="workflow-123",\n    task_id="task-456",\n    agent_id="agent-001",\n    agent_type="backend-developer",\n    error_type="TimeoutError",\n    error_message="Task execution timeout",\n    attempt=2,\n)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_operations_coordination_tracking_4():
    """Test code snippet from operations/coordination-tracking.md (line 219)."""
    code = '# Get all events for workflow\nevents = await tracker.get_workflow_events("workflow-123")\n\n# Filter by event type\nhandoffs = await tracker.get_workflow_events(\n    "workflow-123",\n    event_type=EventType.HANDOFF,\n)\n\n# Limit results\nrecent_events = await tracker.get_workflow_events(\n    "workflow-123",\n    limit=50,\n)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_operations_coordination_tracking_5():
    """Test code snippet from operations/coordination-tracking.md (line 238)."""
    code = '# Get all events for specific task\ntask_events = await tracker.get_task_events("task-456")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_operations_coordination_tracking_6():
    """Test code snippet from operations/coordination-tracking.md (line 245)."""
    code = '# Get all events for agent\nagent_events = await tracker.get_agent_events("agent-001")\n\n# Filter by event type\nagent_failures = await tracker.get_agent_events(\n    "agent-001",\n    event_type=EventType.FAILURE,\n)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_operations_coordination_tracking_7():
    """Test code snippet from operations/coordination-tracking.md (line 258)."""
    code = '# Get complete handoff chain for workflow\nhandoff_chain = await tracker.get_handoff_chain("workflow-123")\n\n# Analyze handoff sequence\nfor i, handoff in enumerate(handoff_chain):\n    print(f"Handoff {i+1}: {handoff.source_agent.agent_type} → {handoff.target_agent.agent_type}")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_operations_coordination_tracking_8():
    """Test code snippet from operations/coordination-tracking.md (line 269)."""
    code = '# Get complete workflow timeline\ntimeline = await tracker.get_workflow_timeline("workflow-123")\n\nprint(f"Total events: {timeline[\'total_events\']}")\nprint(f"Duration: {timeline[\'duration_ms\']}ms")\nprint(f"Lifecycle events: {len(timeline[\'lifecycle\'])}")\nprint(f"Task events: {len(timeline[\'tasks\'])}")\nprint(f"Handoffs: {len(timeline[\'handoffs\'])}")\nprint(f"Failures: {len(timeline[\'failures\'])}")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_operations_coordination_tracking_9():
    """Test code snippet from operations/coordination-tracking.md (line 283)."""
    code = '# Workflow-specific statistics\nstats = await tracker.get_statistics("workflow-123")\nprint(f"Total events: {stats[\'total_events\']}")\nprint(f"Event types: {stats[\'event_types\']}")\nprint(f"Average duration: {stats[\'avg_duration_ms\']}ms")\nprint(f"Event type breakdown: {stats[\'event_type_counts\']}")\n\n# Global statistics\nglobal_stats = await tracker.get_statistics()\nprint(f"Total workflows tracked: {global_stats[\'total_workflows\']}")\nprint(f"Total events: {global_stats[\'total_events\']}")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_operations_coordination_tracking_10():
    """Test code snippet from operations/coordination-tracking.md (line 301)."""
    code = 'from coordination.orchestrator import WorkflowOrchestrator\nfrom coordination.state_manager import StateManager\nfrom coordination.tracker import CoordinationTracker\n\n# Initialize components\nstate_manager = StateManager(pool=pool)\nawait state_manager.initialize()\n\ntracker = CoordinationTracker(pool=pool)\nawait tracker.initialize()\n\norchestrator = WorkflowOrchestrator(state_manager)\n\n# Orchestrator automatically generates tracking events\n# You can add custom tracking in task executors:\n\nasync def my_task_executor(context):\n    # Track task start\n    await track_task_execution(\n        tracker,\n        context.workflow_id,\n        context.task_def.task_id,\n        context.task_def.agent_id,\n        context.task_def.agent_type,\n        "running",\n    )\n\n    try:\n        # Execute task\n        result = await do_work()\n\n        # Track success\n        await track_task_execution(\n            tracker,\n            context.workflow_id,\n            context.task_def.task_id,\n            context.task_def.agent_id,\n            context.task_def.agent_type,\n            "completed",\n            result_summary=result["summary"],\n        )\n\n        return result\n\n    except Exception as e:\n        # Track failure\n        await track_failure(\n            tracker,\n            context.workflow_id,\n            context.task_def.task_id,\n            context.task_def.agent_id,\n            context.task_def.agent_type,\n            type(e).__name__,\n            str(e),\n        )\n        raise'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_operations_coordination_tracking_11():
    """Test code snippet from operations/coordination-tracking.md (line 396)."""
    code = "   stats = await tracker.get_statistics()\n   event_rate = stats['total_events'] / time_window_seconds"

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_operations_coordination_tracking_12():
    """Test code snippet from operations/coordination-tracking.md (line 402)."""
    code = "   failure_count = stats['event_type_counts'].get('failure', 0)\n   failure_rate = failure_count / stats['total_events'] * 100"

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_operations_coordination_tracking_13():
    """Test code snippet from operations/coordination-tracking.md (line 413)."""
    code = "   # Use PostgreSQL query stats\n   SELECT query, mean_exec_time\n   FROM pg_stat_statements\n   WHERE query LIKE '%coordination_events%';"

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_operations_coordination_tracking_14():
    """Test code snippet from operations/coordination-tracking.md (line 433)."""
    code = '# Delete events older than 90 days\nasync def cleanup_old_events(tracker, days=90):\n    async with tracker._pool.acquire() as conn:\n        result = await conn.execute(\n            """\n            DELETE FROM coordination_events\n            WHERE timestamp < NOW() - INTERVAL \'%s days\'\n            """,\n            days,\n        )\n    print(f"Deleted {result} old events")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_operations_coordination_tracking_15():
    """Test code snippet from operations/coordination-tracking.md (line 537)."""
    code = '# Add audit logging to queries\nlogger.info(\n    f"User {user_id} accessed workflow events",\n    extra={"workflow_id": workflow_id, "user_id": user_id}\n)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_patterns_dual_mode_coordination_1():
    """Test code snippet from patterns/dual-mode-coordination.md (line 414)."""
    code = 'import pytest\nfrom unittest.mock import patch, MagicMock\n\nclass TestCoordination:\n    @pytest.fixture(params=["redis", "taskqueue", "markdown"])\n    def coordination_mode(self, request):\n        return request.param\n\n    async def test_store_agent_status(self, coordination_mode):\n        status = {\n            "agent_type": "ai-engineer",\n            "status": "busy",\n            "last_updated": "2025-10-12T14:30:00Z"\n        }\n\n        if coordination_mode == "redis":\n            # Test Redis path\n            with patch("mcp__RedisMCPServer__json_set") as mock:\n                await store_agent_status("ai-engineer", status)\n                assert mock.called\n\n        elif coordination_mode == "taskqueue":\n            # Test TaskQueue path\n            with patch("mcp__taskqueue__create_task") as mock:\n                await store_agent_status("ai-engineer", status)\n                assert mock.called\n\n        elif coordination_mode == "markdown":\n            # Test markdown path\n            with patch("builtins.open") as mock:\n                await store_agent_status("ai-engineer", status)\n                assert mock.called'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_patterns_markdown_coordination_1():
    """Test code snippet from patterns/markdown-coordination.md (line 262)."""
    code = 'import pandas as pd\nmanifest = pd.read_csv("data/processed/alice/manifest.csv")\ntrain_segments = manifest[manifest["split"] == "train"]'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_backlog_OPTION_A_AGENT_USAGE_ANALYTICS_1():
    """Test code snippet from projects/backlog/OPTION_A_AGENT_USAGE_ANALYTICS.md (line 117)."""
    code = 'class TelemetryCollector:\n    """Existing class - add new methods."""\n\n    def record_agent_usage(\n        self,\n        agent_id: str,\n        session_id: str,\n        context_type: str,\n        invocation_method: str,\n        category: str,\n        keywords: list[str],\n        session_duration_seconds: float | None = None,\n        tasks_completed: int | None = None,\n        effectiveness_score: float | None = None,\n    ) -> None:\n        """Track agent usage patterns.\n\n        Args:\n            agent_id: Agent identifier (e.g., "01-core-api-designer")\n            session_id: Unique session identifier\n            context_type: How agent was invoked:\n                - "manual": User explicitly invoked\n                - "suggested": System suggested, user accepted\n                - "auto": Automatically invoked by orchestrator\n            invocation_method: Discovery method:\n                - "direct": User typed agent name\n                - "search": Found via search()\n                - "category_filter": Found via list_agents(category=...)\n            category: Agent category (from index.json)\n            keywords: Agent keywords (from index.json)\n            session_duration_seconds: How long agent was active\n            tasks_completed: Number of tasks completed (if trackable)\n            effectiveness_score: User feedback score (1-5, optional)\n\n        Example:\n            >>> collector = TelemetryCollector(EventStorage())\n            >>> collector.record_agent_usage(\n            ...     agent_id="01-core-api-designer",\n            ...     session_id="session-abc123",\n            ...     context_type="manual",\n            ...     invocation_method="search",\n            ...     category="core-development",\n            ...     keywords=["api", "design", "rest"],\n            ...     session_duration_seconds=1200,\n            ...     tasks_completed=3,\n            ...     effectiveness_score=4.5\n            ... )\n        """\n        event = {\n            "timestamp": datetime.now(timezone.utc).isoformat(),\n            "event_type": "agent_usage",\n            "agent_id_hash": self._hash_agent_id(agent_id),\n            "session_id_hash": self._hash_session_id(session_id),\n            "context_type": context_type,\n            "invocation_method": invocation_method,\n            "category": category,\n            "keywords": keywords,\n        }\n\n        # Add optional fields if provided\n        if session_duration_seconds is not None:\n            event["session_duration_seconds"] = session_duration_seconds\n        if tasks_completed is not None:\n            event["tasks_completed"] = tasks_completed\n        if effectiveness_score is not None:\n            event["effectiveness_score"] = effectiveness_score\n\n        self._record_event(event)\n\n    def record_agent_effectiveness(\n        self,\n        agent_id: str,\n        session_id: str,\n        rating: int,\n        feedback_type: str,\n        task_success: bool,\n    ) -> None:\n        """Track user feedback on agent effectiveness.\n\n        Args:\n            agent_id: Agent identifier\n            session_id: Session identifier\n            rating: User rating (1-5 scale)\n            feedback_type: Type of feedback:\n                - "helpful": Agent was helpful\n                - "unhelpful": Agent was not helpful\n                - "suggested_improvement": User has suggestions\n            task_success: Whether task was successfully completed\n\n        Example:\n            >>> collector.record_agent_effectiveness(\n            ...     agent_id="01-core-api-designer",\n            ...     session_id="session-abc123",\n            ...     rating=5,\n            ...     feedback_type="helpful",\n            ...     task_success=True\n            ... )\n        """\n        event = {\n            "timestamp": datetime.now(timezone.utc).isoformat(),\n            "event_type": "agent_effectiveness",\n            "agent_id_hash": self._hash_agent_id(agent_id),\n            "session_id_hash": self._hash_session_id(session_id),\n            "rating": rating,\n            "feedback_type": feedback_type,\n            "task_success": task_success,\n        }\n        self._record_event(event)\n\n    @staticmethod\n    def _hash_session_id(session_id: str) -> str:\n        """Hash session ID for privacy (internal).\n\n        Args:\n            session_id: Session identifier\n\n        Returns:\n            Hashed session ID (first 8 chars of hex hash)\n        """\n        import hashlib\n        return hashlib.sha256(session_id.encode()).hexdigest()[:8]'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_backlog_OPTION_A_AGENT_USAGE_ANALYTICS_2():
    """Test code snippet from projects/backlog/OPTION_A_AGENT_USAGE_ANALYTICS.md (line 245)."""
    code = 'class UsageAnalyzer:\n    """Analyzes agent usage patterns from telemetry events.\n\n    Provides insights into agent popularity, category breakdown, unused\n    agents, and usage patterns over time.\n\n    Attributes:\n        storage: EventStorage backend for reading events\n\n    Example:\n        >>> storage = EventStorage()\n        >>> analyzer = UsageAnalyzer(storage)\n        >>> ranking = analyzer.get_popularity_ranking(days=30)\n        >>> len(ranking) > 0\n        True\n    """\n\n    def __init__(self, storage: EventStorage):\n        """Initialize usage analyzer.\n\n        Args:\n            storage: EventStorage backend for reading events\n        """\n        self.storage = storage\n\n    def get_popularity_ranking(\n        self,\n        days: int = 30,\n        min_usage: int = 1\n    ) -> list[dict[str, Any]]:\n        """Rank agents by usage frequency.\n\n        Returns agents sorted by usage count (descending) with usage\n        statistics including total invocations, average session duration,\n        and average effectiveness score.\n\n        Args:\n            days: Number of days to analyze (default: 30)\n            min_usage: Minimum usage count to include (default: 1)\n\n        Returns:\n            List of agent usage dictionaries:\n            [\n                {\n                    "agent_id_hash": "f2f2cbc2",\n                    "usage_count": 142,\n                    "avg_session_duration_seconds": 1200.5,\n                    "avg_effectiveness_score": 4.3,\n                    "category": "core-development",\n                    "last_used": "2025-10-19T12:00:00Z"\n                },\n                ...\n            ]\n\n        Example:\n            >>> analyzer = UsageAnalyzer(EventStorage())\n            >>> ranking = analyzer.get_popularity_ranking(days=30)\n            >>> ranking[0][\'usage_count\'] >= ranking[-1][\'usage_count\']\n            True\n        """\n        start_date = datetime.now(timezone.utc) - timedelta(days=days)\n        events = self.storage.read_events(start_date=start_date, limit=100000)\n\n        # Filter agent_usage events\n        usage_events = [\n            e for e in events if e.get("event_type") == "agent_usage"\n        ]\n\n        # Group by agent_id_hash\n        by_agent: dict[str, list[dict[str, Any]]] = {}\n        for event in usage_events:\n            agent_hash = event.get("agent_id_hash", "unknown")\n            if agent_hash not in by_agent:\n                by_agent[agent_hash] = []\n            by_agent[agent_hash].append(event)\n\n        # Compute stats for each agent\n        ranking = []\n        for agent_hash, agent_events in by_agent.items():\n            usage_count = len(agent_events)\n            if usage_count < min_usage:\n                continue\n\n            # Average session duration\n            durations = [\n                e["session_duration_seconds"]\n                for e in agent_events\n                if "session_duration_seconds" in e\n            ]\n            avg_duration = statistics.mean(durations) if durations else 0.0\n\n            # Average effectiveness score\n            scores = [\n                e["effectiveness_score"]\n                for e in agent_events\n                if "effectiveness_score" in e\n            ]\n            avg_score = statistics.mean(scores) if scores else None\n\n            # Last used timestamp\n            timestamps = [\n                e.get("timestamp", "")\n                for e in agent_events\n                if "timestamp" in e\n            ]\n            last_used = max(timestamps) if timestamps else None\n\n            # Category (most common in events)\n            categories = [e.get("category") for e in agent_events if "category" in e]\n            category = max(set(categories), key=categories.count) if categories else "unknown"\n\n            ranking.append({\n                "agent_id_hash": agent_hash,\n                "usage_count": usage_count,\n                "avg_session_duration_seconds": round(avg_duration, 2),\n                "avg_effectiveness_score": round(avg_score, 2) if avg_score else None,\n                "category": category,\n                "last_used": last_used,\n            })\n\n        # Sort by usage_count (descending)\n        ranking.sort(key=lambda x: x["usage_count"], reverse=True)\n\n        return ranking\n\n    def get_category_breakdown(self, days: int = 30) -> dict[str, int]:\n        """Get usage count breakdown by category.\n\n        Args:\n            days: Number of days to analyze (default: 30)\n\n        Returns:\n            Dictionary mapping category to usage count:\n            {\n                "core-development": 342,\n                "infrastructure": 128,\n                "frontend": 95,\n                ...\n            }\n\n        Example:\n            >>> analyzer = UsageAnalyzer(EventStorage())\n            >>> breakdown = analyzer.get_category_breakdown(days=30)\n            >>> isinstance(breakdown, dict)\n            True\n        """\n        start_date = datetime.now(timezone.utc) - timedelta(days=days)\n        events = self.storage.read_events(start_date=start_date, limit=100000)\n\n        usage_events = [\n            e for e in events if e.get("event_type") == "agent_usage"\n        ]\n\n        # Count by category\n        category_counts: dict[str, int] = {}\n        for event in usage_events:\n            category = event.get("category", "uncategorized")\n            category_counts[category] = category_counts.get(category, 0) + 1\n\n        # Sort by count (descending)\n        sorted_categories = dict(\n            sorted(category_counts.items(), key=lambda x: x[1], reverse=True)\n        )\n\n        return sorted_categories\n\n    def get_unused_agents(\n        self,\n        days: int = 30,\n        discovery: \'AgentDiscovery\' | None = None\n    ) -> list[dict[str, Any]]:\n        """Find agents with zero usage in time period.\n\n        Compares all available agents (from AgentDiscovery) against usage\n        events to identify "zombie agents" with no usage.\n\n        Args:\n            days: Number of days to check (default: 30)\n            discovery: Optional AgentDiscovery instance for full agent list\n                If None, returns only agent hashes without metadata\n\n        Returns:\n            List of unused agent dictionaries:\n            [\n                {\n                    "agent_id": "01-unused-agent",\n                    "agent_id_hash": "abc12345",\n                    "category": "data-science",\n                    "keywords": ["ml", "training"],\n                    "days_since_last_use": 45\n                },\n                ...\n            ]\n\n        Example:\n            >>> analyzer = UsageAnalyzer(EventStorage())\n            >>> from scripts.agent_discovery import AgentDiscovery\n            >>> discovery = AgentDiscovery(Path("plugins/mycelium-core/agents/index.json"))\n            >>> unused = analyzer.get_unused_agents(days=30, discovery=discovery)\n            >>> all(u[\'days_since_last_use\'] >= 30 for u in unused)\n            True\n        """\n        start_date = datetime.now(timezone.utc) - timedelta(days=days)\n        events = self.storage.read_events(limit=100000)  # All events, not just recent\n\n        # Get all used agent hashes (ever)\n        used_hashes = set()\n        for event in events:\n            if event.get("event_type") == "agent_usage":\n                used_hashes.add(event.get("agent_id_hash"))\n\n        # If discovery provided, compare against full agent list\n        if discovery is not None:\n            all_agents = discovery.list_agents()\n            unused = []\n\n            for agent in all_agents:\n                agent_id = agent.get("id", "")\n                agent_hash = self._hash_agent_id(agent_id)\n\n                if agent_hash not in used_hashes:\n                    # Never used\n                    unused.append({\n                        "agent_id": agent_id,\n                        "agent_id_hash": agent_hash,\n                        "category": agent.get("category", "unknown"),\n                        "keywords": agent.get("keywords", []),\n                        "days_since_last_use": float("inf"),  # Never used\n                    })\n                else:\n                    # Check if used recently\n                    recent_events = [\n                        e for e in events\n                        if e.get("event_type") == "agent_usage"\n                        and e.get("agent_id_hash") == agent_hash\n                    ]\n\n                    if not recent_events:\n                        continue\n\n                    # Get most recent usage\n                    timestamps = [\n                        datetime.fromisoformat(e.get("timestamp", ""))\n                        for e in recent_events\n                        if "timestamp" in e\n                    ]\n\n                    if not timestamps:\n                        continue\n\n                    last_used = max(timestamps)\n                    days_since = (datetime.now(timezone.utc) - last_used).days\n\n                    if days_since >= days:\n                        unused.append({\n                            "agent_id": agent_id,\n                            "agent_id_hash": agent_hash,\n                            "category": agent.get("category", "unknown"),\n                            "keywords": agent.get("keywords", []),\n                            "days_since_last_use": days_since,\n                        })\n\n            return unused\n\n        # No discovery provided - return hashes only\n        all_hashes_in_storage = set()\n        for event in events:\n            if event.get("event_type") == "agent_usage":\n                all_hashes_in_storage.add(event.get("agent_id_hash"))\n\n        # No way to determine unused without discovery\n        return []\n\n    def get_usage_heatmap(self, days: int = 30) -> dict[str, dict[int, int]]:\n        """Generate usage heatmap by day-of-week and hour-of-day.\n\n        Args:\n            days: Number of days to analyze (default: 30)\n\n        Returns:\n            Nested dictionary with usage counts:\n            {\n                "monday": {0: 5, 1: 2, ..., 23: 12},\n                "tuesday": {0: 3, 1: 8, ..., 23: 6},\n                ...\n            }\n\n            Outer keys: day names (lowercase)\n            Inner keys: hours (0-23)\n            Values: usage counts\n\n        Example:\n            >>> analyzer = UsageAnalyzer(EventStorage())\n            >>> heatmap = analyzer.get_usage_heatmap(days=30)\n            >>> \'monday\' in heatmap\n            True\n            >>> all(0 <= hour <= 23 for hours in heatmap.values() for hour in hours.keys())\n            True\n        """\n        start_date = datetime.now(timezone.utc) - timedelta(days=days)\n        events = self.storage.read_events(start_date=start_date, limit=100000)\n\n        usage_events = [\n            e for e in events if e.get("event_type") == "agent_usage"\n        ]\n\n        # Initialize heatmap\n        days_of_week = ["monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"]\n        heatmap: dict[str, dict[int, int]] = {\n            day: {hour: 0 for hour in range(24)}\n            for day in days_of_week\n        }\n\n        # Count by day and hour\n        for event in usage_events:\n            timestamp_str = event.get("timestamp", "")\n            try:\n                timestamp = datetime.fromisoformat(timestamp_str)\n                day_name = days_of_week[timestamp.weekday()]\n                hour = timestamp.hour\n                heatmap[day_name][hour] += 1\n            except (ValueError, IndexError):\n                continue\n\n        return heatmap\n\n    @staticmethod\n    def _hash_agent_id(agent_id: str) -> str:\n        """Hash agent ID for privacy (matches TelemetryCollector)."""\n        import hashlib\n        return hashlib.sha256(agent_id.encode()).hexdigest()[:8]\n\n\n# Extend MetricsAnalyzer to include usage stats in summary\nclass MetricsAnalyzer:\n    """Existing class - add method to include usage stats."""\n\n    def get_usage_stats(self, days: int = 30) -> dict[str, Any]:\n        """Get comprehensive usage statistics.\n\n        Combines popularity ranking, category breakdown, unused agents,\n        and usage heatmap into single report.\n\n        Args:\n            days: Number of days to analyze (default: 30)\n\n        Returns:\n            Dictionary with usage statistics:\n            {\n                "popularity_ranking": [...],\n                "category_breakdown": {...},\n                "unused_agents": [...],\n                "usage_heatmap": {...}\n            }\n        """\n        usage_analyzer = UsageAnalyzer(self.storage)\n\n        return {\n            "popularity_ranking": usage_analyzer.get_popularity_ranking(days),\n            "category_breakdown": usage_analyzer.get_category_breakdown(days),\n            "usage_heatmap": usage_analyzer.get_usage_heatmap(days),\n        }'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_backlog_OPTION_A_AGENT_USAGE_ANALYTICS_3():
    """Test code snippet from projects/backlog/OPTION_A_AGENT_USAGE_ANALYTICS.md (line 614)."""
    code = '#!/usr/bin/env python3\n"""CLI tool for viewing agent usage analytics.\n\nProvides command-line interface to usage statistics including popularity\nranking, category breakdown, and unused agent detection.\n\nUsage:\n    # Show top 10 most used agents\n    python scripts/agent_stats.py popularity --days 30 --limit 10\n\n    # Show category breakdown\n    python scripts/agent_stats.py categories --days 30\n\n    # Find unused agents\n    python scripts/agent_stats.py unused --days 30\n\n    # Show usage heatmap\n    python scripts/agent_stats.py heatmap --days 7\n\nAuthor: @claude-code-developer\nDate: 2025-10-18\n"""\n\nimport argparse\nfrom pathlib import Path\nfrom mycelium_analytics import EventStorage\nfrom mycelium_analytics.metrics import UsageAnalyzer\nfrom scripts.agent_discovery import AgentDiscovery\n\n\ndef cmd_popularity(args):\n    """Show popularity ranking."""\n    storage = EventStorage()\n    analyzer = UsageAnalyzer(storage)\n\n    ranking = analyzer.get_popularity_ranking(\n        days=args.days,\n        min_usage=args.min_usage\n    )\n\n    print(f"\\n=== Top {args.limit} Most Used Agents (Last {args.days} Days) ===\\n")\n\n    for i, agent in enumerate(ranking[:args.limit], 1):\n        print(f"{i}. Agent {agent[\'agent_id_hash\']}")\n        print(f"   Category: {agent[\'category\']}")\n        print(f"   Usage: {agent[\'usage_count\']} times")\n        print(f"   Avg Session: {agent[\'avg_session_duration_seconds\']:.1f}s")\n        if agent[\'avg_effectiveness_score\']:\n            print(f"   Avg Rating: {agent[\'avg_effectiveness_score\']:.1f}/5.0")\n        print(f"   Last Used: {agent[\'last_used\']}")\n        print()\n\n\ndef cmd_categories(args):\n    """Show category breakdown."""\n    storage = EventStorage()\n    analyzer = UsageAnalyzer(storage)\n\n    breakdown = analyzer.get_category_breakdown(days=args.days)\n\n    print(f"\\n=== Usage by Category (Last {args.days} Days) ===\\n")\n\n    total = sum(breakdown.values())\n    for category, count in breakdown.items():\n        percentage = (count / total * 100) if total > 0 else 0\n        bar = "█" * int(percentage / 2)\n        print(f"{category:30s} {count:4d} ({percentage:5.1f}%) {bar}")\n\n\ndef cmd_unused(args):\n    """Find unused agents."""\n    storage = EventStorage()\n    analyzer = UsageAnalyzer(storage)\n\n    # Load agent discovery\n    index_path = Path("plugins/mycelium-core/agents/index.json")\n    if not index_path.exists():\n        print(f"Error: Index not found at {index_path}")\n        return\n\n    discovery = AgentDiscovery(index_path)\n    unused = analyzer.get_unused_agents(days=args.days, discovery=discovery)\n\n    print(f"\\n=== Unused Agents (Last {args.days} Days) ===\\n")\n    print(f"Found {len(unused)} agents with no recent usage\\n")\n\n    for agent in unused[:args.limit]:\n        print(f"• {agent[\'agent_id\']}")\n        print(f"  Category: {agent[\'category\']}")\n        print(f"  Keywords: {\', \'.join(agent[\'keywords\'][:5])}")\n        days_since = agent[\'days_since_last_use\']\n        if days_since == float("inf"):\n            print(f"  Status: Never used")\n        else:\n            print(f"  Last Used: {days_since} days ago")\n        print()\n\n\ndef cmd_heatmap(args):\n    """Show usage heatmap."""\n    storage = EventStorage()\n    analyzer = UsageAnalyzer(storage)\n\n    heatmap = analyzer.get_usage_heatmap(days=args.days)\n\n    print(f"\\n=== Usage Heatmap (Last {args.days} Days) ===\\n")\n    print("Hour distribution by day of week:\\n")\n\n    # Print header\n    print("Day       ", end="")\n    for hour in [0, 6, 12, 18]:\n        print(f"{hour:>4}h", end=" ")\n    print()\n\n    # Print heatmap rows\n    for day, hours in heatmap.items():\n        print(f"{day.capitalize():10s}", end="")\n        for hour in [0, 6, 12, 18]:\n            count = hours[hour]\n            if count == 0:\n                symbol = "·"\n            elif count < 10:\n                symbol = "░"\n            elif count < 30:\n                symbol = "▒"\n            else:\n                symbol = "█"\n            print(f"  {symbol}  ", end=" ")\n        print()\n\n\ndef main():\n    parser = argparse.ArgumentParser(\n        description="Agent usage analytics CLI"\n    )\n    subparsers = parser.add_subparsers(dest="command", help="Command to run")\n\n    # Popularity command\n    pop_parser = subparsers.add_parser("popularity", help="Show popularity ranking")\n    pop_parser.add_argument("--days", type=int, default=30, help="Days to analyze")\n    pop_parser.add_argument("--limit", type=int, default=10, help="Number to show")\n    pop_parser.add_argument("--min-usage", type=int, default=1, help="Min usage count")\n\n    # Categories command\n    cat_parser = subparsers.add_parser("categories", help="Show category breakdown")\n    cat_parser.add_argument("--days", type=int, default=30, help="Days to analyze")\n\n    # Unused command\n    unused_parser = subparsers.add_parser("unused", help="Find unused agents")\n    unused_parser.add_argument("--days", type=int, default=30, help="Days to check")\n    unused_parser.add_argument("--limit", type=int, default=20, help="Max to show")\n\n    # Heatmap command\n    heat_parser = subparsers.add_parser("heatmap", help="Show usage heatmap")\n    heat_parser.add_argument("--days", type=int, default=7, help="Days to analyze")\n\n    args = parser.parse_args()\n\n    if args.command == "popularity":\n        cmd_popularity(args)\n    elif args.command == "categories":\n        cmd_categories(args)\n    elif args.command == "unused":\n        cmd_unused(args)\n    elif args.command == "heatmap":\n        cmd_heatmap(args)\n    else:\n        parser.print_help()\n\n\nif __name__ == "__main__":\n    main()'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_backlog_OPTION_A_AGENT_USAGE_ANALYTICS_4():
    """Test code snippet from projects/backlog/OPTION_A_AGENT_USAGE_ANALYTICS.md (line 793)."""
    code = 'class AgentDiscovery:\n    """Existing class - add usage tracking to get_agent()."""\n\n    def get_agent(self, agent_id: str) -> Optional[Dict[str, Any]]:\n        """Get agent details (lazy load content).\n\n        MODIFIED: Now tracks usage via telemetry.\n        """\n        start_time = time.perf_counter()\n        self._stats[\'total_lookups\'] += 1\n\n        # ... existing cache check code ...\n\n        # NEW: Track usage event (if telemetry available)\n        if self.telemetry and agent_full:\n            # Generate session ID (use thread ID for now)\n            import threading\n            session_id = f"session-{threading.get_ident()}"\n\n            self.telemetry.record_agent_usage(\n                agent_id=agent_id,\n                session_id=session_id,\n                context_type="manual",  # Assume manual for now\n                invocation_method="direct",  # Direct get_agent() call\n                category=agent_meta.get("category", "unknown"),\n                keywords=agent_meta.get("keywords", []),\n            )\n\n        return agent_full'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_backlog_OPTION_A_AGENT_USAGE_ANALYTICS_5():
    """Test code snippet from projects/backlog/OPTION_A_AGENT_USAGE_ANALYTICS.md (line 833)."""
    code = '"""Unit tests for UsageAnalyzer."""\n\nimport pytest\nfrom datetime import datetime, timezone, timedelta\nfrom mycelium_analytics import EventStorage\nfrom mycelium_analytics.metrics import UsageAnalyzer\n\n\n@pytest.fixture\ndef storage_with_usage_data(tmp_path):\n    """Create storage with sample usage events."""\n    storage = EventStorage(storage_dir=tmp_path)\n\n    # Add sample events\n    for i in range(10):\n        storage.append_event({\n            "timestamp": (datetime.now(timezone.utc) - timedelta(days=i)).isoformat(),\n            "event_type": "agent_usage",\n            "agent_id_hash": "f2f2cbc2",\n            "category": "core-development",\n            "session_duration_seconds": 1200,\n            "effectiveness_score": 4.5,\n        })\n\n    return storage\n\n\ndef test_popularity_ranking(storage_with_usage_data):\n    """Test popularity ranking calculation."""\n    analyzer = UsageAnalyzer(storage_with_usage_data)\n    ranking = analyzer.get_popularity_ranking(days=30)\n\n    assert len(ranking) > 0\n    assert ranking[0]["usage_count"] == 10\n    assert ranking[0]["agent_id_hash"] == "f2f2cbc2"\n\n\ndef test_category_breakdown(storage_with_usage_data):\n    """Test category breakdown."""\n    analyzer = UsageAnalyzer(storage_with_usage_data)\n    breakdown = analyzer.get_category_breakdown(days=30)\n\n    assert "core-development" in breakdown\n    assert breakdown["core-development"] == 10\n\n\ndef test_usage_heatmap(storage_with_usage_data):\n    """Test heatmap generation."""\n    analyzer = UsageAnalyzer(storage_with_usage_data)\n    heatmap = analyzer.get_usage_heatmap(days=30)\n\n    assert "monday" in heatmap\n    assert all(0 <= hour <= 23 for hours in heatmap.values() for hour in hours.keys())'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_backlog_OPTION_B_AGENT_PROMPT_OPTIMIZATION_1():
    """Test code snippet from projects/backlog/OPTION_B_AGENT_PROMPT_OPTIMIZATION.md (line 387)."""
    code = '"""Prompt quality analysis using rubric and NLP.\n\nAnalyzes agent prompts against quality rubric to identify improvement\nopportunities. Combines static analysis (readability, structure) with\ndynamic metrics (usage analytics).\n\nAuthor: @claude-code-developer\nDate: 2025-10-18\n"""\n\nimport re\nimport yaml\nfrom pathlib import Path\nfrom typing import Any\nimport textstat  # For readability metrics\nfrom mycelium_analytics import EventStorage\nfrom mycelium_analytics.metrics import UsageAnalyzer\n\n\nclass PromptAnalyzer:\n    """Analyzes agent prompt quality against rubric.\n\n    Computes scores for clarity, specificity, consistency, effectiveness,\n    and constraints based on automated analysis and analytics data.\n\n    Attributes:\n        rubric: Quality rubric configuration (from YAML)\n        usage_analyzer: UsageAnalyzer for effectiveness metrics\n\n    Example:\n        >>> analyzer = PromptAnalyzer()\n        >>> result = analyzer.analyze_prompt("path/to/agent.md")\n        >>> result[\'total_score\']\n        82.5\n        >>> result[\'grade\']\n        \'B\'\n    """\n\n    def __init__(\n        self,\n        rubric_path: Path | None = None,\n        usage_analyzer: UsageAnalyzer | None = None\n    ):\n        """Initialize analyzer with rubric and analytics.\n\n        Args:\n            rubric_path: Path to rubric YAML (default: config/prompt_quality_rubric.yaml)\n            usage_analyzer: Optional UsageAnalyzer for effectiveness metrics\n        """\n        if rubric_path is None:\n            rubric_path = Path("config/prompt_quality_rubric.yaml")\n\n        with open(rubric_path) as f:\n            self.rubric = yaml.safe_load(f)\n\n        self.usage_analyzer = usage_analyzer\n\n    def analyze_prompt(\n        self,\n        prompt_path: Path,\n        agent_id: str | None = None\n    ) -> dict[str, Any]:\n        """Analyze prompt against quality rubric.\n\n        Args:\n            prompt_path: Path to agent markdown file\n            agent_id: Optional agent ID for analytics lookup\n\n        Returns:\n            Analysis result dictionary:\n            {\n                "total_score": 82.5,\n                "grade": "B",\n                "criteria_scores": {\n                    "clarity": {"score": 85.0, "metrics": {...}},\n                    "specificity": {...},\n                    ...\n                },\n                "suggestions": ["Improve readability...", ...]\n            }\n\n        Example:\n            >>> analyzer = PromptAnalyzer()\n            >>> result = analyzer.analyze_prompt(Path("agents/01-core-api-designer.md"))\n            >>> result[\'grade\'] in [\'A\', \'B\', \'C\', \'D\', \'F\']\n            True\n        """\n        # Read prompt content\n        content = prompt_path.read_text(encoding=\'utf-8\')\n\n        # Analyze each criterion\n        criteria_scores = {}\n\n        criteria_scores[\'clarity\'] = self._analyze_clarity(content)\n        criteria_scores[\'specificity\'] = self._analyze_specificity(content)\n        criteria_scores[\'consistency\'] = self._analyze_consistency(content)\n        criteria_scores[\'effectiveness\'] = self._analyze_effectiveness(\n            agent_id=agent_id\n        )\n        criteria_scores[\'constraints\'] = self._analyze_constraints(content)\n\n        # Compute total score\n        total_score = 0.0\n        for criterion_name, criterion_data in criteria_scores.items():\n            criterion_weight = self.rubric[\'criteria\'][criterion_name][\'weight\']\n            criterion_score = criterion_data[\'score\']\n            total_score += criterion_weight * criterion_score\n\n        # Determine grade\n        grade = self._get_grade(total_score)\n\n        # Generate suggestions\n        suggestions = self._generate_suggestions(criteria_scores)\n\n        return {\n            "total_score": round(total_score, 2),\n            "grade": grade,\n            "criteria_scores": criteria_scores,\n            "suggestions": suggestions,\n            "token_count": len(content.split()),  # Rough estimate\n            "char_count": len(content),\n        }\n\n    def _analyze_clarity(self, content: str) -> dict[str, Any]:\n        """Analyze clarity metrics (readability, sentence complexity, jargon)."""\n        metrics = {}\n\n        # Readability score (Flesch Reading Ease)\n        readability = textstat.flesch_reading_ease(content)\n        metrics[\'readability_score\'] = {\n            "value": readability,\n            "score": self._score_metric(readability, \'clarity\', \'readability_score\'),\n        }\n\n        # Sentence complexity (average sentence length)\n        sentences = re.split(r\'[.!?]+\', content)\n        words = content.split()\n        avg_sentence_length = len(words) / max(len(sentences), 1)\n        metrics[\'sentence_complexity\'] = {\n            "value": avg_sentence_length,\n            "score": self._score_metric(avg_sentence_length, \'clarity\', \'sentence_complexity\'),\n        }\n\n        # Jargon ratio (technical terms / total words)\n        # Load technical terms list\n        tech_terms_path = Path(self.rubric[\'criteria\'][\'clarity\'][\'metrics\'][\'jargon_ratio\'].get(\'technical_terms_list\', \'config/technical_terms.txt\'))\n        tech_terms = set()\n        if tech_terms_path.exists():\n            tech_terms = set(tech_terms_path.read_text().strip().split(\'\\n\'))\n\n        content_lower = content.lower()\n        jargon_count = sum(1 for term in tech_terms if term.lower() in content_lower)\n        jargon_ratio = jargon_count / max(len(words), 1)\n        metrics[\'jargon_ratio\'] = {\n            "value": jargon_ratio,\n            "score": self._score_metric(jargon_ratio, \'clarity\', \'jargon_ratio\'),\n        }\n\n        # Weighted average of clarity metrics\n        total_score = sum(\n            m[\'score\'] * self.rubric[\'criteria\'][\'clarity\'][\'metrics\'][metric_name][\'weight\']\n            for metric_name, m in metrics.items()\n        )\n\n        return {\n            "score": round(total_score, 2),\n            "metrics": metrics,\n        }\n\n    def _analyze_specificity(self, content: str) -> dict[str, Any]:\n        """Analyze specificity metrics (examples, code snippets, concrete language)."""\n        metrics = {}\n\n        # Example count\n        example_patterns = self.rubric[\'criteria\'][\'specificity\'][\'metrics\'][\'example_count\'][\'patterns\']\n        example_count = sum(\n            len(re.findall(pattern, content, re.IGNORECASE))\n            for pattern in example_patterns\n        )\n        metrics[\'example_count\'] = {\n            "value": example_count,\n            "score": self._score_metric(example_count, \'specificity\', \'example_count\'),\n        }\n\n        # Code snippet count\n        code_snippet_count = content.count(\''

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_backlog_OPTION_B_AGENT_PROMPT_OPTIMIZATION_2():
    """Test code snippet from projects/backlog/OPTION_B_AGENT_PROMPT_OPTIMIZATION.md (line 880)."""
    code = '"""Prompt optimization engine with template application and A/B testing.\n\nApplies optimization templates to improve prompt quality based on rubric\nanalysis. Supports batch optimization and A/B testing of improvements.\n\nAuthor: @claude-code-developer + @documentation-engineer\nDate: 2025-10-18\n"""\n\nfrom pathlib import Path\nfrom typing import Any\nimport re\n\n\nclass PromptOptimizer:\n    """Optimizes agent prompts using templates and best practices.\n\n    Provides methods to apply standard templates, optimize for tokens,\n    suggest improvements, and A/B test changes.\n\n    Attributes:\n        analyzer: PromptAnalyzer for quality assessment\n        template_dir: Directory containing optimization templates\n\n    Example:\n        >>> optimizer = PromptOptimizer()\n        >>> suggestions = optimizer.suggest_improvements("agents/01-api-designer.md")\n        >>> len(suggestions) > 0\n        True\n    """\n\n    def __init__(\n        self,\n        analyzer: \'PromptAnalyzer\',\n        template_dir: Path | None = None\n    ):\n        """Initialize optimizer.\n\n        Args:\n            analyzer: PromptAnalyzer instance\n            template_dir: Directory with templates (default: templates/prompts/)\n        """\n        self.analyzer = analyzer\n        self.template_dir = template_dir or Path("templates/prompts")\n\n    def suggest_improvements(\n        self,\n        prompt_path: Path,\n        agent_id: str | None = None\n    ) -> list[dict[str, Any]]:\n        """Analyze prompt and suggest specific improvements.\n\n        Args:\n            prompt_path: Path to agent markdown file\n            agent_id: Optional agent ID for analytics\n\n        Returns:\n            List of improvement suggestions:\n            [\n                {\n                    "category": "clarity",\n                    "issue": "Low readability score (45/100)",\n                    "suggestion": "Simplify sentence structure",\n                    "priority": "high",\n                    "estimated_impact": "+10 points"\n                },\n                ...\n            ]\n\n        Example:\n            >>> optimizer = PromptOptimizer(PromptAnalyzer())\n            >>> suggestions = optimizer.suggest_improvements(Path("agents/01-api-designer.md"))\n            >>> all(\'priority\' in s for s in suggestions)\n            True\n        """\n        analysis = self.analyzer.analyze_prompt(prompt_path, agent_id)\n        suggestions = []\n\n        # Analyze each criterion\n        for criterion_name, criterion_data in analysis[\'criteria_scores\'].items():\n            score = criterion_data[\'score\']\n\n            if score < 70:\n                # High priority improvement needed\n                suggestions.append({\n                    "category": criterion_name,\n                    "issue": f"Low {criterion_name} score ({score:.1f}/100)",\n                    "suggestion": self._get_criterion_suggestion(criterion_name, criterion_data),\n                    "priority": "high",\n                    "estimated_impact": f"+{100 - score:.0f} points",\n                })\n            elif score < 85:\n                # Medium priority\n                suggestions.append({\n                    "category": criterion_name,\n                    "issue": f"{criterion_name.capitalize()} could be improved ({score:.1f}/100)",\n                    "suggestion": self._get_criterion_suggestion(criterion_name, criterion_data),\n                    "priority": "medium",\n                    "estimated_impact": f"+{100 - score:.0f} points",\n                })\n\n        return suggestions\n\n    def apply_template(\n        self,\n        prompt_path: Path,\n        template_name: str = "standard_agent_template.md"\n    ) -> str:\n        """Apply standard template to agent prompt.\n\n        Args:\n            prompt_path: Path to existing agent file\n            template_name: Template file name\n\n        Returns:\n            Optimized prompt content\n\n        Example:\n            >>> optimizer = PromptOptimizer(PromptAnalyzer())\n            >>> optimized = optimizer.apply_template(Path("agents/01-api-designer.md"))\n            >>> "## Your Role" in optimized\n            True\n        """\n        # Load template\n        template_path = self.template_dir / template_name\n        if not template_path.exists():\n            raise FileNotFoundError(f"Template not found: {template_path}")\n\n        template = template_path.read_text(encoding=\'utf-8\')\n\n        # Extract existing content sections\n        existing_content = prompt_path.read_text(encoding=\'utf-8\')\n        sections = self._extract_sections(existing_content)\n\n        # Fill template with existing content\n        optimized = template\n\n        for section_name, section_content in sections.items():\n            placeholder = f"{{{{ {section_name} }}}}"\n            if placeholder in optimized:\n                optimized = optimized.replace(placeholder, section_content)\n\n        return optimized\n\n    def optimize_for_tokens(\n        self,\n        prompt_path: Path,\n        target_reduction: float = 0.20\n    ) -> tuple[str, dict[str, Any]]:\n        """Optimize prompt to reduce token count.\n\n        Args:\n            prompt_path: Path to agent file\n            target_reduction: Target token reduction (0.20 = 20%)\n\n        Returns:\n            Tuple of (optimized_content, stats):\n            - optimized_content: Reduced prompt\n            - stats: {\n                "original_tokens": 1200,\n                "optimized_tokens": 960,\n                "reduction_percentage": 20.0,\n                "methods_applied": ["remove_redundancy", "shorten_examples"]\n              }\n\n        Example:\n            >>> optimizer = PromptOptimizer(PromptAnalyzer())\n            >>> content, stats = optimizer.optimize_for_tokens(Path("agents/verbose.md"))\n            >>> stats[\'reduction_percentage\'] > 0\n            True\n        """\n        content = prompt_path.read_text(encoding=\'utf-8\')\n        original_tokens = len(content.split())\n\n        methods_applied = []\n\n        # Method 1: Remove redundant phrases\n        content, reduced = self._remove_redundancy(content)\n        if reduced:\n            methods_applied.append("remove_redundancy")\n\n        # Method 2: Shorten verbose examples\n        content, reduced = self._shorten_examples(content)\n        if reduced:\n            methods_applied.append("shorten_examples")\n\n        # Method 3: Consolidate bullet points\n        content, reduced = self._consolidate_bullets(content)\n        if reduced:\n            methods_applied.append("consolidate_bullets")\n\n        # Compute stats\n        optimized_tokens = len(content.split())\n        reduction_percentage = ((original_tokens - optimized_tokens) / original_tokens) * 100\n\n        stats = {\n            "original_tokens": original_tokens,\n            "optimized_tokens": optimized_tokens,\n            "reduction_percentage": round(reduction_percentage, 2),\n            "methods_applied": methods_applied,\n        }\n\n        return content, stats\n\n    def ab_test_versions(\n        self,\n        original_path: Path,\n        optimized_path: Path,\n        days: int = 14\n    ) -> dict[str, Any]:\n        """Compare original vs optimized prompt using analytics.\n\n        Args:\n            original_path: Path to original agent\n            optimized_path: Path to optimized version\n            days: Days to collect data\n\n        Returns:\n            A/B test results:\n            {\n                "original": {"score": 78.0, "usage": 42, "rating": 3.8},\n                "optimized": {"score": 85.0, "usage": 56, "rating": 4.2},\n                "improvement": {\n                    "score_delta": +7.0,\n                    "usage_delta": +33%,\n                    "rating_delta": +0.4\n                },\n                "winner": "optimized"\n            }\n\n        Example:\n            >>> optimizer = PromptOptimizer(PromptAnalyzer())\n            >>> results = optimizer.ab_test_versions(\n            ...     Path("agents/01-api-designer.md"),\n            ...     Path("agents/01-api-designer-optimized.md"),\n            ...     days=14\n            ... )\n            >>> results[\'winner\'] in [\'original\', \'optimized\', \'tie\']\n            True\n        """\n        # Analyze both versions\n        original_analysis = self.analyzer.analyze_prompt(original_path)\n        optimized_analysis = self.analyzer.analyze_prompt(optimized_path)\n\n        # TODO: Collect real usage data over time period\n        # For now, return analysis comparison\n\n        original_score = original_analysis[\'total_score\']\n        optimized_score = optimized_analysis[\'total_score\']\n\n        score_delta = optimized_score - original_score\n\n        winner = "tie"\n        if score_delta > 5:\n            winner = "optimized"\n        elif score_delta < -5:\n            winner = "original"\n\n        return {\n            "original": {\n                "score": original_score,\n                "grade": original_analysis[\'grade\'],\n            },\n            "optimized": {\n                "score": optimized_score,\n                "grade": optimized_analysis[\'grade\'],\n            },\n            "improvement": {\n                "score_delta": round(score_delta, 2),\n            },\n            "winner": winner,\n        }\n\n    def _get_criterion_suggestion(\n        self,\n        criterion_name: str,\n        criterion_data: dict\n    ) -> str:\n        """Generate specific suggestion for criterion improvement."""\n        suggestions_map = {\n            "clarity": "Simplify language, reduce jargon, shorten sentences",\n            "specificity": "Add more concrete examples and code snippets",\n            "consistency": "Follow standard template structure and tone guidelines",\n            "effectiveness": "Gather user feedback to improve relevance",\n            "constraints": "Explicitly state limitations and out-of-scope items",\n        }\n        return suggestions_map.get(criterion_name, "Review rubric for details")\n\n    def _extract_sections(self, content: str) -> dict[str, str]:\n        """Extract Markdown sections from content."""\n        sections = {}\n        pattern = r\'^##\\s+(.+?)\\n+(.*?)(?=\\n##|\\Z)\'\n        matches = re.finditer(pattern, content, re.MULTILINE | re.DOTALL)\n\n        for match in matches:\n            heading = match.group(1).strip()\n            section_content = match.group(2).strip()\n            sections[heading] = section_content\n\n        return sections\n\n    def _remove_redundancy(self, content: str) -> tuple[str, bool]:\n        """Remove redundant phrases."""\n        redundant_phrases = [\n            r\'\\s+basically\\s+\',\n            r\'\\s+essentially\\s+\',\n            r\'\\s+in other words\\s+\',\n            r\'\\s+as mentioned before\\s+\',\n        ]\n\n        modified = content\n        for phrase in redundant_phrases:\n            modified = re.sub(phrase, \' \', modified, flags=re.IGNORECASE)\n\n        return modified, modified != content\n\n    def _shorten_examples(self, content: str) -> tuple[str, bool]:\n        """Shorten verbose examples (keep first 3 lines)."""\n        # Find example blocks\n        pattern = r\'(Example:.*?)(?=\\n##|\\Z)\'\n        matches = re.finditer(pattern, content, re.DOTALL)\n\n        modified = content\n        for match in matches:\n            example_block = match.group(1)\n            lines = example_block.split(\'\\n\')\n            if len(lines) > 5:\n                # Keep first 3 lines + ellipsis\n                shortened = \'\\n\'.join(lines[:3]) + \'\\n    ...\'\n                modified = modified.replace(example_block, shortened)\n\n        return modified, modified != content\n\n    def _consolidate_bullets(self, content: str) -> tuple[str, bool]:\n        """Consolidate related bullet points."""\n        # Simple heuristic: if 3+ consecutive bullets start with same word, consolidate\n        pattern = r\'(^-\\s+(\\w+).*\\n(?:-\\s+\\2.*\\n){2,})\'\n        matches = re.finditer(pattern, content, re.MULTILINE)\n\n        modified = content\n        for match in matches:\n            bullet_block = match.group(1)\n            lines = bullet_block.strip().split(\'\\n\')\n            first_word = match.group(2)\n\n            # Consolidate to single bullet\n            consolidated = f"- {first_word}: " + ", ".join(\n                line.split(\':\', 1)[-1].strip() for line in lines\n            )\n            modified = modified.replace(bullet_block, consolidated + \'\\n\')\n\n        return modified, modified != content'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_backlog_OPTION_B_AGENT_PROMPT_OPTIMIZATION_3():
    """Test code snippet from projects/backlog/OPTION_B_AGENT_PROMPT_OPTIMIZATION.md (line 1239)."""
    code = '#!/usr/bin/env python3\n"""CLI tool for agent prompt optimization.\n\nUsage:\n    # Analyze single agent\n    python scripts/optimize_agent.py analyze agents/01-api-designer.md\n\n    # Batch analyze category\n    python scripts/optimize_agent.py batch-analyze --category core-development\n\n    # Optimize single agent\n    python scripts/optimize_agent.py optimize agents/01-api-designer.md --output agents/01-api-designer-v2.md\n\n    # Batch optimize (lowest scores first)\n    python scripts/optimize_agent.py batch-optimize --min-score 70 --dry-run\n\nAuthor: @claude-code-developer + @documentation-engineer\nDate: 2025-10-18\n"""\n\nimport argparse\nfrom pathlib import Path\nfrom mycelium_analytics import EventStorage\nfrom mycelium_analytics.metrics import UsageAnalyzer\nfrom scripts.prompt_analyzer import PromptAnalyzer\nfrom scripts.prompt_optimizer import PromptOptimizer\nfrom scripts.agent_discovery import AgentDiscovery\n\n\ndef cmd_analyze(args):\n    """Analyze single agent prompt."""\n    analyzer = PromptAnalyzer(\n        usage_analyzer=UsageAnalyzer(EventStorage()) if args.include_analytics else None\n    )\n\n    result = analyzer.analyze_prompt(\n        Path(args.agent_path),\n        agent_id=args.agent_id\n    )\n\n    print(f"\\n=== Analysis: {args.agent_path} ===\\n")\n    print(f"Total Score: {result[\'total_score\']:.1f}/100  (Grade: {result[\'grade\']})")\n    print(f"Token Count: {result[\'token_count\']}")\n    print()\n\n    print("Criterion Scores:")\n    for criterion, data in result[\'criteria_scores\'].items():\n        print(f"  {criterion.capitalize():15s}: {data[\'score\']:5.1f}/100")\n    print()\n\n    if result[\'suggestions\']:\n        print("Suggestions for Improvement:")\n        for suggestion in result[\'suggestions\']:\n            print(f"  - {suggestion}")\n        print()\n\n\ndef cmd_batch_analyze(args):\n    """Batch analyze agents by category."""\n    # Load agent discovery\n    index_path = Path("plugins/mycelium-core/agents/index.json")\n    discovery = AgentDiscovery(index_path)\n\n    # Get agents in category\n    agents = discovery.list_agents(category=args.category)\n\n    analyzer = PromptAnalyzer(\n        usage_analyzer=UsageAnalyzer(EventStorage()) if args.include_analytics else None\n    )\n\n    print(f"\\n=== Batch Analysis: {args.category} ===\\n")\n    print(f"Analyzing {len(agents)} agents...\\n")\n\n    results = []\n    for agent in agents:\n        agent_path = Path(agent[\'file_path\'])\n        result = analyzer.analyze_prompt(agent_path, agent_id=agent[\'id\'])\n        results.append({\n            \'agent_id\': agent[\'id\'],\n            \'score\': result[\'total_score\'],\n            \'grade\': result[\'grade\'],\n            \'token_count\': result[\'token_count\'],\n        })\n\n    # Sort by score (lowest first)\n    results.sort(key=lambda x: x[\'score\'])\n\n    # Print summary\n    for r in results:\n        print(f"{r[\'agent_id\']:40s}  {r[\'score\']:5.1f}  ({r[\'grade\']})  {r[\'token_count\']} tokens")\n\n    print()\n    avg_score = sum(r[\'score\'] for r in results) / len(results)\n    print(f"Average Score: {avg_score:.1f}/100")\n    print(f"Agents below 70: {sum(1 for r in results if r[\'score\'] < 70)}")\n\n\ndef cmd_optimize(args):\n    """Optimize single agent."""\n    optimizer = PromptOptimizer(\n        analyzer=PromptAnalyzer(usage_analyzer=UsageAnalyzer(EventStorage()))\n    )\n\n    suggestions = optimizer.suggest_improvements(\n        Path(args.agent_path)\n    )\n\n    print(f"\\n=== Optimization Suggestions: {args.agent_path} ===\\n")\n\n    for s in suggestions:\n        print(f"[{s[\'priority\'].upper()}] {s[\'category\'].capitalize()}")\n        print(f"  Issue: {s[\'issue\']}")\n        print(f"  Suggestion: {s[\'suggestion\']}")\n        print(f"  Estimated Impact: {s[\'estimated_impact\']}")\n        print()\n\n    if args.apply:\n        print("Applying template...")\n        optimized = optimizer.apply_template(Path(args.agent_path))\n\n        output_path = Path(args.output) if args.output else Path(args.agent_path).with_suffix(\'.optimized.md\')\n        output_path.write_text(optimized, encoding=\'utf-8\')\n        print(f"Optimized prompt written to: {output_path}")\n\n\ndef cmd_batch_optimize(args):\n    """Batch optimize agents below score threshold."""\n    # Load agent discovery\n    index_path = Path("plugins/mycelium-core/agents/index.json")\n    discovery = AgentDiscovery(index_path)\n\n    analyzer = PromptAnalyzer(\n        usage_analyzer=UsageAnalyzer(EventStorage())\n    )\n    optimizer = PromptOptimizer(analyzer=analyzer)\n\n    # Analyze all agents\n    all_agents = discovery.list_agents()\n    candidates = []\n\n    for agent in all_agents:\n        agent_path = Path(agent[\'file_path\'])\n        result = analyzer.analyze_prompt(agent_path, agent_id=agent[\'id\'])\n\n        if result[\'total_score\'] < args.min_score:\n            candidates.append({\n                \'agent_id\': agent[\'id\'],\n                \'path\': agent_path,\n                \'score\': result[\'total_score\'],\n            })\n\n    # Sort by score (lowest first)\n    candidates.sort(key=lambda x: x[\'score\'])\n\n    print(f"\\n=== Batch Optimization ===\\n")\n    print(f"Found {len(candidates)} agents below {args.min_score}/100\\n")\n\n    for candidate in candidates[:args.limit]:\n        print(f"Optimizing: {candidate[\'agent_id\']} ({candidate[\'score\']:.1f}/100)")\n\n        if not args.dry_run:\n            suggestions = optimizer.suggest_improvements(candidate[\'path\'])\n            # TODO: Apply optimizations\n            print(f"  - {len(suggestions)} improvements suggested")\n        else:\n            print("  [DRY RUN - skipped]")\n\n\ndef main():\n    parser = argparse.ArgumentParser(description="Agent prompt optimization CLI")\n    subparsers = parser.add_subparsers(dest="command", help="Command to run")\n\n    # Analyze command\n    analyze_parser = subparsers.add_parser("analyze", help="Analyze single agent")\n    analyze_parser.add_argument("agent_path", help="Path to agent markdown file")\n    analyze_parser.add_argument("--agent-id", help="Agent ID for analytics lookup")\n    analyze_parser.add_argument("--include-analytics", action="store_true", help="Include effectiveness metrics")\n\n    # Batch analyze command\n    batch_analyze_parser = subparsers.add_parser("batch-analyze", help="Analyze category")\n    batch_analyze_parser.add_argument("--category", required=True, help="Agent category")\n    batch_analyze_parser.add_argument("--include-analytics", action="store_true")\n\n    # Optimize command\n    optimize_parser = subparsers.add_parser("optimize", help="Optimize single agent")\n    optimize_parser.add_argument("agent_path", help="Path to agent markdown file")\n    optimize_parser.add_argument("--output", help="Output path for optimized version")\n    optimize_parser.add_argument("--apply", action="store_true", help="Apply template")\n\n    # Batch optimize command\n    batch_optimize_parser = subparsers.add_parser("batch-optimize", help="Batch optimize low-scoring agents")\n    batch_optimize_parser.add_argument("--min-score", type=float, default=70, help="Min acceptable score")\n    batch_optimize_parser.add_argument("--limit", type=int, default=10, help="Max agents to optimize")\n    batch_optimize_parser.add_argument("--dry-run", action="store_true", help="Dry run (no changes)")\n\n    args = parser.parse_args()\n\n    if args.command == "analyze":\n        cmd_analyze(args)\n    elif args.command == "batch-analyze":\n        cmd_batch_analyze(args)\n    elif args.command == "optimize":\n        cmd_optimize(args)\n    elif args.command == "batch-optimize":\n        cmd_batch_optimize(args)\n    else:\n        parser.print_help()\n\n\nif __name__ == "__main__":\n    main()'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_backlog_OPTION_B_AGENT_PROMPT_OPTIMIZATION_4():
    """Test code snippet from projects/backlog/OPTION_B_AGENT_PROMPT_OPTIMIZATION.md (line 1459)."""
    code = '"""Unit tests for prompt analyzer and optimizer."""\n\nimport pytest\nfrom pathlib import Path\nfrom scripts.prompt_analyzer import PromptAnalyzer\nfrom scripts.prompt_optimizer import PromptOptimizer\n\n\ndef test_analyze_clarity(tmp_path):\n    """Test clarity analysis."""\n    content = "This is a simple test. It has short sentences. Easy to read."\n    test_file = tmp_path / "test.md"\n    test_file.write_text(content)\n\n    analyzer = PromptAnalyzer()\n    result = analyzer.analyze_prompt(test_file)\n\n    assert \'clarity\' in result[\'criteria_scores\']\n    assert result[\'criteria_scores\'][\'clarity\'][\'score\'] > 0\n\n\ndef test_token_optimization(tmp_path):\n    """Test token reduction."""\n    verbose_content = """\n    This is basically a very verbose example that essentially contains\n    redundant phrases. As mentioned before, we should remove these.\n    """\n    test_file = tmp_path / "verbose.md"\n    test_file.write_text(verbose_content)\n\n    optimizer = PromptOptimizer(PromptAnalyzer())\n    optimized, stats = optimizer.optimize_for_tokens(test_file)\n\n    assert stats[\'reduction_percentage\'] > 0\n    assert stats[\'optimized_tokens\'] < stats[\'original_tokens\']'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_backlog_OPTION_C_SMART_AGENT_SUGGESTIONS_1():
    """Test code snippet from projects/backlog/OPTION_C_SMART_AGENT_SUGGESTIONS.md (line 112)."""
    code = '"""Context extraction from files, git, and user queries.\n\nAnalyzes working directory context to extract relevant keywords for\nagent recommendation. Supports file type detection, git branch/commit\nparsing, and NLP-based query understanding.\n\nAuthor: @claude-code-developer + @ml-engineer\nDate: 2025-10-18\n"""\n\nimport subprocess\nfrom pathlib import Path\nfrom typing import Any\nimport re\n\n\nclass ContextExtractor:\n    """Extracts context keywords from environment.\n\n    Analyzes open files, git state, and user queries to build a semantic\n    context vector for agent recommendation.\n\n    Example:\n        >>> extractor = ContextExtractor()\n        >>> context = extractor.extract_from_files([Path("src/components/Button.tsx")])\n        >>> "react" in context\n        True\n        >>> "typescript" in context\n        True\n    """\n\n    # File extension → keyword mapping\n    FILE_TYPE_KEYWORDS = {\n        # Frontend\n        ".tsx": ["react", "typescript", "frontend", "component"],\n        ".jsx": ["react", "javascript", "frontend", "component"],\n        ".ts": ["typescript", "javascript"],\n        ".js": ["javascript"],\n        ".vue": ["vue", "frontend", "component"],\n        ".svelte": ["svelte", "frontend", "component"],\n        ".css": ["css", "styling", "frontend"],\n        ".scss": ["sass", "css", "styling", "frontend"],\n        ".html": ["html", "frontend", "markup"],\n\n        # Backend\n        ".py": ["python", "backend"],\n        ".go": ["golang", "backend"],\n        ".rs": ["rust", "backend"],\n        ".java": ["java", "backend"],\n        ".rb": ["ruby", "backend"],\n        ".php": ["php", "backend"],\n\n        # Infrastructure\n        ".yaml": ["yaml", "config", "infrastructure"],\n        ".yml": ["yaml", "config", "infrastructure"],\n        ".toml": ["toml", "config"],\n        ".json": ["json", "config"],\n        ".dockerfile": ["docker", "container", "infrastructure"],\n        "Dockerfile": ["docker", "container", "infrastructure"],\n        "docker-compose.yml": ["docker", "compose", "infrastructure"],\n\n        # Data\n        ".sql": ["sql", "database", "data"],\n        ".graphql": ["graphql", "api", "data"],\n        ".proto": ["protobuf", "grpc", "api"],\n\n        # ML/AI\n        ".ipynb": ["jupyter", "python", "data-science", "ml"],\n        ".pkl": ["python", "ml", "model"],\n        ".h5": ["keras", "tensorflow", "ml"],\n        ".pt": ["pytorch", "ml"],\n\n        # Documentation\n        ".md": ["documentation", "markdown"],\n        ".rst": ["documentation", "restructuredtext"],\n        ".tex": ["latex", "documentation"],\n\n        # Testing\n        "test_*.py": ["testing", "pytest", "python"],\n        "*_test.go": ["testing", "golang"],\n        "*.test.ts": ["testing", "typescript", "jest"],\n        "*.spec.ts": ["testing", "typescript", "jest"],\n    }\n\n    # Directory name → keyword mapping\n    DIR_KEYWORDS = {\n        "src": ["source", "code"],\n        "tests": ["testing", "quality"],\n        "docs": ["documentation"],\n        "frontend": ["frontend", "ui"],\n        "backend": ["backend", "api"],\n        "api": ["api", "backend"],\n        "components": ["react", "vue", "component", "frontend"],\n        "services": ["backend", "service"],\n        "models": ["data", "database", "ml"],\n        "utils": ["utility", "helper"],\n        "config": ["configuration", "settings"],\n        "scripts": ["automation", "tooling"],\n        "infra": ["infrastructure", "devops"],\n        "infrastructure": ["infrastructure", "devops"],\n        ".github": ["ci-cd", "github", "automation"],\n        ".gitlab": ["ci-cd", "gitlab", "automation"],\n    }\n\n    def extract_from_files(self, file_paths: list[Path]) -> str:\n        """Extract keywords from open files.\n\n        Analyzes file extensions and directory names to infer context.\n\n        Args:\n            file_paths: List of file paths to analyze\n\n        Returns:\n            Space-separated keyword string\n\n        Example:\n            >>> extractor = ContextExtractor()\n            >>> context = extractor.extract_from_files([\n            ...     Path("src/components/Button.tsx"),\n            ...     Path("tests/unit/test_button.py")\n            ... ])\n            >>> "react" in context and "testing" in context\n            True\n        """\n        keywords = set()\n\n        for path in file_paths:\n            # Extract from file extension\n            suffix = path.suffix.lower()\n            if suffix in self.FILE_TYPE_KEYWORDS:\n                keywords.update(self.FILE_TYPE_KEYWORDS[suffix])\n\n            # Special case: full filename patterns\n            filename = path.name\n            if filename.startswith("test_") or filename.endswith("_test.py"):\n                keywords.update(["testing", "pytest", "python"])\n            if filename == "Dockerfile":\n                keywords.update(["docker", "container", "infrastructure"])\n\n            # Extract from directory names\n            for part in path.parts:\n                part_lower = part.lower()\n                if part_lower in self.DIR_KEYWORDS:\n                    keywords.update(self.DIR_KEYWORDS[part_lower])\n\n        return " ".join(keywords)\n\n    def extract_from_git(self) -> str:\n        """Extract context from git branch and recent commits.\n\n        Parses branch name and commit messages for semantic keywords.\n\n        Returns:\n            Space-separated keyword string\n\n        Example:\n            >>> extractor = ContextExtractor()\n            >>> context = extractor.extract_from_git()\n            >>> len(context) > 0  # May be empty if not in git repo\n            True\n        """\n        keywords = set()\n\n        try:\n            # Get current branch name\n            branch = subprocess.check_output(\n                ["git", "branch", "--show-current"],\n                stderr=subprocess.DEVNULL\n            ).decode().strip()\n\n            # Parse branch name (e.g., feat/api-redesign → api, redesign)\n            branch_keywords = re.findall(r\'[a-z]+\', branch.lower())\n            keywords.update(branch_keywords)\n\n            # Get recent commit messages (last 5)\n            commits = subprocess.check_output(\n                ["git", "log", "--oneline", "-5"],\n                stderr=subprocess.DEVNULL\n            ).decode().strip().split(\'\\n\')\n\n            for commit in commits:\n                # Extract words from commit message\n                commit_words = re.findall(r\'[a-z]{3,}\', commit.lower())\n                keywords.update(commit_words)\n\n        except (subprocess.CalledProcessError, FileNotFoundError):\n            # Not a git repo or git not available\n            pass\n\n        return " ".join(keywords)\n\n    def extract_from_query(self, query: str) -> str:\n        """Extract keywords from user query using NLP.\n\n        Uses simple word extraction for now. Can be enhanced with spaCy\n        for entity recognition and keyword extraction.\n\n        Args:\n            query: User\'s natural language query\n\n        Returns:\n            Space-separated keyword string\n\n        Example:\n            >>> extractor = ContextExtractor()\n            >>> context = extractor.extract_from_query("help with react components")\n            >>> "react" in context and "components" in context\n            True\n        """\n        # Simple approach: extract alphanumeric words\n        keywords = re.findall(r\'\\b[a-z]{3,}\\b\', query.lower())\n\n        # TODO: Enhance with spaCy for:\n        # - Named entity recognition\n        # - Keyword extraction (RAKE, TF-IDF)\n        # - Synonym expansion\n\n        return " ".join(keywords)\n\n    def extract_full_context(\n        self,\n        query: str | None = None,\n        file_paths: list[Path] | None = None,\n        include_git: bool = True\n    ) -> str:\n        """Extract comprehensive context from all sources.\n\n        Combines query, file, and git context into single keyword string.\n\n        Args:\n            query: Optional user query\n            file_paths: Optional file paths\n            include_git: Whether to include git context\n\n        Returns:\n            Combined keyword string\n\n        Example:\n            >>> extractor = ContextExtractor()\n            >>> context = extractor.extract_full_context(\n            ...     query="optimize database queries",\n            ...     file_paths=[Path("src/models/user.py")]\n            ... )\n            >>> "database" in context and "python" in context\n            True\n        """\n        all_keywords = []\n\n        if query:\n            all_keywords.append(self.extract_from_query(query))\n\n        if file_paths:\n            all_keywords.append(self.extract_from_files(file_paths))\n\n        if include_git:\n            all_keywords.append(self.extract_from_git())\n\n        # Combine and deduplicate\n        combined = " ".join(all_keywords)\n        unique_keywords = list(dict.fromkeys(combined.split()))  # Preserve order\n\n        return " ".join(unique_keywords)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_backlog_OPTION_C_SMART_AGENT_SUGGESTIONS_2():
    """Test code snippet from projects/backlog/OPTION_C_SMART_AGENT_SUGGESTIONS.md (line 383)."""
    code = '"""TF-IDF based agent recommendation engine.\n\nUses scikit-learn TF-IDF vectorization and cosine similarity to rank\nagents by relevance to user context. Includes Redis caching for fast\nrepeated queries.\n\nAuthor: @claude-code-developer + @ml-engineer\nDate: 2025-10-18\n"""\n\nfrom pathlib import Path\nfrom typing import Any\nimport pickle\nimport hashlib\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.metrics.pairwise import cosine_similarity\nimport numpy as np\n\nfrom scripts.agent_discovery import AgentDiscovery\n\n\nclass AgentRecommender:\n    """Recommends agents based on TF-IDF similarity.\n\n    Pre-computes TF-IDF vectors for all agent descriptions, then scores\n    context queries against the corpus using cosine similarity.\n\n    Attributes:\n        discovery: AgentDiscovery instance\n        vectorizer: TfidfVectorizer for text vectorization\n        agent_vectors: Pre-computed agent TF-IDF vectors\n        agent_ids: Ordered list of agent IDs\n\n    Example:\n        >>> discovery = AgentDiscovery(Path("plugins/mycelium-core/agents/index.json"))\n        >>> recommender = AgentRecommender(discovery)\n        >>> suggestions = recommender.suggest("react typescript frontend", top_k=5)\n        >>> len(suggestions) == 5\n        True\n        >>> suggestions[0][1] > suggestions[-1][1]  # Scores descending\n        True\n    """\n\n    def __init__(\n        self,\n        discovery: AgentDiscovery,\n        cache_ttl_seconds: int = 300,  # 5 minutes\n        use_redis: bool = True\n    ):\n        """Initialize recommender with agent discovery.\n\n        Args:\n            discovery: AgentDiscovery instance\n            cache_ttl_seconds: Cache TTL for recommendations\n            use_redis: Whether to use Redis for caching\n\n        Example:\n            >>> discovery = AgentDiscovery(Path("plugins/mycelium-core/agents/index.json"))\n            >>> recommender = AgentRecommender(discovery)\n            >>> recommender.agent_ids is not None\n            True\n        """\n        self.discovery = discovery\n        self.cache_ttl = cache_ttl_seconds\n        self.use_redis = use_redis\n\n        # Initialize TF-IDF vectorizer\n        self.vectorizer = TfidfVectorizer(\n            max_features=500,  # Limit vocabulary size\n            ngram_range=(1, 2),  # Unigrams and bigrams\n            stop_words=\'english\',\n            lowercase=True,\n        )\n\n        # Build corpus and vectorize\n        self._build_corpus()\n\n        # Initialize Redis client if available\n        self.redis_client = None\n        if use_redis:\n            try:\n                import redis\n                self.redis_client = redis.Redis(\n                    host=\'localhost\',\n                    port=6379,\n                    decode_responses=False  # Binary for pickle\n                )\n            except Exception:\n                # Redis unavailable - continue without cache\n                pass\n\n    def _build_corpus(self) -> None:\n        """Build TF-IDF corpus from agent descriptions.\n\n        Loads all agent metadata and vectorizes descriptions + keywords\n        into TF-IDF feature vectors.\n        """\n        agents = self.discovery.list_agents()\n\n        # Build corpus: description + keywords\n        self.corpus = []\n        self.agent_ids = []\n        self.agent_metadata = []\n\n        for agent in agents:\n            # Combine description and keywords for richer matching\n            description = agent.get(\'description\', \'\')\n            keywords = \' \'.join(agent.get(\'keywords\', []))\n            category = agent.get(\'category\', \'\')\n\n            combined = f"{description} {keywords} {category}"\n            self.corpus.append(combined)\n            self.agent_ids.append(agent[\'id\'])\n            self.agent_metadata.append(agent)\n\n        # Vectorize corpus\n        self.agent_vectors = self.vectorizer.fit_transform(self.corpus)\n\n    def suggest(\n        self,\n        context: str,\n        top_k: int = 5,\n        min_similarity: float = 0.1,\n        exclude_agents: list[str] | None = None,\n        usage_boost: bool = False\n    ) -> list[tuple[str, float, dict[str, Any]]]:\n        """Suggest top-k agents based on context.\n\n        Args:\n            context: Context string (keywords from ContextExtractor)\n            top_k: Number of suggestions to return\n            min_similarity: Minimum similarity threshold (0-1)\n            exclude_agents: Optional list of agent IDs to exclude\n            usage_boost: Boost scores using usage analytics (requires Option A)\n\n        Returns:\n            List of (agent_id, similarity_score, metadata) tuples:\n            [\n                ("react-tanstack-developer", 0.92, {...}),\n                ("nextjs-developer", 0.85, {...}),\n                ...\n            ]\n\n        Example:\n            >>> recommender = AgentRecommender(discovery)\n            >>> suggestions = recommender.suggest("python testing pytest", top_k=3)\n            >>> len(suggestions) <= 3\n            True\n            >>> all(0 <= score <= 1 for _, score, _ in suggestions)\n            True\n        """\n        # Check cache first\n        cache_key = self._get_cache_key(context, top_k, exclude_agents)\n        cached = self._get_from_cache(cache_key)\n        if cached is not None:\n            return cached\n\n        # Vectorize context query\n        context_vector = self.vectorizer.transform([context])\n\n        # Compute cosine similarity\n        similarities = cosine_similarity(context_vector, self.agent_vectors)[0]\n\n        # Create (agent_id, score, metadata) tuples\n        scored_agents = [\n            (self.agent_ids[i], similarities[i], self.agent_metadata[i])\n            for i in range(len(self.agent_ids))\n        ]\n\n        # Filter by minimum similarity\n        scored_agents = [\n            (aid, score, meta)\n            for aid, score, meta in scored_agents\n            if score >= min_similarity\n        ]\n\n        # Exclude agents\n        if exclude_agents:\n            scored_agents = [\n                (aid, score, meta)\n                for aid, score, meta in scored_agents\n                if aid not in exclude_agents\n            ]\n\n        # Apply usage boost (if Option A available)\n        if usage_boost:\n            scored_agents = self._apply_usage_boost(scored_agents)\n\n        # Sort by score (descending)\n        scored_agents.sort(key=lambda x: x[1], reverse=True)\n\n        # Take top-k\n        suggestions = scored_agents[:top_k]\n\n        # Cache results\n        self._put_in_cache(cache_key, suggestions)\n\n        return suggestions\n\n    def suggest_by_category(\n        self,\n        context: str,\n        category: str,\n        top_k: int = 3\n    ) -> list[tuple[str, float, dict[str, Any]]]:\n        """Suggest agents within specific category.\n\n        Args:\n            context: Context string\n            category: Agent category to filter\n            top_k: Number of suggestions\n\n        Returns:\n            List of (agent_id, score, metadata) tuples\n\n        Example:\n            >>> recommender = AgentRecommender(discovery)\n            >>> suggestions = recommender.suggest_by_category(\n            ...     "api design",\n            ...     category="core-development",\n            ...     top_k=3\n            ... )\n            >>> all(s[2][\'category\'] == \'core-development\' for s in suggestions)\n            True\n        """\n        # Get all suggestions\n        all_suggestions = self.suggest(context, top_k=100, min_similarity=0.0)\n\n        # Filter by category\n        category_suggestions = [\n            (aid, score, meta)\n            for aid, score, meta in all_suggestions\n            if meta.get(\'category\') == category\n        ]\n\n        return category_suggestions[:top_k]\n\n    def explain_suggestion(\n        self,\n        agent_id: str,\n        context: str\n    ) -> dict[str, Any]:\n        """Explain why agent was suggested.\n\n        Returns feature weights and matched keywords.\n\n        Args:\n            agent_id: Agent ID to explain\n            context: Context used for recommendation\n\n        Returns:\n            Explanation dictionary:\n            {\n                "agent_id": "react-tanstack-developer",\n                "similarity_score": 0.92,\n                "matched_keywords": ["react", "typescript", "frontend"],\n                "top_features": [("react", 0.45), ("frontend", 0.32), ...],\n            }\n\n        Example:\n            >>> recommender = AgentRecommender(discovery)\n            >>> explanation = recommender.explain_suggestion(\n            ...     "react-tanstack-developer",\n            ...     "react typescript"\n            ... )\n            >>> "matched_keywords" in explanation\n            True\n        """\n        # Get agent index\n        try:\n            agent_idx = self.agent_ids.index(agent_id)\n        except ValueError:\n            return {"error": f"Agent not found: {agent_id}"}\n\n        # Vectorize context\n        context_vector = self.vectorizer.transform([context])\n        agent_vector = self.agent_vectors[agent_idx]\n\n        # Compute similarity\n        similarity = cosine_similarity(context_vector, agent_vector)[0][0]\n\n        # Get feature names and weights\n        feature_names = self.vectorizer.get_feature_names_out()\n        context_features = context_vector.toarray()[0]\n        agent_features = agent_vector.toarray()[0]\n\n        # Find matched features (both context and agent have non-zero weight)\n        matched_features = [\n            (feature_names[i], context_features[i] * agent_features[i])\n            for i in range(len(feature_names))\n            if context_features[i] > 0 and agent_features[i] > 0\n        ]\n\n        # Sort by weight (descending)\n        matched_features.sort(key=lambda x: x[1], reverse=True)\n\n        # Extract matched keywords\n        matched_keywords = [kw for kw, _ in matched_features[:10]]\n\n        return {\n            "agent_id": agent_id,\n            "similarity_score": round(similarity, 4),\n            "matched_keywords": matched_keywords,\n            "top_features": [(kw, round(weight, 4)) for kw, weight in matched_features[:5]],\n        }\n\n    def _apply_usage_boost(\n        self,\n        scored_agents: list[tuple[str, float, dict]]\n    ) -> list[tuple[str, float, dict]]:\n        """Boost scores based on usage popularity (requires Option A).\n\n        Args:\n            scored_agents: List of (agent_id, score, metadata)\n\n        Returns:\n            Boosted list of (agent_id, adjusted_score, metadata)\n        """\n        try:\n            from mycelium_analytics import EventStorage\n            from mycelium_analytics.metrics import UsageAnalyzer\n\n            storage = EventStorage()\n            usage_analyzer = UsageAnalyzer(storage)\n            ranking = usage_analyzer.get_popularity_ranking(days=30)\n\n            # Create usage score map (percentile)\n            usage_scores = {}\n            for i, agent_data in enumerate(ranking):\n                percentile = (len(ranking) - i) / len(ranking)\n                usage_scores[agent_data[\'agent_id_hash\']] = percentile\n\n            # Apply boost (multiply similarity by usage percentile)\n            boosted = []\n            for agent_id, score, meta in scored_agents:\n                # Hash agent_id to match analytics\n                agent_hash = hashlib.sha256(agent_id.encode()).hexdigest()[:8]\n                usage_percentile = usage_scores.get(agent_hash, 0.5)  # Default: median\n\n                # Boost formula: score * (1 + 0.2 * usage_percentile)\n                # Top agents get +20% boost, bottom agents get 0% boost\n                boosted_score = score * (1 + 0.2 * usage_percentile)\n                boosted.append((agent_id, boosted_score, meta))\n\n            return boosted\n\n        except Exception:\n            # Usage analytics unavailable - return original scores\n            return scored_agents\n\n    def _get_cache_key(\n        self,\n        context: str,\n        top_k: int,\n        exclude_agents: list[str] | None\n    ) -> str:\n        """Generate cache key for recommendation request."""\n        exclude_str = ",".join(sorted(exclude_agents)) if exclude_agents else ""\n        key_input = f"{context}|{top_k}|{exclude_str}"\n        return hashlib.sha256(key_input.encode()).hexdigest()\n\n    def _get_from_cache(self, cache_key: str) -> list | None:\n        """Retrieve recommendations from Redis cache."""\n        if self.redis_client is None:\n            return None\n\n        try:\n            cached_data = self.redis_client.get(f"mycelium:rec:{cache_key}")\n            if cached_data:\n                return pickle.loads(cached_data)\n        except Exception:\n            pass\n\n        return None\n\n    def _put_in_cache(self, cache_key: str, suggestions: list) -> None:\n        """Store recommendations in Redis cache."""\n        if self.redis_client is None:\n            return\n\n        try:\n            serialized = pickle.dumps(suggestions)\n            self.redis_client.setex(\n                f"mycelium:rec:{cache_key}",\n                self.cache_ttl,\n                serialized\n            )\n        except Exception:\n            pass  # Cache write failure - not critical'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_backlog_OPTION_C_SMART_AGENT_SUGGESTIONS_3():
    """Test code snippet from projects/backlog/OPTION_C_SMART_AGENT_SUGGESTIONS.md (line 781)."""
    code = '#!/usr/bin/env python3\n"""CLI tool for smart agent suggestions.\n\nUsage:\n    # Auto-detect context from working directory\n    mycelium suggest\n\n    # Manual query\n    mycelium suggest "help with react components"\n\n    # Suggest within category\n    mycelium suggest "api design" --category core-development\n\n    # Explain why agent was suggested\n    mycelium suggest --explain react-tanstack-developer --query "react frontend"\n\nAuthor: @claude-code-developer\nDate: 2025-10-18\n"""\n\nimport argparse\nimport subprocess\nfrom pathlib import Path\nfrom mycelium_recommender.context_extractor import ContextExtractor\nfrom mycelium_recommender.recommender import AgentRecommender\nfrom scripts.agent_discovery import AgentDiscovery\n\n\ndef auto_detect_files() -> list[Path]:\n    """Auto-detect recently modified files in working directory.\n\n    Returns:\n        List of recently modified file paths (last 10)\n    """\n    try:\n        # Get recently modified files (git-aware)\n        result = subprocess.check_output(\n            ["git", "diff", "--name-only", "HEAD"],\n            stderr=subprocess.DEVNULL\n        ).decode().strip()\n\n        if result:\n            return [Path(p) for p in result.split(\'\\n\')[:10]]\n        else:\n            # Fallback: list files in current directory\n            return list(Path.cwd().rglob("*.py"))[:10]\n    except (subprocess.CalledProcessError, FileNotFoundError):\n        # Not a git repo - use current directory\n        return list(Path.cwd().rglob("*.*"))[:10]\n\n\ndef cmd_suggest(args):\n    """Suggest agents based on context."""\n    # Initialize components\n    index_path = Path("plugins/mycelium-core/agents/index.json")\n    discovery = AgentDiscovery(index_path)\n    recommender = AgentRecommender(discovery, use_redis=True)\n    extractor = ContextExtractor()\n\n    # Extract context\n    if args.query:\n        # Manual query\n        context = extractor.extract_from_query(args.query)\n    else:\n        # Auto-detect from environment\n        file_paths = auto_detect_files()\n        context = extractor.extract_full_context(\n            file_paths=file_paths,\n            include_git=True\n        )\n\n    print(f"\\n=== Agent Suggestions ===\\n")\n    print(f"Context: {context}\\n")\n\n    # Get suggestions\n    if args.category:\n        suggestions = recommender.suggest_by_category(\n            context,\n            category=args.category,\n            top_k=args.top_k\n        )\n    else:\n        suggestions = recommender.suggest(\n            context,\n            top_k=args.top_k,\n            usage_boost=args.use_analytics\n        )\n\n    if not suggestions:\n        print("No suggestions found. Try a different query or context.")\n        return\n\n    # Display suggestions\n    for i, (agent_id, score, metadata) in enumerate(suggestions, 1):\n        percentage = int(score * 100)\n        print(f"{i}. {agent_id}")\n        print(f"   Match: {percentage}%")\n        print(f"   Category: {metadata.get(\'category\', \'unknown\')}")\n        print(f"   Description: {metadata.get(\'description\', \'\')[:80]}...")\n        print()\n\n    # Show how to invoke\n    top_agent = suggestions[0][0]\n    print(f"To use top suggestion: claude --agents {top_agent}")\n\n\ndef cmd_explain(args):\n    """Explain why agent was suggested."""\n    index_path = Path("plugins/mycelium-core/agents/index.json")\n    discovery = AgentDiscovery(index_path)\n    recommender = AgentRecommender(discovery)\n    extractor = ContextExtractor()\n\n    # Extract context\n    context = extractor.extract_from_query(args.query)\n\n    # Get explanation\n    explanation = recommender.explain_suggestion(args.agent_id, context)\n\n    print(f"\\n=== Explanation: {args.agent_id} ===\\n")\n    print(f"Similarity Score: {explanation[\'similarity_score\']:.2%}")\n    print(f"\\nMatched Keywords:")\n    for keyword in explanation[\'matched_keywords\']:\n        print(f"  - {keyword}")\n    print(f"\\nTop Features:")\n    for feature, weight in explanation[\'top_features\']:\n        print(f"  - {feature}: {weight:.4f}")\n\n\ndef main():\n    parser = argparse.ArgumentParser(description="Smart agent suggestions")\n    subparsers = parser.add_subparsers(dest="command", help="Command to run")\n\n    # Suggest command\n    suggest_parser = subparsers.add_parser("suggest", help="Suggest agents")\n    suggest_parser.add_argument("query", nargs="?", help="Optional query (auto-detect if omitted)")\n    suggest_parser.add_argument("--category", help="Filter by category")\n    suggest_parser.add_argument("--top-k", type=int, default=5, help="Number of suggestions")\n    suggest_parser.add_argument("--use-analytics", action="store_true", help="Boost with usage data")\n\n    # Explain command\n    explain_parser = subparsers.add_parser("explain", help="Explain suggestion")\n    explain_parser.add_argument("--agent-id", required=True, help="Agent ID to explain")\n    explain_parser.add_argument("--query", required=True, help="Query context")\n\n    args = parser.parse_args()\n\n    if args.command == "suggest" or args.command is None:\n        # Default to suggest if no command\n        if not hasattr(args, \'query\'):\n            args.query = None\n            args.category = None\n            args.top_k = 5\n            args.use_analytics = False\n        cmd_suggest(args)\n    elif args.command == "explain":\n        cmd_explain(args)\n    else:\n        parser.print_help()\n\n\nif __name__ == "__main__":\n    main()'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_backlog_OPTION_C_SMART_AGENT_SUGGESTIONS_4():
    """Test code snippet from projects/backlog/OPTION_C_SMART_AGENT_SUGGESTIONS.md (line 953)."""
    code = '"""Unit tests for recommendation system."""\n\nimport pytest\nfrom pathlib import Path\nfrom mycelium_recommender.context_extractor import ContextExtractor\nfrom mycelium_recommender.recommender import AgentRecommender\nfrom scripts.agent_discovery import AgentDiscovery\n\n\ndef test_context_extraction_from_files():\n    """Test file context extraction."""\n    extractor = ContextExtractor()\n    context = extractor.extract_from_files([\n        Path("src/components/Button.tsx"),\n        Path("tests/test_api.py")\n    ])\n\n    assert "react" in context\n    assert "typescript" in context\n    assert "testing" in context\n\n\ndef test_recommendation_ranking():\n    """Test recommendation ranking."""\n    index_path = Path("plugins/mycelium-core/agents/index.json")\n    discovery = AgentDiscovery(index_path)\n    recommender = AgentRecommender(discovery)\n\n    suggestions = recommender.suggest("react typescript frontend", top_k=5)\n\n    assert len(suggestions) <= 5\n    assert all(0 <= score <= 1 for _, score, _ in suggestions)\n    # Scores should be descending\n    assert suggestions[0][1] >= suggestions[-1][1]\n\n\ndef test_category_filtering():\n    """Test category-specific suggestions."""\n    index_path = Path("plugins/mycelium-core/agents/index.json")\n    discovery = AgentDiscovery(index_path)\n    recommender = AgentRecommender(discovery)\n\n    suggestions = recommender.suggest_by_category(\n        "api design",\n        category="core-development",\n        top_k=3\n    )\n\n    assert all(meta[\'category\'] == \'core-development\' for _, _, meta in suggestions)\n\n\ndef test_cache_hit():\n    """Test Redis caching."""\n    index_path = Path("plugins/mycelium-core/agents/index.json")\n    discovery = AgentDiscovery(index_path)\n    recommender = AgentRecommender(discovery, use_redis=True)\n\n    # First call (cache miss)\n    suggestions1 = recommender.suggest("python testing", top_k=3)\n\n    # Second call (cache hit)\n    suggestions2 = recommender.suggest("python testing", top_k=3)\n\n    assert suggestions1 == suggestions2\n\n\ndef test_min_similarity_threshold():\n    """Test minimum similarity filtering."""\n    index_path = Path("plugins/mycelium-core/agents/index.json")\n    discovery = AgentDiscovery(index_path)\n    recommender = AgentRecommender(discovery)\n\n    # Very specific query - should have few high-similarity matches\n    suggestions = recommender.suggest(\n        "obscure niche technology xyz123",\n        min_similarity=0.5,\n        top_k=10\n    )\n\n    assert all(score >= 0.5 for _, score, _ in suggestions)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_backlog_OPTION_D_MULTI_AGENT_ORCHESTRATION_UI_1():
    """Test code snippet from projects/backlog/OPTION_D_MULTI_AGENT_ORCHESTRATION_UI.md (line 265)."""
    code = 'from fastapi import FastAPI, HTTPException, WebSocket\nfrom pydantic import BaseModel, Field\nfrom typing import List, Dict, Any, Optional\nfrom datetime import datetime\nimport uuid\n\napp = FastAPI(title="Mycelium Orchestration API", version="1.0.0")\n\n\n# ============================================================================\n# Data Models (Pydantic)\n# ============================================================================\n\nclass AgentNode(BaseModel):\n    """Agent node in workflow DAG."""\n    id: str = Field(..., description="Unique node ID")\n    agent_type: str = Field(..., description="Agent ID (e.g., \'python-pro\')")\n    position: tuple[int, int] = Field(..., description="(x, y) position in canvas")\n    config: Dict[str, Any] = Field(default_factory=dict, description="Node-specific config")\n\n\nclass WorkflowEdge(BaseModel):\n    """Edge connecting two nodes."""\n    source: str = Field(..., description="Source node ID")\n    target: str = Field(..., description="Target node ID")\n    condition: Optional[str] = Field(None, description="Conditional edge (e.g., \'on_success\')")\n\n\nclass WorkflowCreate(BaseModel):\n    """Create workflow request."""\n    name: str\n    description: Optional[str] = None\n    nodes: List[AgentNode]\n    edges: List[WorkflowEdge]\n    tags: List[str] = Field(default_factory=list)\n    category: Optional[str] = None\n\n\nclass WorkflowResponse(BaseModel):\n    """Workflow response."""\n    id: uuid.UUID\n    name: str\n    description: Optional[str]\n    nodes: List[AgentNode]\n    edges: List[WorkflowEdge]\n    created_at: datetime\n    updated_at: datetime\n    is_template: bool\n\n\nclass ExecutionCreate(BaseModel):\n    """Execute workflow request."""\n    input_params: Dict[str, Any] = Field(default_factory=dict)\n    trigger: str = "manual"\n\n\nclass ExecutionResponse(BaseModel):\n    """Execution response."""\n    id: uuid.UUID\n    workflow_id: uuid.UUID\n    status: str\n    started_at: Optional[datetime]\n    completed_at: Optional[datetime]\n    duration_seconds: Optional[float]\n    node_statuses: Dict[str, str]\n    error_message: Optional[str]\n\n\n# ============================================================================\n# Endpoints\n# ============================================================================\n\n@app.get("/api/agents", response_model=List[Dict[str, Any]])\nasync def list_agents():\n    """List all available agents from discovery system.\n\n    Returns:\n        List of agent metadata dictionaries\n\n    Example:\n        GET /api/agents\n\n        Response:\n        [\n            {\n                "id": "python-pro",\n                "name": "Python Pro",\n                "category": "core-development",\n                "description": "Senior Python developer...",\n                "keywords": ["python", "backend", "testing"]\n            },\n            ...\n        ]\n    """\n    from scripts.agent_discovery import AgentDiscovery\n    from pathlib import Path\n\n    discovery = AgentDiscovery(Path("plugins/mycelium-core/agents/index.json"))\n    agents = discovery.list_agents()\n\n    return agents\n\n\n@app.get("/api/workflows", response_model=List[WorkflowResponse])\nasync def list_workflows(\n    category: Optional[str] = None,\n    is_template: Optional[bool] = None,\n    limit: int = 50\n):\n    """List workflows with optional filtering.\n\n    Args:\n        category: Filter by category\n        is_template: Filter templates (True) or user workflows (False)\n        limit: Maximum number of results\n\n    Returns:\n        List of workflow objects\n\n    Example:\n        GET /api/workflows?category=ci-cd&limit=10\n    """\n    # TODO: Implement database query\n    # For now, return empty list\n    return []\n\n\n@app.post("/api/workflows", response_model=WorkflowResponse, status_code=201)\nasync def create_workflow(workflow: WorkflowCreate):\n    """Create new workflow.\n\n    Args:\n        workflow: Workflow definition\n\n    Returns:\n        Created workflow object\n\n    Example:\n        POST /api/workflows\n\n        Body:\n        {\n            "name": "Python Code Review",\n            "description": "Automated code review workflow",\n            "nodes": [\n                {"id": "node-1", "agent_type": "python-pro", "position": [100, 100]},\n                {"id": "node-2", "agent_type": "devops-engineer", "position": [300, 100]}\n            ],\n            "edges": [\n                {"source": "node-1", "target": "node-2"}\n            ],\n            "tags": ["python", "code-review"],\n            "category": "quality"\n        }\n    """\n    # TODO: Implement database insert\n    # Validate DAG (no cycles)\n    # Store in PostgreSQL\n    raise HTTPException(status_code=501, detail="Not implemented")\n\n\n@app.get("/api/workflows/{workflow_id}", response_model=WorkflowResponse)\nasync def get_workflow(workflow_id: uuid.UUID):\n    """Get workflow by ID.\n\n    Args:\n        workflow_id: Workflow UUID\n\n    Returns:\n        Workflow object\n\n    Example:\n        GET /api/workflows/123e4567-e89b-12d3-a456-426614174000\n    """\n    # TODO: Implement database query\n    raise HTTPException(status_code=404, detail="Workflow not found")\n\n\n@app.put("/api/workflows/{workflow_id}", response_model=WorkflowResponse)\nasync def update_workflow(workflow_id: uuid.UUID, workflow: WorkflowCreate):\n    """Update existing workflow.\n\n    Args:\n        workflow_id: Workflow UUID\n        workflow: Updated workflow definition\n\n    Returns:\n        Updated workflow object\n    """\n    # TODO: Implement database update\n    raise HTTPException(status_code=501, detail="Not implemented")\n\n\n@app.delete("/api/workflows/{workflow_id}", status_code=204)\nasync def delete_workflow(workflow_id: uuid.UUID):\n    """Delete workflow.\n\n    Args:\n        workflow_id: Workflow UUID\n\n    Example:\n        DELETE /api/workflows/123e4567-e89b-12d3-a456-426614174000\n    """\n    # TODO: Implement database delete\n    # Check if workflow has running executions\n    raise HTTPException(status_code=501, detail="Not implemented")\n\n\n@app.post("/api/workflows/{workflow_id}/execute", response_model=ExecutionResponse)\nasync def execute_workflow(workflow_id: uuid.UUID, execution: ExecutionCreate):\n    """Execute workflow asynchronously.\n\n    Creates execution record and enqueues Celery task for async execution.\n    Client should connect to WebSocket for real-time updates.\n\n    Args:\n        workflow_id: Workflow UUID\n        execution: Execution parameters\n\n    Returns:\n        Execution object with status "pending"\n\n    Example:\n        POST /api/workflows/123e4567-e89b-12d3-a456-426614174000/execute\n\n        Body:\n        {\n            "input_params": {"branch": "main", "run_tests": true},\n            "trigger": "manual"\n        }\n\n        Response:\n        {\n            "id": "exec-456...",\n            "workflow_id": "123e4567-...",\n            "status": "pending",\n            "started_at": null,\n            "node_statuses": {}\n        }\n    """\n    # TODO: Implement workflow execution\n    # 1. Validate workflow exists\n    # 2. Create execution record in PostgreSQL\n    # 3. Enqueue Celery task: execute_workflow.delay(execution_id)\n    # 4. Return execution object\n    raise HTTPException(status_code=501, detail="Not implemented")\n\n\n@app.get("/api/workflows/{workflow_id}/executions", response_model=List[ExecutionResponse])\nasync def list_executions(\n    workflow_id: uuid.UUID,\n    status: Optional[str] = None,\n    limit: int = 50\n):\n    """List executions for workflow.\n\n    Args:\n        workflow_id: Workflow UUID\n        status: Filter by status (pending, running, completed, failed, cancelled)\n        limit: Maximum number of results\n\n    Returns:\n        List of execution objects\n\n    Example:\n        GET /api/workflows/123e4567-e89b-12d3-a456-426614174000/executions?status=completed\n    """\n    # TODO: Implement database query\n    return []\n\n\n@app.get("/api/executions/{execution_id}", response_model=ExecutionResponse)\nasync def get_execution(execution_id: uuid.UUID):\n    """Get execution details.\n\n    Args:\n        execution_id: Execution UUID\n\n    Returns:\n        Execution object with node statuses and logs\n    """\n    # TODO: Implement database query\n    raise HTTPException(status_code=404, detail="Execution not found")\n\n\n@app.post("/api/executions/{execution_id}/cancel", status_code=204)\nasync def cancel_execution(execution_id: uuid.UUID):\n    """Cancel running execution.\n\n    Args:\n        execution_id: Execution UUID\n\n    Example:\n        POST /api/executions/exec-456.../cancel\n    """\n    # TODO: Implement cancellation\n    # 1. Update execution status to "cancelled"\n    # 2. Revoke Celery task\n    # 3. Publish cancellation event via Redis Pub/Sub\n    raise HTTPException(status_code=501, detail="Not implemented")\n\n\n@app.get("/api/executions/{execution_id}/logs")\nasync def get_execution_logs(\n    execution_id: uuid.UUID,\n    node_id: Optional[str] = None,\n    level: Optional[str] = None,\n    limit: int = 1000\n):\n    """Get execution logs.\n\n    Args:\n        execution_id: Execution UUID\n        node_id: Optional node ID filter\n        level: Optional log level filter (debug, info, warning, error)\n        limit: Maximum number of log entries\n\n    Returns:\n        List of log entries\n\n    Example:\n        GET /api/executions/exec-456.../logs?node_id=node-1&level=error\n\n        Response:\n        [\n            {\n                "id": 12345,\n                "node_id": "node-1",\n                "timestamp": "2025-10-19T12:00:00Z",\n                "level": "error",\n                "message": "Agent execution failed: ...",\n                "metadata": {"error_code": "AGENT_TIMEOUT"}\n            },\n            ...\n        ]\n    """\n    # TODO: Implement database query\n    return []\n\n\n@app.get("/api/metrics")\nasync def get_metrics(days: int = 7):\n    """Get orchestration performance metrics.\n\n    Integrates with Phase 2 analytics to provide workflow-level metrics.\n\n    Args:\n        days: Number of days to analyze\n\n    Returns:\n        Metrics dictionary with workflow statistics\n\n    Example:\n        GET /api/metrics?days=30\n\n        Response:\n        {\n            "total_workflows": 42,\n            "total_executions": 256,\n            "success_rate": 94.5,\n            "avg_duration_seconds": 45.2,\n            "top_workflows": [\n                {"name": "Python Code Review", "executions": 82, "success_rate": 98.8},\n                ...\n            ]\n        }\n    """\n    # TODO: Implement analytics query\n    # Combine PostgreSQL execution data with Phase 2 analytics\n    return {}\n\n\n# ============================================================================\n# WebSocket Endpoint\n# ============================================================================\n\n@app.websocket("/ws/workflows/{workflow_id}")\nasync def workflow_websocket(websocket: WebSocket, workflow_id: uuid.UUID):\n    """WebSocket endpoint for real-time workflow updates.\n\n    Clients connect to receive live status updates during execution.\n\n    Protocol:\n        - Client connects to /ws/workflows/{workflow_id}\n        - Server sends status updates as JSON:\n          {\n              "event": "node_status_update",\n              "execution_id": "exec-456...",\n              "node_id": "node-1",\n              "status": "running",\n              "timestamp": "2025-10-19T12:00:00Z"\n          }\n        - Client can send ping to keep connection alive\n\n    Example (JavaScript):\n        const socket = new WebSocket(\'ws://localhost:8000/ws/workflows/123e4567-...\');\n        socket.onmessage = (event) => {\n            const update = JSON.parse(event.data);\n            console.log(\'Node status:\', update);\n        };\n    """\n    await websocket.accept()\n\n    # Subscribe to Redis Pub/Sub for this workflow\n    # Forward messages to WebSocket client\n\n    try:\n        while True:\n            # Keep connection alive\n            # Forward Redis messages to client\n            data = await websocket.receive_text()\n            # Handle client messages (ping, etc.)\n    except Exception as e:\n        print(f"WebSocket error: {e}")\n    finally:\n        # Unsubscribe from Redis Pub/Sub\n        pass'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_backlog_OPTION_D_MULTI_AGENT_ORCHESTRATION_UI_2():
    """Test code snippet from projects/backlog/OPTION_D_MULTI_AGENT_ORCHESTRATION_UI.md (line 986)."""
    code = '# backend/tasks.py\nfrom celery import Celery\nimport subprocess\nimport json\nfrom datetime import datetime\nimport redis\n\ncelery_app = Celery(\n    \'mycelium_orchestrator\',\n    broker=\'redis://localhost:6379/0\',\n    backend=\'redis://localhost:6379/1\'\n)\n\nredis_client = redis.Redis(host=\'localhost\', port=6379, decode_responses=True)\n\n\n@celery_app.task\ndef execute_workflow(execution_id: str):\n    """Execute workflow asynchronously.\n\n    Loads workflow DAG, performs topological sort, and executes nodes\n    in dependency order. Publishes real-time updates via Redis Pub/Sub.\n\n    Args:\n        execution_id: UUID of execution record\n    """\n    # Load execution from database\n    # TODO: Query PostgreSQL for execution + workflow\n\n    # Publish execution started event\n    publish_event({\n        \'event\': \'execution_started\',\n        \'execution_id\': execution_id,\n        \'timestamp\': datetime.utcnow().isoformat(),\n    })\n\n    try:\n        # Topological sort of DAG\n        # TODO: Implement topological sort\n        execution_order = topological_sort(workflow[\'nodes\'], workflow[\'edges\'])\n\n        # Execute nodes in order\n        for node_id in execution_order:\n            execute_node(execution_id, node_id, workflow[\'nodes\'])\n\n        # Mark execution as completed\n        # TODO: Update PostgreSQL execution record\n        publish_event({\n            \'event\': \'execution_completed\',\n            \'execution_id\': execution_id,\n            \'timestamp\': datetime.utcnow().isoformat(),\n        })\n\n    except Exception as e:\n        # Mark execution as failed\n        # TODO: Update PostgreSQL with error\n        publish_event({\n            \'event\': \'execution_failed\',\n            \'execution_id\': execution_id,\n            \'error\': str(e),\n            \'timestamp\': datetime.utcnow().isoformat(),\n        })\n        raise\n\n\ndef execute_node(execution_id: str, node_id: str, nodes: list):\n    """Execute single agent node.\n\n    Args:\n        execution_id: Execution UUID\n        node_id: Node ID to execute\n        nodes: List of all nodes (for config lookup)\n    """\n    node = next(n for n in nodes if n[\'id\'] == node_id)\n    agent_type = node[\'agent_type\']\n\n    # Publish node started event\n    publish_event({\n        \'event\': \'node_status_update\',\n        \'execution_id\': execution_id,\n        \'node_id\': node_id,\n        \'status\': \'running\',\n        \'timestamp\': datetime.utcnow().isoformat(),\n    })\n\n    try:\n        # Invoke Claude Code with agent\n        # TODO: Construct prompt from node config\n        result = subprocess.run(\n            [\'claude\', \'--agents\', agent_type, \'-p\', \'Execute node task\'],\n            capture_output=True,\n            text=True,\n            timeout=300  # 5 minute timeout\n        )\n\n        if result.returncode == 0:\n            # Node succeeded\n            publish_event({\n                \'event\': \'node_status_update\',\n                \'execution_id\': execution_id,\n                \'node_id\': node_id,\n                \'status\': \'completed\',\n                \'output\': result.stdout,\n                \'timestamp\': datetime.utcnow().isoformat(),\n            })\n        else:\n            # Node failed\n            publish_event({\n                \'event\': \'node_status_update\',\n                \'execution_id\': execution_id,\n                \'node_id\': node_id,\n                \'status\': \'failed\',\n                \'error\': result.stderr,\n                \'timestamp\': datetime.utcnow().isoformat(),\n            })\n            raise RuntimeError(f"Node {node_id} failed: {result.stderr}")\n\n    except subprocess.TimeoutExpired:\n        publish_event({\n            \'event\': \'node_status_update\',\n            \'execution_id\': execution_id,\n            \'node_id\': node_id,\n            \'status\': \'failed\',\n            \'error\': \'Execution timeout (5 minutes)\',\n            \'timestamp\': datetime.utcnow().isoformat(),\n        })\n        raise\n    except Exception as e:\n        publish_event({\n            \'event\': \'node_status_update\',\n            \'execution_id\': execution_id,\n            \'node_id\': node_id,\n            \'status\': \'failed\',\n            \'error\': str(e),\n            \'timestamp\': datetime.utcnow().isoformat(),\n        })\n        raise\n\n\ndef publish_event(event: dict):\n    """Publish event to Redis Pub/Sub.\n\n    Args:\n        event: Event dictionary to publish\n    """\n    channel = f"mycelium:events:{event[\'execution_id\']}"\n    redis_client.publish(channel, json.dumps(event))\n\n\ndef topological_sort(nodes: list, edges: list) -> list:\n    """Perform topological sort on DAG.\n\n    Args:\n        nodes: List of node dictionaries\n        edges: List of edge dictionaries\n\n    Returns:\n        Ordered list of node IDs (execution order)\n\n    Raises:\n        ValueError: If DAG contains cycles\n    """\n    # TODO: Implement topological sort (Kahn\'s algorithm)\n    # For now, return nodes in order\n    return [n[\'id\'] for n in nodes]'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_backlog_OPTION_D_MULTI_AGENT_ORCHESTRATION_UI_3():
    """Test code snippet from projects/backlog/OPTION_D_MULTI_AGENT_ORCHESTRATION_UI.md (line 1220)."""
    code = '# tests/test_workflow_api.py\nimport pytest\nfrom fastapi.testclient import TestClient\nfrom backend.main import app\n\nclient = TestClient(app)\n\n\ndef test_list_agents():\n    """Test agent listing endpoint."""\n    response = client.get("/api/agents")\n    assert response.status_code == 200\n    agents = response.json()\n    assert isinstance(agents, list)\n    assert len(agents) > 0\n\n\ndef test_create_workflow():\n    """Test workflow creation."""\n    workflow = {\n        "name": "Test Workflow",\n        "nodes": [\n            {"id": "node-1", "agent_type": "python-pro", "position": [100, 100]}\n        ],\n        "edges": [],\n        "tags": ["test"]\n    }\n    response = client.post("/api/workflows", json=workflow)\n    assert response.status_code == 201\n    created = response.json()\n    assert created["name"] == "Test Workflow"\n\n\ndef test_execute_workflow():\n    """Test workflow execution."""\n    # Create workflow first\n    workflow = {...}  # Workflow definition\n    create_response = client.post("/api/workflows", json=workflow)\n    workflow_id = create_response.json()["id"]\n\n    # Execute workflow\n    execution = {"input_params": {}, "trigger": "manual"}\n    response = client.post(f"/api/workflows/{workflow_id}/execute", json=execution)\n    assert response.status_code == 200\n    execution_data = response.json()\n    assert execution_data["status"] in ["pending", "running"]'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_claude_code_skills_FEEDBACK_INCORPORATION_PLAN_1():
    """Test code snippet from projects/claude-code-skills/FEEDBACK_INCORPORATION_PLAN.md (line 138)."""
    code = '# Text command example\n@click.command()\n@click.argument(\'skill_name\')\ndef install(skill_name: str):\n    """Install a skill from the repository."""\n    loader = SkillLoader()\n    loader.install(skill_name)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_claude_code_skills_FEEDBACK_INCORPORATION_PLAN_2():
    """Test code snippet from projects/claude-code-skills/FEEDBACK_INCORPORATION_PLAN.md (line 148)."""
    code = '# Textual TUI example\nfrom textual.app import App\nfrom textual.widgets import Header, Footer, DataTable\n\nclass MyceliumTUI(App):\n    """Interactive TUI for Mycelium Skills."""\n    def compose(self):\n        yield Header()\n        yield DataTable()  # Skills list\n        yield Footer()'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_claude_code_skills_FEEDBACK_INCORPORATION_PLAN_3():
    """Test code snippet from projects/claude-code-skills/FEEDBACK_INCORPORATION_PLAN.md (line 455)."""
    code = 'class BudgetAwareSkill(BaseSkill):\n    """Extended base class for budget-aware skills."""\n\n    def estimate_tokens(self, params: Dict[str, Any]) -> int:\n        """Estimate token consumption for this execution.\n\n        Used by budget allocator to provide warnings.\n\n        Args:\n            params: Skill execution parameters\n\n        Returns:\n            Estimated token count\n        """\n        return 1000  # Override with actual estimation\n\n    def on_budget_warning(self, estimated: int, allocated: int):\n        """Callback when budget warning is triggered.\n\n        Default behavior: log warning and continue.\n        Override to customize behavior.\n\n        Args:\n            estimated: Estimated token consumption\n            allocated: Allocated budget (if limits enabled)\n        """\n        logger.warning(\n            f"Budget warning: estimated {estimated} tokens, "\n            f"allocated {allocated} tokens"\n        )\n\n    def on_budget_exceeded(self, estimated: int, allocated: int) -> bool:\n        """Callback when hard budget limit exceeded.\n\n        Only called if hard limits are enabled.\n\n        Args:\n            estimated: Estimated token consumption\n            allocated: Allocated budget\n\n        Returns:\n            True to proceed anyway, False to abort\n        """\n        return False  # Default: respect hard limits'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_claude_code_skills_FEEDBACK_INCORPORATION_PLAN_4():
    """Test code snippet from projects/claude-code-skills/FEEDBACK_INCORPORATION_PLAN.md (line 787)."""
    code = '# plugins/mycelium-core/skills/database.py\nimport os\nimport psycopg2\nfrom psycopg2.pool import SimpleConnectionPool\nfrom pgvector.psycopg2 import register_vector\n\nclass DatabaseManager:\n    """Manages PostgreSQL connections for skills infrastructure."""\n\n    def __init__(self):\n        self.pool = SimpleConnectionPool(\n            minconn=1,\n            maxconn=10,\n            host=os.getenv(\'PGHOST\', \'localhost\'),\n            database=os.getenv(\'PGDATABASE\', \'mycelium_skills\'),\n            user=os.getenv(\'PGUSER\', os.getenv(\'USER\')),\n            password=os.getenv(\'PGPASSWORD\', \'\')\n        )\n\n    def get_connection(self):\n        """Get connection from pool."""\n        conn = self.pool.getconn()\n        register_vector(conn)  # Enable pgvector support\n        return conn\n\n    def return_connection(self, conn):\n        """Return connection to pool."""\n        self.pool.putconn(conn)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_claude_code_skills_FEEDBACK_INCORPORATION_PLAN_5():
    """Test code snippet from projects/claude-code-skills/FEEDBACK_INCORPORATION_PLAN.md (line 824)."""
    code = '"""\nTF-IDF Vectorizer for agent search with pgvector integration.\nHybrid approach: TF-IDF for explainability + embeddings for semantic search.\n"""\n\nfrom typing import List, Dict, Any, Optional\nfrom pathlib import Path\nimport json\nimport numpy as np\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.metrics.pairwise import cosine_similarity\nfrom sentence_transformers import SentenceTransformer\nimport psycopg2\nfrom pgvector.psycopg2 import register_vector\n\nclass AgentVectorizer:\n    """Hybrid TF-IDF + Embeddings agent similarity ranking."""\n\n    def __init__(self, index_path: str, db_manager: Optional[\'DatabaseManager\'] = None):\n        """Initialize vectorizer.\n\n        Args:\n            index_path: Path to agents/index.json\n            db_manager: Database manager for pgvector (optional)\n        """\n        self.index_path = Path(index_path)\n        self.db_manager = db_manager\n        self.agents = self._load_agents()\n\n        # TF-IDF for keyword matching (explainability)\n        self.vectorizer = TfidfVectorizer(\n            max_features=500,\n            stop_words=\'english\',\n            ngram_range=(1, 2),\n            lowercase=True\n        )\n        self.agent_vectors = self._vectorize_agents()\n\n        # Sentence embeddings for semantic search (accuracy)\n        self.embedding_model = SentenceTransformer(\'all-MiniLM-L6-v2\')\n        self._ensure_embeddings()\n\n    def _ensure_embeddings(self):\n        """Ensure all agents have embeddings in database."""\n        if not self.db_manager:\n            return  # Skip if no database\n\n        conn = self.db_manager.get_connection()\n        try:\n            cursor = conn.cursor()\n\n            # Check which agents need embeddings\n            cursor.execute("""\n                SELECT id FROM skills\n                WHERE id NOT IN (SELECT skill_id FROM skill_embeddings)\n            """)\n            missing = [row[0] for row in cursor.fetchall()]\n\n            if missing:\n                print(f"Generating embeddings for {len(missing)} agents...")\n                for agent in self.agents:\n                    if agent[\'id\'] in missing:\n                        # Generate embedding\n                        text = f"{agent.get(\'description\', \'\')} {\' \'.join(agent.get(\'keywords\', []))}"\n                        embedding = self.embedding_model.encode(text)\n\n                        # Store in database\n                        cursor.execute("""\n                            INSERT INTO skill_embeddings (skill_id, embedding)\n                            VALUES (%s, %s)\n                        """, (agent[\'id\'], embedding.tolist()))\n\n                conn.commit()\n                print(f"✅ Generated {len(missing)} embeddings")\n        finally:\n            self.db_manager.return_connection(conn)\n\n    def search(\n        self,\n        query: str,\n        max_results: int = 5,\n        category_filter: Optional[str] = None,\n        min_score: float = 0.0,\n        use_embeddings: bool = True\n    ) -> List[Dict[str, Any]]:\n        """Hybrid search using TF-IDF + embeddings.\n\n        Args:\n            query: Search query\n            max_results: Max results to return\n            category_filter: Optional category filter\n            min_score: Minimum similarity score\n            use_embeddings: Use pgvector semantic search (default: True)\n\n        Returns:\n            List of matching agents with scores\n        """\n        # TF-IDF search (fast, explainable)\n        tfidf_results = self._tfidf_search(query, max_results * 2, category_filter)\n\n        # Embedding search (accurate, semantic)\n        if use_embeddings and self.db_manager:\n            embedding_results = self._embedding_search(query, max_results * 2, category_filter)\n\n            # Combine results (weighted average)\n            combined = self._combine_results(tfidf_results, embedding_results, weights=(0.3, 0.7))\n        else:\n            combined = tfidf_results\n\n        # Filter and return top results\n        filtered = [r for r in combined if r[\'score\'] >= min_score]\n        return filtered[:max_results]\n\n    def _embedding_search(\n        self,\n        query: str,\n        max_results: int,\n        category_filter: Optional[str]\n    ) -> List[Dict[str, Any]]:\n        """Search using pgvector embeddings."""\n        conn = self.db_manager.get_connection()\n        try:\n            # Generate query embedding\n            query_embedding = self.embedding_model.encode(query)\n\n            # Similarity search using pgvector\n            cursor = conn.cursor()\n            sql = """\n                SELECT s.id, s.name, s.description, s.category,\n                       1 - (e.embedding <=> %s::vector) as similarity\n                FROM skills s\n                JOIN skill_embeddings e ON e.skill_id = s.id\n            """\n            params = [query_embedding.tolist()]\n\n            if category_filter:\n                sql += " WHERE s.category = %s"\n                params.append(category_filter)\n\n            sql += " ORDER BY e.embedding <=> %s::vector LIMIT %s"\n            params.extend([query_embedding.tolist(), max_results])\n\n            cursor.execute(sql, params)\n\n            results = []\n            for row in cursor.fetchall():\n                agent_id, name, description, category, similarity = row\n                results.append({\n                    \'agent_id\': agent_id,\n                    \'score\': float(similarity),\n                    \'explanation\': f"Semantic match (embedding similarity: {similarity:.3f})",\n                    \'category\': category or \'uncategorized\'\n                })\n\n            return results\n        finally:\n            self.db_manager.return_connection(conn)\n\n    def _combine_results(\n        self,\n        tfidf_results: List[Dict],\n        embedding_results: List[Dict],\n        weights: tuple = (0.3, 0.7)\n    ) -> List[Dict]:\n        """Combine TF-IDF and embedding results with weighted scores."""\n        # Create maps for quick lookup\n        tfidf_map = {r[\'agent_id\']: r for r in tfidf_results}\n        embedding_map = {r[\'agent_id\']: r for r in embedding_results}\n\n        # Get all unique agent IDs\n        all_ids = set(tfidf_map.keys()) | set(embedding_map.keys())\n\n        # Combine scores\n        combined = []\n        for agent_id in all_ids:\n            tfidf_score = tfidf_map.get(agent_id, {}).get(\'score\', 0.0)\n            embedding_score = embedding_map.get(agent_id, {}).get(\'score\', 0.0)\n\n            # Weighted average\n            final_score = weights[0] * tfidf_score + weights[1] * embedding_score\n\n            # Use embedding result as template (better explanation)\n            result = embedding_map.get(agent_id, tfidf_map.get(agent_id))\n            result[\'score\'] = final_score\n            result[\'explanation\'] = f"Hybrid match (TF-IDF: {tfidf_score:.3f}, Embedding: {embedding_score:.3f})"\n\n            combined.append(result)\n\n        # Sort by combined score\n        combined.sort(key=lambda x: x[\'score\'], reverse=True)\n        return combined'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_claude_code_skills_FEEDBACK_INCORPORATION_PLAN_6():
    """Test code snippet from projects/claude-code-skills/FEEDBACK_INCORPORATION_PLAN.md (line 1282)."""
    code = '# Click commands\nimport click\n\n@click.group()\ndef cli():\n    """Mycelium Skills CLI"""\n    pass\n\n@cli.command()\n@click.argument(\'skill_name\')\ndef install(skill_name: str):\n    """Install a skill from the repository."""\n    loader = SkillLoader()\n    loader.install(skill_name)\n    click.echo(f"✅ Installed {skill_name}")\n\n@cli.command()\n@click.option(\'--format\', type=click.Choice([\'table\', \'json\']), default=\'table\')\ndef list(format: str):\n    """List installed skills."""\n    registry = SkillRegistry()\n    skills = registry.list()\n\n    if format == \'json\':\n        click.echo(json.dumps(skills, indent=2))\n    else:\n        # Table output\n        for skill in skills:\n            click.echo(f"{skill[\'name\']:<30} {skill[\'version\']:<10} {skill[\'tier\']}")\n\n# Textual TUI\nfrom textual.app import App\nfrom textual.widgets import Header, Footer, DataTable, Static\nfrom textual.containers import Container\n\nclass MyceliumTUI(App):\n    """Interactive TUI for Mycelium Skills."""\n\n    BINDINGS = [\n        ("q", "quit", "Quit"),\n        ("s", "skills", "Skills"),\n        ("a", "analytics", "Analytics"),\n    ]\n\n    def compose(self):\n        yield Header()\n        yield Container(\n            DataTable(id="skills_table"),\n            Static(id="analytics_panel"),\n        )\n        yield Footer()\n\n    def on_mount(self):\n        table = self.query_one("#skills_table", DataTable)\n        table.add_columns("Name", "Version", "Tier", "Status")\n\n        # Load skills\n        registry = SkillRegistry()\n        for skill in registry.list():\n            table.add_row(\n                skill[\'name\'],\n                skill[\'version\'],\n                str(skill[\'tier\']),\n                "Active"\n            )\n\nif __name__ == \'__main__\':\n    app = MyceliumTUI()\n    app.run()'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_claude_code_skills_FEEDBACK_INCORPORATION_PLAN_7():
    """Test code snippet from projects/claude-code-skills/FEEDBACK_INCORPORATION_PLAN.md (line 1433)."""
    code = 'class TokenBudgetCalculator:\n    """Calculate token budgets with advisory warnings (no enforcement by default)."""\n\n    def __init__(self, policy_config: Dict[str, Any]):\n        self.policy = PolicyManager(policy_config)\n        self.predictor = MLTokenPredictor()  # From historical data\n\n    def calculate_budget(\n        self,\n        workflow: Workflow,\n        context: Dict[str, Any]\n    ) -> BudgetRecommendation:\n        """Calculate budget recommendation for workflow.\n\n        Returns advisory budget with warnings, not hard limits.\n        """\n        # Predict token consumption\n        estimated = self.predictor.predict(workflow, context)\n\n        # Apply buffer\n        buffer = self.policy.get_buffer_percentage()\n        recommended = estimated * (1 + buffer / 100)\n\n        # Generate recommendation\n        return BudgetRecommendation(\n            estimated_tokens=estimated,\n            recommended_budget=recommended,\n            confidence=self.predictor.confidence_score(),\n            mode=self.policy.get_mode(),  # "warn" | "limit" | "off"\n            warnings=self._generate_warnings(estimated, recommended),\n            enforcement_enabled=self.policy.hard_limits_enabled()\n        )\n\n    def check_budget_status(\n        self,\n        consumed: int,\n        budget: BudgetRecommendation\n    ) -> BudgetStatus:\n        """Check budget status and generate warnings if needed."""\n        percentage = consumed / budget.recommended_budget\n\n        status = BudgetStatus(\n            consumed=consumed,\n            recommended=budget.recommended_budget,\n            percentage=percentage,\n            warnings=[]\n        )\n\n        # Generate warnings based on policy\n        if budget.mode == "warn" and percentage > self.policy.warn_threshold:\n            status.warnings.append(\n                f"⚠️ Token consumption at {percentage*100:.1f}% of recommended budget. "\n                f"Consider optimizing or allocating more resources."\n            )\n\n        # Hard limit check (only if enabled)\n        if budget.mode == "limit" and percentage > 1.0:\n            if budget.enforcement_enabled:\n                raise BudgetExceededError(\n                    f"Hard budget limit exceeded: {consumed} > {budget.recommended_budget}"\n                )\n            else:\n                status.warnings.append(\n                    f"🚨 Budget exceeded but enforcement disabled. "\n                    f"Enable hard limits if cost control is required."\n                )\n\n        return status'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_claude_code_skills_success_metrics_1():
    """Test code snippet from projects/claude-code-skills/success-metrics.md (line 401)."""
    code = '# Session token consumption\nbaseline_tokens = 21150  # Phase 1 with lazy loading\ncurrent_tokens = measure_session_tokens()\n\nreduction_percentage = ((baseline_tokens - current_tokens) / baseline_tokens) * 100\n\n# Success: reduction_percentage >= 40 for M03'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_claude_code_skills_success_metrics_2():
    """Test code snippet from projects/claude-code-skills/success-metrics.md (line 413)."""
    code = "from sentence_transformers import SentenceTransformer\nfrom sklearn.metrics.pairwise import cosine_similarity\n\nmodel = SentenceTransformer('all-MiniLM-L6-v2')\n\noriginal_embedding = model.encode(original_text)\ncompressed_embedding = model.encode(compressed_text)\n\nsimilarity = cosine_similarity([original_embedding], [compressed_embedding])[0][0]\n\n# Success: similarity >= 0.95"

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_claude_code_skills_success_metrics_3():
    """Test code snippet from projects/claude-code-skills/success-metrics.md (line 429)."""
    code = '# Survey responses (1-5 scale)\nresponses = [5, 4, 5, 4, 3, 5, 4, 5, 4, 4]  # 10 respondents\n\naverage_score = sum(responses) / len(responses)\npercentage_satisfied = (average_score / 5) * 100\n\n# Success: percentage_satisfied >= 85'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_onboarding_ORIGINAL_PLAN_1():
    """Test code snippet from projects/onboarding/ORIGINAL_PLAN.md (line 77)."""
    code = '# ~/.claude/plugins/mycelium-core/lib/onboarding/tui.py\nfrom textual.app import App\nfrom textual.widgets import Checkbox, Button, SelectionList\n\nclass MyceliumOnboarding(App):\n    def compose(self):\n        yield Header()\n        yield ServiceSelector(detected_services)\n        yield DeploymentMethodSelector()\n        yield EnvironmentIsolationSelector()\n        yield ProgressView()\n        yield Footer()'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_onboarding_ORIGINAL_PLAN_2():
    """Test code snippet from projects/onboarding/ORIGINAL_PLAN.md (line 93)."""
    code = '# ~/.claude/plugins/mycelium-core/lib/onboarding/cli.py\nimport click\nfrom InquirerPy import inquirer\n\n@click.command()\ndef onboard():\n    services = detect_services()\n    selected = inquirer.checkbox(\n        message="Select services to enable:",\n        choices=[...detected_services]\n    ).execute()\n\n    deployment = inquirer.select(\n        message="Choose deployment method:",\n        choices=["Docker Compose", "Baremetal (Justfile)", "Baremetal (Procfile)"]\n    ).execute()\n\n    # Continue configuration...'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_onboarding_ORIGINAL_PLAN_3():
    """Test code snippet from projects/onboarding/ORIGINAL_PLAN.md (line 115)."""
    code = '# ~/.claude/plugins/mycelium-core/lib/onboarding/detect.py\n\ndef detect_services():\n    """Detect available services on host system"""\n    return {\n        "redis": check_redis(),\n        "postgres": check_postgres(),\n        "temporal": check_temporal(),\n        "docker": check_docker(),\n        "gpus": detect_gpus(),\n        "python": detect_python(),\n        "node": detect_node(),\n    }\n\ndef check_redis():\n    """Returns: {"available": bool, "version": str, "port": int}"""\n    result = subprocess.run(["redis-cli", "ping"], capture_output=True)\n    return {"available": result.returncode == 0, ...}\n\ndef detect_gpus():\n    """Returns: [{"model": str, "memory_gb": int, "driver": str}]"""\n    result = subprocess.run(["nvidia-smi", "--query-gpu=name,memory.total", "--format=csv,noheader"], ...)\n    # Parse and return GPU list'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_onboarding_ORIGINAL_PLAN_4():
    """Test code snippet from projects/onboarding/ORIGINAL_PLAN.md (line 532)."""
    code = '# In command execution context\ndef validate_python_command(cmd: str) -> bool:\n    """Ensure python commands use uv"""\n    blocked_patterns = [\n        r\'\\bpython\\s\',\n        r\'\\bpython3\\s\',\n        r\'\\bpip\\s\',\n        r\'\\bpip3\\s\',\n    ]\n\n    for pattern in blocked_patterns:\n        if re.search(pattern, cmd):\n            raise ValueError(\n                f"Direct python execution blocked. Use: uv run python ..."\n            )\n\n    return True'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_onboarding_ORIGINAL_PLAN_5():
    """Test code snippet from projects/onboarding/ORIGINAL_PLAN.md (line 621)."""
    code = '# ~/.claude/plugins/mycelium-core/lib/testing/orchestrator.py\n\nclass MyceliumTest:\n    def __init__(self, redis_client, taskqueue_client):\n        self.redis = redis_client\n        self.taskqueue = taskqueue_client\n        self.test_id = str(uuid.uuid4())\n\n    async def run_test(self):\n        """Execute full coordination test"""\n        print("🍄 Initializing Mycelium coordination test...")\n\n        # 1. Create test project\n        project = await self.create_test_project()\n\n        # 2. Generate quirky tasks\n        tasks = self.generate_spore_tasks()\n\n        # 3. Publish tasks to TaskQueue\n        for task in tasks:\n            await self.taskqueue.create_task(\n                project_id=project.id,\n                **task\n            )\n\n        # 4. Monitor coordination\n        results = await self.monitor_execution(\n            duration_seconds=60\n        )\n\n        # 5. Generate report\n        report = self.generate_report(results)\n\n        print(report)\n        return report\n\n    def generate_spore_tasks(self):\n        """Generate mycelium-themed test tasks"""\n        return [\n            {\n                "title": "Spread spores to 5 new locations",\n                "description": "Disperse fungal propagules across the network",\n                "agent": "task-distributor",\n                "priority": "high"\n            },\n            {\n                "title": "Establish hyphal network connection",\n                "description": "Create interconnected mycelial threads",\n                "agent": "context-manager",\n                "priority": "medium"\n            },\n            {\n                "title": "Synthesize nutrient report from decomposition",\n                "description": "Extract insights from organic matter breakdown",\n                "agent": "knowledge-synthesizer",\n                "priority": "medium"\n            },\n            {\n                "title": "Monitor mycelial growth rate",\n                "description": "Track expansion metrics across hyphae",\n                "agent": "performance-monitor",\n                "priority": "low"\n            },\n            {\n                "title": "Detect and isolate fungal anomalies",\n                "description": "Identify contamination or network disruptions",\n                "agent": "error-coordinator",\n                "priority": "high"\n            }\n        ]\n\n    async def monitor_execution(self, duration_seconds):\n        """Monitor Redis/TaskQueue during test"""\n        start_time = time.time()\n        metrics = {\n            "agent_responses": [],\n            "task_completions": [],\n            "messages_published": 0,\n            "heartbeat_count": 0\n        }\n\n        while time.time() - start_time < duration_seconds:\n            # Check Redis for agent activity\n            workload = await self.redis.hgetall("agents:workload")\n            heartbeats = await self.redis.hgetall("agents:heartbeat")\n\n            # Check TaskQueue for task progress\n            tasks = await self.taskqueue.list_tasks(\n                project_id=self.project_id\n            )\n\n            # Update metrics\n            metrics["heartbeat_count"] = len(heartbeats)\n            metrics["task_completions"] = sum(\n                1 for t in tasks if t.status == "done"\n            )\n\n            await asyncio.sleep(5)\n\n        return metrics'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_onboarding_ORIGINAL_PLAN_6():
    """Test code snippet from projects/onboarding/ORIGINAL_PLAN.md (line 1167)."""
    code = '# tests/test_detection.py\ndef test_detect_redis_running():\n    result = detect_services()\n    assert result["redis"]["available"] is True\n\ndef test_detect_gpu():\n    gpus = detect_gpus()\n    assert len(gpus) > 0\n    assert gpus[0]["model"] == "NVIDIA RTX 4090"'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_onboarding_ORIGINAL_PLAN_7():
    """Test code snippet from projects/onboarding/ORIGINAL_PLAN.md (line 1181)."""
    code = '# tests/test_onboarding.py\ndef test_docker_compose_generation():\n    config = {\n        "services": {"redis": {"enabled": True}},\n        "deployment": {"method": "docker-compose"}\n    }\n\n    compose_file = generate_docker_compose(config)\n    assert "redis:" in compose_file\n    assert "6379:6379" in compose_file\n\ndef test_justfile_generation():\n    config = {\n        "services": {"redis": {"enabled": True}},\n        "deployment": {"method": "baremetal"}\n    }\n\n    justfile = generate_justfile(config)\n    assert "start-redis:" in justfile\n    assert "[parallel]" in justfile'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_onboarding_ORIGINAL_PLAN_8():
    """Test code snippet from projects/onboarding/ORIGINAL_PLAN.md (line 1206)."""
    code = '# tests/test_coordination.py\nasync def test_full_coordination_flow():\n    """Test complete onboarding -> test -> validation flow"""\n\n    # 1. Run onboarding (non-interactive)\n    config = await run_onboarding(interactive=False)\n\n    # 2. Start services\n    await start_services(config)\n\n    # 3. Run coordination test\n    test_result = await run_mycelium_test()\n\n    # 4. Validate results\n    assert test_result.success is True\n    assert test_result.agents_responded == 5\n\n    # 5. Cleanup\n    await stop_services(config)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_onboarding_milestones_M01_ENVIRONMENT_ISOLATION_1():
    """Test code snippet from projects/onboarding/milestones/M01_ENVIRONMENT_ISOLATION.md (line 112)."""
    code = '# mycelium_onboarding/xdg_dirs.py\nfrom pathlib import Path\nimport os\nfrom typing import Optional\n\ndef get_config_dir(project_name: str = "mycelium") -> Path:\n    """Get XDG config directory, creating if needed.\n\n    Returns: ~/.config/mycelium/ or $XDG_CONFIG_HOME/mycelium/\n    """\n    base = os.environ.get("XDG_CONFIG_HOME")\n    if base is None:\n        base = Path.home() / ".config"\n    else:\n        base = Path(base)\n\n    config_dir = base / project_name\n    config_dir.mkdir(parents=True, exist_ok=True)\n    return config_dir\n\n\ndef get_data_dir(project_name: str = "mycelium") -> Path:\n    """Get XDG data directory, creating if needed.\n\n    Returns: ~/.local/share/mycelium/ or $XDG_DATA_HOME/mycelium/\n    """\n    base = os.environ.get("XDG_DATA_HOME")\n    if base is None:\n        base = Path.home() / ".local" / "share"\n    else:\n        base = Path(base)\n\n    data_dir = base / project_name\n    data_dir.mkdir(parents=True, exist_ok=True)\n    return data_dir\n\n\ndef get_cache_dir(project_name: str = "mycelium") -> Path:\n    """Get XDG cache directory, creating if needed.\n\n    Returns: ~/.cache/mycelium/ or $XDG_CACHE_HOME/mycelium/\n    """\n    base = os.environ.get("XDG_CACHE_HOME")\n    if base is None:\n        base = Path.home() / ".cache"\n    else:\n        base = Path(base)\n\n    cache_dir = base / project_name\n    cache_dir.mkdir(parents=True, exist_ok=True)\n    return cache_dir\n\n\ndef get_state_dir(project_name: str = "mycelium") -> Path:\n    """Get XDG state directory, creating if needed.\n\n    Returns: ~/.local/state/mycelium/ or $XDG_STATE_HOME/mycelium/\n    """\n    base = os.environ.get("XDG_STATE_HOME")\n    if base is None:\n        base = Path.home() / ".local" / "state"\n    else:\n        base = Path(base)\n\n    state_dir = base / project_name\n    state_dir.mkdir(parents=True, exist_ok=True)\n    return state_dir\n\n\ndef get_project_dir(project_root: Optional[Path] = None) -> Path:\n    """Get project-local directory.\n\n    Args:\n        project_root: Project root path (defaults to MYCELIUM_ROOT env var or cwd)\n\n    Returns: <project_root>/.mycelium/\n    """\n    if project_root is None:\n        root_env = os.environ.get("MYCELIUM_ROOT")\n        if root_env:\n            project_root = Path(root_env)\n        else:\n            project_root = Path.cwd()\n\n    project_dir = project_root / ".mycelium"\n    project_dir.mkdir(parents=True, exist_ok=True)\n    return project_dir\n\n\n# Convenience functions\ndef ensure_all_dirs() -> dict[str, Path]:\n    """Ensure all XDG directories exist and return them.\n\n    Returns:\n        Dictionary mapping directory names to paths\n    """\n    return {\n        "config": get_config_dir(),\n        "data": get_data_dir(),\n        "cache": get_cache_dir(),\n        "state": get_state_dir(),\n        "project": get_project_dir(),\n    }'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_onboarding_milestones_M01_ENVIRONMENT_ISOLATION_2():
    """Test code snippet from projects/onboarding/milestones/M01_ENVIRONMENT_ISOLATION.md (line 220)."""
    code = '# tests/test_xdg_dirs.py\nimport pytest\nfrom pathlib import Path\nimport os\n\ndef test_get_config_dir_default(monkeypatch, tmp_path):\n    """Test default config dir when XDG_CONFIG_HOME not set."""\n    monkeypatch.delenv("XDG_CONFIG_HOME", raising=False)\n    monkeypatch.setenv("HOME", str(tmp_path))\n\n    config_dir = get_config_dir()\n\n    assert config_dir == tmp_path / ".config" / "mycelium"\n    assert config_dir.exists()\n\n\ndef test_get_config_dir_custom(monkeypatch, tmp_path):\n    """Test custom config dir via XDG_CONFIG_HOME."""\n    custom_config = tmp_path / "custom_config"\n    monkeypatch.setenv("XDG_CONFIG_HOME", str(custom_config))\n\n    config_dir = get_config_dir()\n\n    assert config_dir == custom_config / "mycelium"\n    assert config_dir.exists()\n\n\ndef test_ensure_all_dirs(tmp_path, monkeypatch):\n    """Test that all directories are created."""\n    monkeypatch.setenv("HOME", str(tmp_path))\n    monkeypatch.setenv("MYCELIUM_ROOT", str(tmp_path / "project"))\n\n    dirs = ensure_all_dirs()\n\n    assert all(path.exists() for path in dirs.values())\n    assert "config" in dirs\n    assert "data" in dirs\n    assert "cache" in dirs\n    assert "state" in dirs\n    assert "project" in dirs'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_onboarding_milestones_M01_ENVIRONMENT_ISOLATION_3():
    """Test code snippet from projects/onboarding/milestones/M01_ENVIRONMENT_ISOLATION.md (line 320)."""
    code = '# mycelium_onboarding/setup_direnv.py\n"""Setup direnv integration for automatic environment activation."""\n\nfrom pathlib import Path\nimport shutil\nimport subprocess\nfrom typing import Optional\n\ndef check_direnv_installed() -> bool:\n    """Check if direnv is installed and available."""\n    return shutil.which("direnv") is not None\n\n\ndef setup_direnv(project_root: Optional[Path] = None) -> tuple[bool, str]:\n    """Setup direnv for the project.\n\n    Args:\n        project_root: Project root directory (defaults to cwd)\n\n    Returns:\n        (success, message) tuple\n    """\n    if project_root is None:\n        project_root = Path.cwd()\n\n    envrc_path = project_root / ".envrc"\n    template_path = Path(__file__).parent / "templates" / ".envrc.template"\n\n    # Check if direnv is installed\n    if not check_direnv_installed():\n        return False, "direnv not installed. Install from https://direnv.net/"\n\n    # Copy template if .envrc doesn\'t exist\n    if not envrc_path.exists():\n        shutil.copy(template_path, envrc_path)\n        message = f"Created {envrc_path}\\nRun: direnv allow"\n    else:\n        message = f".envrc already exists at {envrc_path}"\n\n    # Check if direnv hook is in shell config\n    shell_instructions = get_shell_hook_instructions()\n\n    return True, f"{message}\\n\\n{shell_instructions}"\n\n\ndef get_shell_hook_instructions() -> str:\n    """Get shell-specific hook instructions."""\n    shell = Path(subprocess.check_output(["echo", "$SHELL"], text=True).strip()).name\n\n    instructions = {\n        "bash": \'Add to ~/.bashrc: eval "$(direnv hook bash)"\',\n        "zsh": \'Add to ~/.zshrc: eval "$(direnv hook zsh)"\',\n        "fish": \'Add to ~/.config/fish/config.fish: direnv hook fish | source\',\n    }\n\n    return instructions.get(shell, "See https://direnv.net/docs/hook.html for your shell")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_onboarding_milestones_M01_ENVIRONMENT_ISOLATION_4():
    """Test code snippet from projects/onboarding/milestones/M01_ENVIRONMENT_ISOLATION.md (line 516)."""
    code = '# mycelium_onboarding/env_validator.py\n"""Runtime environment validation."""\n\nimport os\nfrom pathlib import Path\nfrom typing import List, Optional\n\nclass EnvironmentValidationError(Exception):\n    """Raised when environment validation fails."""\n    pass\n\n\ndef validate_environment(require_project_dir: bool = False) -> None:\n    """Validate that Mycelium environment is properly activated.\n\n    Args:\n        require_project_dir: If True, also require MYCELIUM_PROJECT_DIR\n\n    Raises:\n        EnvironmentValidationError: If environment is not properly set up\n    """\n    required_vars = [\n        "MYCELIUM_ROOT",\n        "MYCELIUM_CONFIG_DIR",\n        "MYCELIUM_DATA_DIR",\n        "MYCELIUM_CACHE_DIR",\n        "MYCELIUM_STATE_DIR",\n    ]\n\n    if require_project_dir:\n        required_vars.append("MYCELIUM_PROJECT_DIR")\n\n    missing_vars = []\n    for var in required_vars:\n        if var not in os.environ:\n            missing_vars.append(var)\n\n    if missing_vars:\n        raise EnvironmentValidationError(\n            f"Missing environment variables: {\', \'.join(missing_vars)}\\n"\n            "Activate environment first:\\n"\n            "  - With direnv: cd to project and run \'direnv allow\'\\n"\n            "  - Without direnv: run \'source bin/activate.sh\'"\n        )\n\n    # Validate that directories exist\n    for var in required_vars:\n        path = Path(os.environ[var])\n        if not path.exists():\n            raise EnvironmentValidationError(\n                f"Directory does not exist: {path} (from ${var})\\n"\n                "Run: python -m mycelium_onboarding setup"\n            )\n\n\ndef is_environment_active() -> bool:\n    """Check if Mycelium environment is active.\n\n    Returns:\n        True if environment is active, False otherwise\n    """\n    return "MYCELIUM_ENV_ACTIVE" in os.environ\n\n\ndef get_missing_vars() -> List[str]:\n    """Get list of missing environment variables.\n\n    Returns:\n        List of missing variable names (empty if all present)\n    """\n    required_vars = [\n        "MYCELIUM_ROOT",\n        "MYCELIUM_CONFIG_DIR",\n        "MYCELIUM_DATA_DIR",\n        "MYCELIUM_CACHE_DIR",\n        "MYCELIUM_STATE_DIR",\n    ]\n\n    return [var for var in required_vars if var not in os.environ]\n\n\ndef get_environment_info() -> dict[str, Optional[str]]:\n    """Get current environment information.\n\n    Returns:\n        Dictionary of environment variables and their values\n    """\n    vars_to_check = [\n        "MYCELIUM_ROOT",\n        "MYCELIUM_CONFIG_DIR",\n        "MYCELIUM_DATA_DIR",\n        "MYCELIUM_CACHE_DIR",\n        "MYCELIUM_STATE_DIR",\n        "MYCELIUM_PROJECT_DIR",\n        "MYCELIUM_ENV_ACTIVE",\n    ]\n\n    return {var: os.environ.get(var) for var in vars_to_check}'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_onboarding_milestones_M01_ENVIRONMENT_ISOLATION_5():
    """Test code snippet from projects/onboarding/milestones/M01_ENVIRONMENT_ISOLATION.md (line 619)."""
    code = '# mycelium_onboarding/cli.py\nimport click\nfrom mycelium_onboarding.env_validator import validate_environment\n\n@click.group()\ndef cli():\n    """Mycelium onboarding CLI."""\n    # Validate environment before running any commands\n    try:\n        validate_environment()\n    except EnvironmentValidationError as e:\n        click.echo(str(e), err=True)\n        raise click.Abort()\n\n\n@cli.command()\ndef status():\n    """Show environment status."""\n    from mycelium_onboarding.env_validator import get_environment_info\n\n    info = get_environment_info()\n    click.echo("Mycelium Environment Status:")\n    for var, value in info.items():\n        status = "✓" if value else "✗"\n        click.echo(f"  {status} {var}: {value or \'(not set)\'}")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_onboarding_milestones_M01_ENVIRONMENT_ISOLATION_6():
    """Test code snippet from projects/onboarding/milestones/M01_ENVIRONMENT_ISOLATION.md (line 671)."""
    code = '# mycelium_onboarding/config_loader.py\n"""Hierarchical configuration loading."""\n\nfrom pathlib import Path\nimport os\nfrom typing import Optional\n\ndef get_config_path(filename: str, prefer_project: bool = True) -> Path:\n    """Get configuration file path following precedence.\n\n    Precedence order:\n    1. Project-local: .mycelium/<filename>\n    2. User-global: ~/.config/mycelium/<filename>\n    3. Defaults: package resources\n\n    Args:\n        filename: Configuration filename (e.g., "config.yaml")\n        prefer_project: If True, prefer project-local over user-global\n\n    Returns:\n        Path to configuration file (may not exist)\n    """\n    # Check project-local first (if MYCELIUM_PROJECT_DIR set and prefer_project)\n    if prefer_project and "MYCELIUM_PROJECT_DIR" in os.environ:\n        project_path = Path(os.environ["MYCELIUM_PROJECT_DIR"]) / filename\n        if project_path.exists():\n            return project_path\n\n    # Check user-global\n    from mycelium_onboarding.xdg_dirs import get_config_dir\n    user_path = get_config_dir() / filename\n    if user_path.exists():\n        return user_path\n\n    # Check project-local again (even if prefer_project=False, for creation)\n    if "MYCELIUM_PROJECT_DIR" in os.environ:\n        project_path = Path(os.environ["MYCELIUM_PROJECT_DIR"]) / filename\n        if prefer_project:\n            return project_path\n\n    # Fall back to user-global (even if doesn\'t exist, for creation)\n    return user_path\n\n\ndef get_all_config_paths(filename: str) -> list[Path]:\n    """Get all possible config file locations in precedence order.\n\n    Args:\n        filename: Configuration filename\n\n    Returns:\n        List of paths in precedence order (may not all exist)\n    """\n    paths = []\n\n    # Project-local\n    if "MYCELIUM_PROJECT_DIR" in os.environ:\n        paths.append(Path(os.environ["MYCELIUM_PROJECT_DIR"]) / filename)\n\n    # User-global\n    from mycelium_onboarding.xdg_dirs import get_config_dir\n    paths.append(get_config_dir() / filename)\n\n    return paths\n\n\ndef find_config_file(filename: str) -> Optional[Path]:\n    """Find first existing config file in precedence order.\n\n    Args:\n        filename: Configuration filename\n\n    Returns:\n        Path to first existing config file, or None if not found\n    """\n    for path in get_all_config_paths(filename):\n        if path.exists():\n            return path\n    return None'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_onboarding_milestones_M01_ENVIRONMENT_ISOLATION_7():
    """Test code snippet from projects/onboarding/milestones/M01_ENVIRONMENT_ISOLATION.md (line 755)."""
    code = '# Example: Loading config with fallback\nimport yaml\n\ndef load_config():\n    """Load configuration with hierarchical fallback."""\n    config_file = find_config_file("config.yaml")\n\n    if config_file:\n        with open(config_file) as f:\n            return yaml.safe_load(f)\n\n    # No config file found, return defaults\n    return {\n        "deployment_method": "docker-compose",\n        "services": ["redis", "postgres"],\n    }'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_onboarding_milestones_M01_ENVIRONMENT_ISOLATION_8():
    """Test code snippet from projects/onboarding/milestones/M01_ENVIRONMENT_ISOLATION.md (line 799)."""
    code = '# tests/integration/test_environment_activation.py\nimport pytest\nimport subprocess\nfrom pathlib import Path\n\n\ndef test_manual_activation_full_flow(tmp_path):\n    """Test complete manual activation flow."""\n    # Setup mock project\n    project_dir = tmp_path / "test_project"\n    project_dir.mkdir()\n\n    # Copy activation script\n    activate_script = project_dir / "bin" / "activate.sh"\n    activate_script.parent.mkdir()\n    # ... copy script ...\n\n    # Run activation in subprocess\n    result = subprocess.run(\n        ["bash", "-c", f"source {activate_script} && env"],\n        capture_output=True,\n        text=True\n    )\n\n    # Verify environment variables set\n    assert "MYCELIUM_ROOT" in result.stdout\n    assert "MYCELIUM_CONFIG_DIR" in result.stdout\n    assert "MYCELIUM_ENV_ACTIVE=1" in result.stdout\n\n\ndef test_direnv_activation(tmp_path):\n    """Test direnv activation (if direnv installed)."""\n    if not shutil.which("direnv"):\n        pytest.skip("direnv not installed")\n\n    # Setup .envrc\n    project_dir = tmp_path / "test_project"\n    project_dir.mkdir()\n    envrc = project_dir / ".envrc"\n    # ... copy .envrc.template ...\n\n    # Allow direnv\n    subprocess.run(["direnv", "allow"], cwd=project_dir, check=True)\n\n    # Verify environment\n    result = subprocess.run(\n        ["direnv", "exec", str(project_dir), "env"],\n        capture_output=True,\n        text=True\n    )\n\n    assert "MYCELIUM_ENV_ACTIVE=1" in result.stdout\n\n\ndef test_runtime_validation():\n    """Test runtime validation catches missing environment."""\n    from mycelium_onboarding.env_validator import validate_environment\n\n    # Clear environment\n    for var in os.environ.copy():\n        if var.startswith("MYCELIUM_"):\n            del os.environ[var]\n\n    # Should raise error\n    with pytest.raises(EnvironmentValidationError):\n        validate_environment()'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_onboarding_milestones_M02_CONFIGURATION_SYSTEM_1():
    """Test code snippet from projects/onboarding/milestones/M02_CONFIGURATION_SYSTEM.md (line 95)."""
    code = '# mycelium_onboarding/config/schema.py\n"""Configuration schema using Pydantic v2."""\n\nfrom pydantic import BaseModel, Field, field_validator\nfrom typing import Literal, Optional\nfrom pathlib import Path\nfrom enum import Enum\n\n\nclass DeploymentMethod(str, Enum):\n    """Supported deployment methods."""\n    DOCKER_COMPOSE = "docker-compose"\n    JUSTFILE = "justfile"\n\n\nclass ServiceConfig(BaseModel):\n    """Configuration for a single service."""\n    enabled: bool = True\n    version: Optional[str] = None\n    custom_config: dict[str, str] = Field(default_factory=dict)\n\n\nclass RedisConfig(ServiceConfig):\n    """Redis-specific configuration."""\n    port: int = Field(default=6379, ge=1, le=65535)\n    persistence: bool = True\n    max_memory: str = "256mb"\n\n\nclass PostgresConfig(ServiceConfig):\n    """PostgreSQL-specific configuration."""\n    port: int = Field(default=5432, ge=1, le=65535)\n    database: str = "mycelium"\n    max_connections: int = 100\n\n\nclass TemporalConfig(ServiceConfig):\n    """Temporal-specific configuration."""\n    ui_port: int = Field(default=8080, ge=1, le=65535)\n    frontend_port: int = Field(default=7233, ge=1, le=65535)\n    namespace: str = "default"\n\n\nclass ServicesConfig(BaseModel):\n    """All service configurations."""\n    redis: RedisConfig = Field(default_factory=RedisConfig)\n    postgres: PostgresConfig = Field(default_factory=PostgresConfig)\n    temporal: TemporalConfig = Field(default_factory=TemporalConfig)\n\n\nclass DeploymentConfig(BaseModel):\n    """Deployment configuration."""\n    method: DeploymentMethod = DeploymentMethod.DOCKER_COMPOSE\n    auto_start: bool = True\n    healthcheck_timeout: int = Field(default=60, ge=10, le=300)\n\n\nclass MyceliumConfig(BaseModel):\n    """Top-level Mycelium configuration."""\n    version: Literal["1.0"] = "1.0"  # Schema version\n    deployment: DeploymentConfig = Field(default_factory=DeploymentConfig)\n    services: ServicesConfig = Field(default_factory=ServicesConfig)\n    project_name: str = "mycelium"\n\n    @field_validator("project_name")\n    @classmethod\n    def validate_project_name(cls, v: str) -> str:\n        """Validate project name is alphanumeric with hyphens/underscores."""\n        import re\n        if not re.match(r"^[a-zA-Z0-9_-]+$", v):\n            raise ValueError(\n                "Project name must contain only alphanumeric characters, "\n                "hyphens, and underscores"\n            )\n        return v\n\n    def model_post_init(self, __context) -> None:\n        """Post-initialization hook for custom validation."""\n        # Ensure at least one service is enabled\n        if not any([\n            self.services.redis.enabled,\n            self.services.postgres.enabled,\n            self.services.temporal.enabled,\n        ]):\n            raise ValueError("At least one service must be enabled")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_onboarding_milestones_M02_CONFIGURATION_SYSTEM_2():
    """Test code snippet from projects/onboarding/milestones/M02_CONFIGURATION_SYSTEM.md (line 207)."""
    code = '# mycelium_onboarding/config/manager.py\n"""Configuration manager for loading/saving configurations."""\n\nfrom pathlib import Path\nfrom typing import Optional\nimport yaml\nfrom pydantic import ValidationError\n\nfrom mycelium_onboarding.config.schema import MyceliumConfig\nfrom mycelium_onboarding.config_loader import get_config_path, find_config_file\n\n\nclass ConfigurationError(Exception):\n    """Base exception for configuration errors."""\n    pass\n\n\nclass ConfigValidationError(ConfigurationError):\n    """Configuration validation failed."""\n    pass\n\n\nclass ConfigManager:\n    """Manages configuration loading, saving, and validation."""\n\n    CONFIG_FILENAME = "config.yaml"\n\n    @classmethod\n    def load(cls, prefer_project: bool = True) -> MyceliumConfig:\n        """Load configuration from file or return defaults.\n\n        Args:\n            prefer_project: Prefer project-local over user-global config\n\n        Returns:\n            MyceliumConfig instance\n\n        Raises:\n            ConfigValidationError: If configuration is invalid\n        """\n        config_file = find_config_file(cls.CONFIG_FILENAME)\n\n        if config_file is None:\n            # No config file found, return defaults\n            return MyceliumConfig()\n\n        return cls.load_from_path(config_file)\n\n    @classmethod\n    def load_from_path(cls, path: Path) -> MyceliumConfig:\n        """Load configuration from specific path.\n\n        Args:\n            path: Path to configuration file\n\n        Returns:\n            MyceliumConfig instance\n\n        Raises:\n            ConfigValidationError: If configuration is invalid\n            FileNotFoundError: If path doesn\'t exist\n        """\n        if not path.exists():\n            raise FileNotFoundError(f"Configuration file not found: {path}")\n\n        with open(path) as f:\n            try:\n                data = yaml.safe_load(f)\n            except yaml.YAMLError as e:\n                raise ConfigValidationError(\n                    f"Invalid YAML in {path}: {e}"\n                ) from e\n\n        if data is None:\n            # Empty file, return defaults\n            return MyceliumConfig()\n\n        try:\n            return MyceliumConfig.model_validate(data)\n        except ValidationError as e:\n            raise ConfigValidationError(\n                f"Configuration validation failed in {path}:\\n{e}"\n            ) from e\n\n    @classmethod\n    def save(\n        cls,\n        config: MyceliumConfig,\n        project_local: bool = False,\n        create_dirs: bool = True,\n    ) -> Path:\n        """Save configuration to file.\n\n        Args:\n            config: Configuration to save\n            project_local: Save to project-local (.mycelium/) if True,\n                          user-global (~/.config/mycelium/) if False\n            create_dirs: Create parent directories if they don\'t exist\n\n        Returns:\n            Path where configuration was saved\n\n        Raises:\n            ConfigValidationError: If configuration is invalid before save\n        """\n        # Validate before saving\n        try:\n            config.model_validate(config.model_dump())\n        except ValidationError as e:\n            raise ConfigValidationError(\n                f"Configuration invalid, not saving:\\n{e}"\n            ) from e\n\n        # Determine save path\n        config_path = get_config_path(\n            cls.CONFIG_FILENAME,\n            prefer_project=project_local\n        )\n\n        # Create parent directories if needed\n        if create_dirs:\n            config_path.parent.mkdir(parents=True, exist_ok=True)\n\n        # Serialize to YAML with nice formatting\n        config_dict = config.model_dump(mode="json", exclude_none=True)\n\n        with open(config_path, "w") as f:\n            yaml.dump(\n                config_dict,\n                f,\n                default_flow_style=False,\n                sort_keys=False,\n                allow_unicode=True,\n            )\n\n        return config_path\n\n    @classmethod\n    def exists(cls, prefer_project: bool = True) -> bool:\n        """Check if configuration file exists.\n\n        Args:\n            prefer_project: Check project-local first if True\n\n        Returns:\n            True if configuration file exists\n        """\n        return find_config_file(cls.CONFIG_FILENAME) is not None\n\n    @classmethod\n    def get_config_location(cls, prefer_project: bool = True) -> Path:\n        """Get path where configuration would be saved.\n\n        Args:\n            prefer_project: Get project-local path if True\n\n        Returns:\n            Path to configuration file (may not exist)\n        """\n        return get_config_path(cls.CONFIG_FILENAME, prefer_project=prefer_project)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_onboarding_milestones_M02_CONFIGURATION_SYSTEM_3():
    """Test code snippet from projects/onboarding/milestones/M02_CONFIGURATION_SYSTEM.md (line 372)."""
    code = '# Load configuration (auto-detects location)\nconfig = ConfigManager.load()\n\n# Modify configuration\nconfig.deployment.method = DeploymentMethod.JUSTFILE\nconfig.services.redis.port = 6380\n\n# Save to user-global config\nConfigManager.save(config, project_local=False)\n\n# Save to project-local config\nConfigManager.save(config, project_local=True)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_onboarding_milestones_M02_CONFIGURATION_SYSTEM_4():
    """Test code snippet from projects/onboarding/milestones/M02_CONFIGURATION_SYSTEM.md (line 412)."""
    code = '# mycelium_onboarding/config/migrations.py\n"""Configuration schema migrations."""\n\nfrom typing import Any, Callable\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n# Type alias for migration function\nMigrationFunc = Callable[[dict[str, Any]], dict[str, Any]]\n\n# Registry of migrations: version -> migration function\n_MIGRATIONS: dict[str, MigrationFunc] = {}\n\n\ndef register_migration(from_version: str, to_version: str):\n    """Decorator to register a migration function.\n\n    Args:\n        from_version: Source schema version\n        to_version: Target schema version\n    """\n    def decorator(func: MigrationFunc) -> MigrationFunc:\n        key = f"{from_version}->{to_version}"\n        _MIGRATIONS[key] = func\n        logger.debug(f"Registered migration: {key}")\n        return func\n    return decorator\n\n\ndef migrate_config(config_dict: dict[str, Any]) -> dict[str, Any]:\n    """Migrate configuration to latest schema version.\n\n    Args:\n        config_dict: Raw configuration dictionary\n\n    Returns:\n        Migrated configuration dictionary\n\n    Raises:\n        ValueError: If migration path not found\n    """\n    current_version = config_dict.get("version", "0.9")  # Assume 0.9 if missing\n    target_version = "1.0"\n\n    if current_version == target_version:\n        logger.debug(f"Configuration already at version {target_version}")\n        return config_dict\n\n    # Find migration path\n    migration_path = _find_migration_path(current_version, target_version)\n\n    if not migration_path:\n        raise ValueError(\n            f"No migration path from {current_version} to {target_version}"\n        )\n\n    # Apply migrations in sequence\n    migrated = config_dict.copy()\n    for from_ver, to_ver in migration_path:\n        key = f"{from_ver}->{to_ver}"\n        migration_func = _MIGRATIONS[key]\n\n        logger.info(f"Applying migration: {key}")\n        migrated = migration_func(migrated)\n        migrated["version"] = to_ver\n\n    return migrated\n\n\ndef _find_migration_path(\n    from_version: str,\n    to_version: str\n) -> list[tuple[str, str]]:\n    """Find shortest migration path between versions.\n\n    Args:\n        from_version: Starting version\n        to_version: Target version\n\n    Returns:\n        List of (from, to) version tuples forming migration path\n    """\n    # Simple linear path for now (can extend to graph search later)\n    if from_version == "0.9" and to_version == "1.0":\n        return [("0.9", "1.0")]\n\n    return []\n\n\n# Define migrations\n\n@register_migration("0.9", "1.0")\ndef migrate_0_9_to_1_0(config: dict[str, Any]) -> dict[str, Any]:\n    """Migrate from schema 0.9 to 1.0.\n\n    Changes:\n    - Add deployment.healthcheck_timeout field\n    - Rename service.redis.memory to service.redis.max_memory\n    - Add service.postgres.max_connections field\n    """\n    migrated = config.copy()\n\n    # Add deployment.healthcheck_timeout\n    if "deployment" not in migrated:\n        migrated["deployment"] = {}\n    if "healthcheck_timeout" not in migrated["deployment"]:\n        migrated["deployment"]["healthcheck_timeout"] = 60\n\n    # Rename redis.memory to redis.max_memory\n    if "services" in migrated and "redis" in migrated["services"]:\n        redis = migrated["services"]["redis"]\n        if "memory" in redis:\n            redis["max_memory"] = redis.pop("memory")\n\n    # Add postgres.max_connections\n    if "services" in migrated and "postgres" in migrated["services"]:\n        postgres = migrated["services"]["postgres"]\n        if "max_connections" not in postgres:\n            postgres["max_connections"] = 100\n\n    return migrated'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_onboarding_milestones_M02_CONFIGURATION_SYSTEM_5():
    """Test code snippet from projects/onboarding/milestones/M02_CONFIGURATION_SYSTEM.md (line 539)."""
    code = '# In mycelium_onboarding/config/manager.py\n\nfrom mycelium_onboarding.config.migrations import migrate_config\n\nclass ConfigManager:\n    @classmethod\n    def load_from_path(cls, path: Path) -> MyceliumConfig:\n        """Load configuration from specific path with migration."""\n        # ... existing code to load YAML ...\n\n        # Apply migrations if needed\n        if data.get("version") != "1.0":\n            logger.info(f"Migrating configuration from {data.get(\'version\')} to 1.0")\n            data = migrate_config(data)\n\n        try:\n            return MyceliumConfig.model_validate(data)\n        except ValidationError as e:\n            raise ConfigValidationError(\n                f"Configuration validation failed in {path}:\\n{e}"\n            ) from e'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_onboarding_milestones_M02_CONFIGURATION_SYSTEM_6():
    """Test code snippet from projects/onboarding/milestones/M02_CONFIGURATION_SYSTEM.md (line 589)."""
    code = '# mycelium_onboarding/cli/config_commands.py\n"""CLI commands for configuration management."""\n\nimport click\nimport yaml\nfrom pathlib import Path\n\nfrom mycelium_onboarding.config.manager import ConfigManager, ConfigValidationError\nfrom mycelium_onboarding.config.schema import MyceliumConfig\n\n\n@click.group(name="config")\ndef config_group():\n    """Configuration management commands."""\n    pass\n\n\n@config_group.command(name="show")\n@click.option(\n    "--project-local",\n    is_flag=True,\n    help="Show project-local configuration only"\n)\n@click.option(\n    "--format",\n    type=click.Choice(["yaml", "json"]),\n    default="yaml",\n    help="Output format"\n)\ndef show_config(project_local: bool, format: str):\n    """Show current configuration."""\n    try:\n        config = ConfigManager.load(prefer_project=project_local)\n\n        if format == "yaml":\n            output = yaml.dump(\n                config.model_dump(mode="json"),\n                default_flow_style=False,\n                sort_keys=False\n            )\n        else:  # json\n            output = config.model_dump_json(indent=2)\n\n        click.echo(output)\n\n    except ConfigValidationError as e:\n        click.echo(f"❌ Configuration invalid: {e}", err=True)\n        raise click.Abort()\n\n\n@config_group.command(name="validate")\n@click.argument("config_file", type=click.Path(exists=True), required=False)\ndef validate_config(config_file: Optional[str]):\n    """Validate configuration file.\n\n    If CONFIG_FILE not provided, validates current configuration.\n    """\n    try:\n        if config_file:\n            config = ConfigManager.load_from_path(Path(config_file))\n            click.echo(f"✓ Configuration valid: {config_file}")\n        else:\n            config = ConfigManager.load()\n            click.echo("✓ Configuration valid")\n\n        # Show summary\n        enabled_services = [\n            name for name, svc in config.services.model_dump().items()\n            if svc.get("enabled", False)\n        ]\n        click.echo(f"\\nDeployment: {config.deployment.method.value}")\n        click.echo(f"Services: {\', \'.join(enabled_services)}")\n\n    except ConfigValidationError as e:\n        click.echo(f"❌ Configuration invalid:\\n{e}", err=True)\n        raise click.Abort()\n    except FileNotFoundError as e:\n        click.echo(f"❌ {e}", err=True)\n        raise click.Abort()\n\n\n@config_group.command(name="location")\n@click.option(\n    "--project-local",\n    is_flag=True,\n    help="Show project-local location"\n)\ndef show_location(project_local: bool):\n    """Show configuration file location."""\n    location = ConfigManager.get_config_location(prefer_project=project_local)\n    exists = location.exists()\n\n    status = "✓" if exists else "✗"\n    click.echo(f"{status} {location}")\n\n    if not exists:\n        click.echo("  (file does not exist)")\n\n\n@config_group.command(name="init")\n@click.option(\n    "--project-local",\n    is_flag=True,\n    help="Create project-local configuration"\n)\n@click.option(\n    "--force",\n    is_flag=True,\n    help="Overwrite existing configuration"\n)\ndef init_config(project_local: bool, force: bool):\n    """Initialize configuration with defaults."""\n    location = ConfigManager.get_config_location(prefer_project=project_local)\n\n    if location.exists() and not force:\n        click.echo(f"❌ Configuration already exists: {location}", err=True)\n        click.echo("Use --force to overwrite")\n        raise click.Abort()\n\n    # Create default configuration\n    config = MyceliumConfig()\n    saved_path = ConfigManager.save(config, project_local=project_local)\n\n    click.echo(f"✓ Created configuration: {saved_path}")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_onboarding_milestones_M03_SERVICE_DETECTION_1():
    """Test code snippet from projects/onboarding/milestones/M03_SERVICE_DETECTION.md (line 96)."""
    code = '# mycelium_onboarding/detection/docker.py\n"""Docker detection and health checking."""\n\nimport subprocess\nimport shutil\nfrom typing import Optional\nfrom dataclasses import dataclass\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n\n@dataclass\nclass DockerInfo:\n    """Docker detection result."""\n    available: bool\n    version: Optional[str] = None\n    running: bool = False\n    compose_available: bool = False\n    compose_version: Optional[str] = None\n    error: Optional[str] = None\n\n\ndef detect_docker(timeout: float = 2.0) -> DockerInfo:\n    """Detect Docker Engine availability and status.\n\n    Args:\n        timeout: Timeout in seconds for detection commands\n\n    Returns:\n        DockerInfo with detection results\n    """\n    # Check if docker command exists\n    if not shutil.which("docker"):\n        return DockerInfo(\n            available=False,\n            error="docker command not found in PATH"\n        )\n\n    info = DockerInfo(available=True)\n\n    # Get Docker version\n    try:\n        result = subprocess.run(\n            ["docker", "--version"],\n            capture_output=True,\n            text=True,\n            timeout=timeout,\n            check=False\n        )\n        if result.returncode == 0:\n            # Parse version from "Docker version 24.0.6, build ed223bc"\n            version_line = result.stdout.strip()\n            if "version" in version_line.lower():\n                parts = version_line.split()\n                version_idx = parts.index("version") if "version" in parts else -1\n                if version_idx >= 0 and version_idx + 1 < len(parts):\n                    info.version = parts[version_idx + 1].rstrip(",")\n\n    except (subprocess.TimeoutExpired, subprocess.SubprocessError) as e:\n        logger.warning(f"Failed to get Docker version: {e}")\n\n    # Check if Docker daemon is running\n    try:\n        result = subprocess.run(\n            ["docker", "ps"],\n            capture_output=True,\n            text=True,\n            timeout=timeout,\n            check=False\n        )\n        info.running = (result.returncode == 0)\n        if not info.running:\n            info.error = "Docker daemon not running"\n\n    except (subprocess.TimeoutExpired, subprocess.SubprocessError) as e:\n        logger.warning(f"Failed to check Docker status: {e}")\n        info.running = False\n        info.error = str(e)\n\n    # Check Docker Compose\n    info.compose_available = _detect_docker_compose(timeout)\n    if info.compose_available:\n        info.compose_version = _get_compose_version(timeout)\n\n    return info\n\n\ndef _detect_docker_compose(timeout: float) -> bool:\n    """Check if Docker Compose is available."""\n    # Try docker compose (v2, plugin)\n    try:\n        result = subprocess.run(\n            ["docker", "compose", "version"],\n            capture_output=True,\n            timeout=timeout,\n            check=False\n        )\n        if result.returncode == 0:\n            return True\n    except (subprocess.TimeoutExpired, subprocess.SubprocessError):\n        pass\n\n    # Try docker-compose (v1, standalone)\n    if shutil.which("docker-compose"):\n        try:\n            result = subprocess.run(\n                ["docker-compose", "--version"],\n                capture_output=True,\n                timeout=timeout,\n                check=False\n            )\n            return result.returncode == 0\n        except (subprocess.TimeoutExpired, subprocess.SubprocessError):\n            pass\n\n    return False\n\n\ndef _get_compose_version(timeout: float) -> Optional[str]:\n    """Get Docker Compose version."""\n    # Try docker compose (v2)\n    try:\n        result = subprocess.run(\n            ["docker", "compose", "version", "--short"],\n            capture_output=True,\n            text=True,\n            timeout=timeout,\n            check=False\n        )\n        if result.returncode == 0:\n            return result.stdout.strip()\n    except (subprocess.TimeoutExpired, subprocess.SubprocessError):\n        pass\n\n    # Try docker-compose (v1)\n    if shutil.which("docker-compose"):\n        try:\n            result = subprocess.run(\n                ["docker-compose", "--version"],\n                capture_output=True,\n                text=True,\n                timeout=timeout,\n                check=False\n            )\n            if result.returncode == 0:\n                # Parse "docker-compose version 1.29.2, build 5becea4c"\n                parts = result.stdout.split()\n                if len(parts) >= 3:\n                    return parts[2].rstrip(",")\n        except (subprocess.TimeoutExpired, subprocess.SubprocessError):\n            pass\n\n    return None'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_onboarding_milestones_M03_SERVICE_DETECTION_2():
    """Test code snippet from projects/onboarding/milestones/M03_SERVICE_DETECTION.md (line 255)."""
    code = '# tests/test_docker_detection.py\nimport pytest\nfrom mycelium_onboarding.detection.docker import detect_docker, DockerInfo\n\n\ndef test_detect_docker_available(monkeypatch):\n    """Test detection when Docker is available."""\n    # Mock docker command\n    def mock_run(*args, **kwargs):\n        command = args[0]\n        if "--version" in command:\n            return subprocess.CompletedProcess(\n                args=command,\n                returncode=0,\n                stdout="Docker version 24.0.6, build ed223bc\\n"\n            )\n        elif "ps" in command:\n            return subprocess.CompletedProcess(\n                args=command,\n                returncode=0,\n                stdout=""\n            )\n        return subprocess.CompletedProcess(args=command, returncode=1)\n\n    monkeypatch.setattr("subprocess.run", mock_run)\n    monkeypatch.setattr("shutil.which", lambda x: "/usr/bin/docker" if x == "docker" else None)\n\n    info = detect_docker()\n\n    assert info.available\n    assert info.version == "24.0.6"\n    assert info.running\n\n\ndef test_detect_docker_not_installed(monkeypatch):\n    """Test detection when Docker is not installed."""\n    monkeypatch.setattr("shutil.which", lambda x: None)\n\n    info = detect_docker()\n\n    assert not info.available\n    assert "not found" in info.error.lower()'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_onboarding_milestones_M03_SERVICE_DETECTION_3():
    """Test code snippet from projects/onboarding/milestones/M03_SERVICE_DETECTION.md (line 325)."""
    code = '# mycelium_onboarding/detection/redis.py\n"""Redis detection and health checking."""\n\nimport socket\nfrom typing import Optional\nfrom dataclasses import dataclass\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n\n@dataclass\nclass RedisInfo:\n    """Redis detection result."""\n    available: bool\n    host: str = "localhost"\n    port: int = 6379\n    version: Optional[str] = None\n    reachable: bool = False\n    error: Optional[str] = None\n\n\ndef detect_redis(\n    host: str = "localhost",\n    port: int = 6379,\n    timeout: float = 2.0\n) -> RedisInfo:\n    """Detect Redis server availability.\n\n    Args:\n        host: Redis host\n        port: Redis port\n        timeout: Connection timeout\n\n    Returns:\n        RedisInfo with detection results\n    """\n    info = RedisInfo(available=False, host=host, port=port)\n\n    # Try socket connection first\n    try:\n        with socket.create_connection((host, port), timeout=timeout) as sock:\n            info.available = True\n            info.reachable = True\n\n            # Try to get Redis version via INFO command\n            sock.sendall(b"INFO server\\r\\n")\n            response = sock.recv(1024).decode("utf-8", errors="ignore")\n\n            # Parse version from "redis_version:7.0.12"\n            for line in response.split("\\r\\n"):\n                if line.startswith("redis_version:"):\n                    info.version = line.split(":", 1)[1]\n                    break\n\n    except socket.timeout:\n        info.error = f"Connection timeout to {host}:{port}"\n        logger.debug(f"Redis connection timeout: {host}:{port}")\n\n    except (socket.error, OSError) as e:\n        info.error = f"Cannot connect to {host}:{port}: {e}"\n        logger.debug(f"Redis connection failed: {host}:{port} - {e}")\n\n    return info\n\n\ndef scan_redis_ports(\n    host: str = "localhost",\n    ports: list[int] = None,\n    timeout: float = 1.0\n) -> list[RedisInfo]:\n    """Scan multiple ports for Redis servers.\n\n    Args:\n        host: Redis host to scan\n        ports: List of ports to check (default: common Redis ports)\n        timeout: Connection timeout per port\n\n    Returns:\n        List of RedisInfo for available Redis servers\n    """\n    if ports is None:\n        ports = [6379, 6380, 6381]  # Common Redis ports\n\n    results = []\n    for port in ports:\n        info = detect_redis(host, port, timeout)\n        if info.available:\n            results.append(info)\n\n    return results'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_onboarding_milestones_M03_SERVICE_DETECTION_4():
    """Test code snippet from projects/onboarding/milestones/M03_SERVICE_DETECTION.md (line 444)."""
    code = '# mycelium_onboarding/detection/postgres.py\n"""PostgreSQL detection."""\n\n@dataclass\nclass PostgresInfo:\n    available: bool\n    host: str = "localhost"\n    port: int = 5432\n    version: Optional[str] = None\n    reachable: bool = False\n    error: Optional[str] = None\n\n\ndef detect_postgres(\n    host: str = "localhost",\n    port: int = 5432,\n    timeout: float = 2.0\n) -> PostgresInfo:\n    """Detect PostgreSQL server."""\n    info = PostgresInfo(available=False, host=host, port=port)\n\n    try:\n        with socket.create_connection((host, port), timeout=timeout):\n            info.available = True\n            info.reachable = True\n\n            # Could attempt PostgreSQL startup message for version\n            # For simplicity, just check socket connection\n\n    except (socket.timeout, socket.error, OSError) as e:\n        info.error = str(e)\n\n    return info'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_onboarding_milestones_M03_SERVICE_DETECTION_5():
    """Test code snippet from projects/onboarding/milestones/M03_SERVICE_DETECTION.md (line 480)."""
    code = '# mycelium_onboarding/detection/temporal.py\n"""Temporal detection."""\n\nimport requests\n\n@dataclass\nclass TemporalInfo:\n    available: bool\n    host: str = "localhost"\n    frontend_port: int = 7233\n    ui_port: int = 8080\n    version: Optional[str] = None\n    reachable: bool = False\n    error: Optional[str] = None\n\n\ndef detect_temporal(\n    host: str = "localhost",\n    frontend_port: int = 7233,\n    ui_port: int = 8080,\n    timeout: float = 2.0\n) -> TemporalInfo:\n    """Detect Temporal server."""\n    info = TemporalInfo(\n        available=False,\n        host=host,\n        frontend_port=frontend_port,\n        ui_port=ui_port\n    )\n\n    # Check frontend port (gRPC)\n    try:\n        with socket.create_connection((host, frontend_port), timeout=timeout):\n            info.available = True\n\n    except (socket.timeout, socket.error, OSError):\n        info.error = f"Frontend port {frontend_port} not reachable"\n        return info\n\n    # Check UI port (HTTP)\n    try:\n        response = requests.get(\n            f"http://{host}:{ui_port}",\n            timeout=timeout,\n            allow_redirects=False\n        )\n        info.reachable = (response.status_code in [200, 302])\n\n    except requests.RequestException as e:\n        info.error = f"UI port {ui_port} not reachable: {e}"\n\n    return info'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_onboarding_milestones_M03_SERVICE_DETECTION_6():
    """Test code snippet from projects/onboarding/milestones/M03_SERVICE_DETECTION.md (line 559)."""
    code = '# mycelium_onboarding/detection/gpu.py\n"""GPU detection."""\n\nimport subprocess\nimport shutil\nfrom typing import Optional\nfrom dataclasses import dataclass\nfrom enum import Enum\n\n\nclass GPUType(str, Enum):\n    """GPU types."""\n    NVIDIA = "nvidia"\n    AMD = "amd"\n    UNKNOWN = "unknown"\n\n\n@dataclass\nclass GPUInfo:\n    """GPU detection result."""\n    available: bool\n    gpu_type: Optional[GPUType] = None\n    count: int = 0\n    driver_version: Optional[str] = None\n    cuda_version: Optional[str] = None\n    devices: list[str] = None\n    error: Optional[str] = None\n\n    def __post_init__(self):\n        if self.devices is None:\n            self.devices = []\n\n\ndef detect_gpu(timeout: float = 2.0) -> GPUInfo:\n    """Detect GPU availability.\n\n    Args:\n        timeout: Timeout for detection commands\n\n    Returns:\n        GPUInfo with detection results\n    """\n    # Try NVIDIA first\n    nvidia_info = _detect_nvidia_gpu(timeout)\n    if nvidia_info.available:\n        return nvidia_info\n\n    # Try AMD\n    amd_info = _detect_amd_gpu(timeout)\n    if amd_info.available:\n        return amd_info\n\n    # No GPU found\n    return GPUInfo(available=False, error="No GPU detected")\n\n\ndef _detect_nvidia_gpu(timeout: float) -> GPUInfo:\n    """Detect NVIDIA GPU via nvidia-smi."""\n    if not shutil.which("nvidia-smi"):\n        return GPUInfo(available=False, error="nvidia-smi not found")\n\n    info = GPUInfo(available=False, gpu_type=GPUType.NVIDIA)\n\n    try:\n        result = subprocess.run(\n            [\n                "nvidia-smi",\n                "--query-gpu=name,driver_version",\n                "--format=csv,noheader"\n            ],\n            capture_output=True,\n            text=True,\n            timeout=timeout,\n            check=False\n        )\n\n        if result.returncode == 0:\n            lines = result.stdout.strip().split("\\n")\n            info.count = len(lines)\n            info.available = info.count > 0\n\n            for line in lines:\n                parts = line.split(",")\n                if len(parts) >= 1:\n                    info.devices.append(parts[0].strip())\n                if len(parts) >= 2 and not info.driver_version:\n                    info.driver_version = parts[1].strip()\n\n            # Get CUDA version\n            info.cuda_version = _get_cuda_version(timeout)\n\n        else:\n            info.error = result.stderr.strip()\n\n    except (subprocess.TimeoutExpired, subprocess.SubprocessError) as e:\n        info.error = str(e)\n\n    return info\n\n\ndef _get_cuda_version(timeout: float) -> Optional[str]:\n    """Get CUDA version from nvidia-smi."""\n    try:\n        result = subprocess.run(\n            ["nvidia-smi", "--query-gpu=driver_version", "--format=csv,noheader"],\n            capture_output=True,\n            text=True,\n            timeout=timeout,\n            check=False\n        )\n        if result.returncode == 0:\n            # Parse CUDA version from output\n            # This is simplified; actual parsing may be more complex\n            return result.stdout.strip().split("\\n")[0]\n\n    except (subprocess.TimeoutExpired, subprocess.SubprocessError):\n        pass\n\n    return None\n\n\ndef _detect_amd_gpu(timeout: float) -> GPUInfo:\n    """Detect AMD GPU via rocm-smi."""\n    if not shutil.which("rocm-smi"):\n        return GPUInfo(available=False, error="rocm-smi not found")\n\n    info = GPUInfo(available=False, gpu_type=GPUType.AMD)\n\n    try:\n        result = subprocess.run(\n            ["rocm-smi", "--showproductname"],\n            capture_output=True,\n            text=True,\n            timeout=timeout,\n            check=False\n        )\n\n        if result.returncode == 0:\n            # Parse AMD GPU info from output\n            lines = result.stdout.strip().split("\\n")\n            # Simplified parsing\n            info.count = len([l for l in lines if "GPU" in l])\n            info.available = info.count > 0\n\n        else:\n            info.error = result.stderr.strip()\n\n    except (subprocess.TimeoutExpired, subprocess.SubprocessError) as e:\n        info.error = str(e)\n\n    return info'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_onboarding_milestones_M03_SERVICE_DETECTION_7():
    """Test code snippet from projects/onboarding/milestones/M03_SERVICE_DETECTION.md (line 737)."""
    code = '# mycelium_onboarding/detection/orchestrator.py\n"""Service detection orchestrator."""\n\nimport asyncio\nimport json\nfrom pathlib import Path\nfrom datetime import datetime, timedelta\nfrom typing import Optional\nfrom dataclasses import asdict\nimport logging\n\nfrom mycelium_onboarding.xdg_dirs import get_cache_dir\nfrom mycelium_onboarding.detection.docker import detect_docker, DockerInfo\nfrom mycelium_onboarding.detection.redis import detect_redis, RedisInfo\nfrom mycelium_onboarding.detection.postgres import detect_postgres, PostgresInfo\nfrom mycelium_onboarding.detection.temporal import detect_temporal, TemporalInfo\nfrom mycelium_onboarding.detection.gpu import detect_gpu, GPUInfo\n\nlogger = logging.getLogger(__name__)\n\n\nclass DetectionResults:\n    """All service detection results."""\n\n    def __init__(\n        self,\n        docker: DockerInfo,\n        redis: RedisInfo,\n        postgres: PostgresInfo,\n        temporal: TemporalInfo,\n        gpu: GPUInfo,\n        timestamp: datetime = None\n    ):\n        self.docker = docker\n        self.redis = redis\n        self.postgres = postgres\n        self.temporal = temporal\n        self.gpu = gpu\n        self.timestamp = timestamp or datetime.now(UTC)\n\n    def to_dict(self) -> dict:\n        """Convert to dictionary for serialization."""\n        return {\n            "timestamp": self.timestamp.isoformat(),\n            "docker": asdict(self.docker),\n            "redis": asdict(self.redis),\n            "postgres": asdict(self.postgres),\n            "temporal": asdict(self.temporal),\n            "gpu": asdict(self.gpu),\n        }\n\n    @classmethod\n    def from_dict(cls, data: dict) -> "DetectionResults":\n        """Load from dictionary."""\n        return cls(\n            docker=DockerInfo(**data["docker"]),\n            redis=RedisInfo(**data["redis"]),\n            postgres=PostgresInfo(**data["postgres"]),\n            temporal=TemporalInfo(**data["temporal"]),\n            gpu=GPUInfo(**data["gpu"]),\n            timestamp=datetime.fromisoformat(data["timestamp"])\n        )\n\n\nasync def detect_all_services(\n    use_cache: bool = True,\n    cache_ttl: int = 300  # 5 minutes\n) -> DetectionResults:\n    """Detect all services in parallel.\n\n    Args:\n        use_cache: Use cached results if available and fresh\n        cache_ttl: Cache TTL in seconds\n\n    Returns:\n        DetectionResults with all detection results\n    """\n    # Try to load from cache\n    if use_cache:\n        cached = _load_from_cache(cache_ttl)\n        if cached:\n            logger.info("Using cached detection results")\n            return cached\n\n    # Run all detections in parallel\n    logger.info("Running service detection (parallel)...")\n\n    docker_task = asyncio.to_thread(detect_docker)\n    redis_task = asyncio.to_thread(detect_redis)\n    postgres_task = asyncio.to_thread(detect_postgres)\n    temporal_task = asyncio.to_thread(detect_temporal)\n    gpu_task = asyncio.to_thread(detect_gpu)\n\n    docker, redis, postgres, temporal, gpu = await asyncio.gather(\n        docker_task,\n        redis_task,\n        postgres_task,\n        temporal_task,\n        gpu_task\n    )\n\n    results = DetectionResults(\n        docker=docker,\n        redis=redis,\n        postgres=postgres,\n        temporal=temporal,\n        gpu=gpu\n    )\n\n    # Save to cache\n    _save_to_cache(results)\n\n    return results\n\n\ndef _get_cache_path() -> Path:\n    """Get cache file path."""\n    cache_dir = get_cache_dir()\n    return cache_dir / "service-detection.json"\n\n\ndef _load_from_cache(ttl: int) -> Optional[DetectionResults]:\n    """Load detection results from cache if fresh."""\n    cache_path = _get_cache_path()\n\n    if not cache_path.exists():\n        return None\n\n    try:\n        with open(cache_path) as f:\n            data = json.load(f)\n\n        results = DetectionResults.from_dict(data)\n\n        # Check if cache is fresh\n        age = datetime.now(UTC) - results.timestamp\n        if age > timedelta(seconds=ttl):\n            logger.debug("Cache expired")\n            return None\n\n        return results\n\n    except (json.JSONDecodeError, KeyError, ValueError) as e:\n        logger.warning(f"Failed to load cache: {e}")\n        return None\n\n\ndef _save_to_cache(results: DetectionResults) -> None:\n    """Save detection results to cache."""\n    cache_path = _get_cache_path()\n\n    try:\n        cache_path.parent.mkdir(parents=True, exist_ok=True)\n\n        with open(cache_path, "w") as f:\n            json.dump(results.to_dict(), f, indent=2)\n\n        logger.debug(f"Saved detection results to cache: {cache_path}")\n\n    except (OSError, TypeError) as e:\n        logger.warning(f"Failed to save cache: {e}")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_onboarding_milestones_M03_SERVICE_DETECTION_8():
    """Test code snippet from projects/onboarding/milestones/M03_SERVICE_DETECTION.md (line 903)."""
    code = '# mycelium_onboarding/cli/detect_commands.py\n"""CLI commands for service detection."""\n\nimport click\nimport asyncio\nimport json\n\nfrom mycelium_onboarding.detection.orchestrator import detect_all_services\n\n\n@click.command(name="detect")\n@click.option(\n    "--no-cache",\n    is_flag=True,\n    help="Skip cache, always run fresh detection"\n)\n@click.option(\n    "--format",\n    type=click.Choice(["text", "json"]),\n    default="text",\n    help="Output format"\n)\ndef detect_services(no_cache: bool, format: str):\n    """Detect available services."""\n    use_cache = not no_cache\n\n    # Run async detection\n    results = asyncio.run(detect_all_services(use_cache=use_cache))\n\n    if format == "json":\n        click.echo(json.dumps(results.to_dict(), indent=2))\n    else:\n        _print_text_results(results)\n\n\ndef _print_text_results(results):\n    """Print results in human-readable format."""\n    click.echo("=== Service Detection Results ===\\n")\n\n    # Docker\n    click.echo("Docker:")\n    if results.docker.available:\n        status = "✓ Available" if results.docker.running else "⚠ Not running"\n        click.echo(f"  {status}")\n        if results.docker.version:\n            click.echo(f"  Version: {results.docker.version}")\n        if results.docker.compose_available:\n            click.echo(f"  Compose: {results.docker.compose_version or \'available\'}")\n    else:\n        click.echo(f"  ✗ Not available ({results.docker.error})")\n\n    # Redis\n    click.echo("\\nRedis:")\n    if results.redis.available:\n        click.echo(f"  ✓ Available at {results.redis.host}:{results.redis.port}")\n        if results.redis.version:\n            click.echo(f"  Version: {results.redis.version}")\n    else:\n        click.echo(f"  ✗ Not available ({results.redis.error})")\n\n    # ... similar for postgres, temporal, gpu ...'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_onboarding_milestones_M04_INTERACTIVE_ONBOARDING_1():
    """Test code snippet from projects/onboarding/milestones/M04_INTERACTIVE_ONBOARDING.md (line 65)."""
    code = '# mycelium_onboarding/wizard/flow.py\n"""\nWizard flow design and orchestration.\n\nFlow Sequence:\n1. Welcome screen with system detection summary\n2. Service selection (Redis, Postgres, Temporal, TaskQueue)\n3. Service configuration (ports, persistence, memory limits)\n4. Deployment method selection (Docker Compose, Justfile)\n5. Project metadata (name, description)\n6. Configuration review and confirmation\n7. Write configuration and show next steps\n"""\n\nfrom enum import Enum\nfrom typing import Optional\nfrom dataclasses import dataclass\n\nclass WizardStep(str, Enum):\n    WELCOME = "welcome"\n    SERVICE_SELECTION = "service_selection"\n    SERVICE_CONFIG = "service_config"\n    DEPLOYMENT_METHOD = "deployment_method"\n    PROJECT_METADATA = "project_metadata"\n    REVIEW = "review"\n    FINALIZE = "finalize"\n\n@dataclass\nclass WizardState:\n    """Maintains state across wizard steps."""\n    current_step: WizardStep\n    detection_results: Optional[\'DetectionResults\'] = None\n    selected_services: set[str] = None\n    deployment_method: Optional[str] = None\n    config: Optional[\'MyceliumConfig\'] = None\n\n    def can_proceed(self) -> bool:\n        """Validate if current step is complete."""\n        if self.current_step == WizardStep.SERVICE_SELECTION:\n            return self.selected_services is not None\n        elif self.current_step == WizardStep.DEPLOYMENT_METHOD:\n            return self.deployment_method is not None\n        return True\n\n    def next_step(self) -> Optional[WizardStep]:\n        """Determine next step in flow."""\n        steps = list(WizardStep)\n        current_idx = steps.index(self.current_step)\n        if current_idx < len(steps) - 1:\n            return steps[current_idx + 1]\n        return None\n\ndef create_wizard_state(detection_results: \'DetectionResults\') -> WizardState:\n    """Initialize wizard state with detection results."""\n    return WizardState(\n        current_step=WizardStep.WELCOME,\n        detection_results=detection_results,\n        selected_services=set(),\n    )'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_onboarding_milestones_M04_INTERACTIVE_ONBOARDING_2():
    """Test code snippet from projects/onboarding/milestones/M04_INTERACTIVE_ONBOARDING.md (line 142)."""
    code = '# mycelium_onboarding/wizard/screens.py\n"""Individual wizard screens using InquirerPy."""\n\nfrom InquirerPy import inquirer\nfrom InquirerPy.base.control import Choice\nfrom InquirerPy.validator import PathValidator\nfrom rich.console import Console\nfrom rich.panel import Panel\nfrom rich.table import Table\n\nconsole = Console()\n\ndef show_welcome_screen(detection_results: \'DetectionResults\') -> None:\n    """Display welcome screen with system detection summary."""\n    console.clear()\n\n    # Create detection summary table\n    table = Table(title="🔍 System Detection Results")\n    table.add_column("Service", style="cyan")\n    table.add_column("Status", style="green")\n    table.add_column("Details", style="white")\n\n    # Add detection results\n    table.add_row(\n        "Docker",\n        "✓ Available" if detection_results.docker.available else "✗ Not Found",\n        detection_results.docker.version or "N/A"\n    )\n    table.add_row(\n        "Redis",\n        "✓ Running" if detection_results.redis.reachable else "○ Available",\n        f"{detection_results.redis.host}:{detection_results.redis.port}"\n    )\n    # ... add other services ...\n\n    console.print(table)\n    console.print("\\n")\n    console.print(Panel(\n        "[bold]Welcome to Mycelium Onboarding![/bold]\\n\\n"\n        "This wizard will guide you through setting up your multi-agent "\n        "coordination infrastructure. We\'ve detected your system and will "\n        "recommend the best configuration.",\n        border_style="blue"\n    ))\n\n    inquirer.confirm(\n        message="Ready to begin?",\n        default=True,\n    ).execute()\n\ndef prompt_service_selection(detection_results: \'DetectionResults\') -> set[str]:\n    """Prompt user to select services to enable."""\n    console.print("\\n[bold cyan]Service Selection[/bold cyan]")\n    console.print("Select which coordination services to enable:\\n")\n\n    choices = [\n        Choice(\n            value="redis",\n            name="Redis - Pub/Sub messaging and state management",\n            enabled=detection_results.redis.available,\n        ),\n        Choice(\n            value="postgres",\n            name="PostgreSQL - Persistent data storage",\n            enabled=detection_results.postgres.available,\n        ),\n        Choice(\n            value="temporal",\n            name="Temporal - Workflow orchestration",\n            enabled=detection_results.temporal.available,\n        ),\n        Choice(\n            value="taskqueue",\n            name="TaskQueue - Task distribution (MCP)",\n            enabled=True,  # Always available via MCP\n        ),\n    ]\n\n    selected = inquirer.checkbox(\n        message="Select services (Space to toggle, Enter to confirm):",\n        choices=choices,\n        validate=lambda result: len(result) > 0,\n        invalid_message="You must select at least one service",\n    ).execute()\n\n    return set(selected)\n\ndef prompt_deployment_method(has_docker: bool) -> str:\n    """Prompt user to choose deployment method."""\n    console.print("\\n[bold cyan]Deployment Method[/bold cyan]")\n\n    if not has_docker:\n        console.print(\n            "[yellow]⚠ Docker not detected. Defaulting to Justfile deployment.[/yellow]\\n"\n        )\n        return "justfile"\n\n    choices = [\n        Choice(\n            value="docker-compose",\n            name="Docker Compose (Recommended) - Containerized services with automatic dependency management",\n        ),\n        Choice(\n            value="justfile",\n            name="Justfile - Bare-metal deployment with manual service management",\n        ),\n    ]\n\n    method = inquirer.select(\n        message="Choose deployment method:",\n        choices=choices,\n        default="docker-compose",\n    ).execute()\n\n    return method\n\ndef prompt_project_metadata() -> dict[str, str]:\n    """Prompt for project name and description."""\n    console.print("\\n[bold cyan]Project Metadata[/bold cyan]\\n")\n\n    name = inquirer.text(\n        message="Project name:",\n        default="mycelium",\n        validate=lambda x: x.isidentifier(),\n        invalid_message="Must be valid Python identifier (letters, numbers, underscores)",\n    ).execute()\n\n    description = inquirer.text(\n        message="Project description (optional):",\n        default="Multi-agent coordination system",\n    ).execute()\n\n    return {"name": name, "description": description}\n\ndef show_configuration_review(config: \'MyceliumConfig\') -> bool:\n    """Display configuration review and confirm."""\n    console.print("\\n[bold cyan]Configuration Review[/bold cyan]\\n")\n\n    # Create configuration summary\n    table = Table(title="Final Configuration")\n    table.add_column("Setting", style="cyan")\n    table.add_column("Value", style="white")\n\n    table.add_row("Project Name", config.project_name)\n    table.add_row("Deployment Method", config.deployment.method)\n    table.add_row("Services Enabled", ", ".join([\n        s for s in ["redis", "postgres", "temporal", "taskqueue"]\n        if getattr(config.services, s).enabled\n    ]))\n\n    console.print(table)\n    console.print("\\n")\n\n    confirmed = inquirer.confirm(\n        message="Save this configuration?",\n        default=True,\n    ).execute()\n\n    return confirmed'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_onboarding_milestones_M04_INTERACTIVE_ONBOARDING_3():
    """Test code snippet from projects/onboarding/milestones/M04_INTERACTIVE_ONBOARDING.md (line 306)."""
    code = '# tests/test_wizard_screens.py\n"""Test wizard screen rendering and validation."""\n\nimport pytest\nfrom unittest.mock import patch, MagicMock\nfrom mycelium_onboarding.wizard.screens import (\n    prompt_service_selection,\n    prompt_deployment_method,\n    prompt_project_metadata,\n)\n\ndef test_service_selection_requires_at_least_one():\n    """Service selection should require at least one service."""\n    with patch(\'mycelium_onboarding.wizard.screens.inquirer.checkbox\') as mock:\n        mock.return_value.execute.return_value = []\n        # Should show validation error\n        # (validation happens in InquirerPy, test the validator)\n\ndef test_deployment_method_defaults_to_justfile_without_docker():\n    """Should default to Justfile when Docker unavailable."""\n    method = prompt_deployment_method(has_docker=False)\n    assert method == "justfile"\n\ndef test_project_metadata_validates_identifier():\n    """Project name must be valid Python identifier."""\n    # Test validation logic separately\n    validator = lambda x: x.isidentifier()\n    assert validator("mycelium") is True\n    assert validator("my-project") is False\n    assert validator("123project") is False'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_onboarding_milestones_M04_INTERACTIVE_ONBOARDING_4():
    """Test code snippet from projects/onboarding/milestones/M04_INTERACTIVE_ONBOARDING.md (line 355)."""
    code = '# mycelium_onboarding/wizard/integration.py\n"""Integration between wizard and detection system."""\n\nfrom mycelium_onboarding.detection.orchestrator import detect_all_services\nfrom mycelium_onboarding.wizard.flow import WizardState, create_wizard_state\nfrom mycelium_onboarding.wizard.screens import (\n    show_welcome_screen,\n    prompt_service_selection,\n    prompt_deployment_method,\n)\n\nasync def run_wizard_with_detection(use_cache: bool = True) -> \'MyceliumConfig\':\n    """Run full wizard flow with service detection."""\n\n    # Step 1: Detect services (use cache if available)\n    console.print("[dim]Detecting available services...[/dim]")\n    detection_results = await detect_all_services(use_cache=use_cache)\n\n    # Step 2: Initialize wizard state\n    state = create_wizard_state(detection_results)\n\n    # Step 3: Show welcome with detection summary\n    show_welcome_screen(detection_results)\n\n    # Step 4: Service selection\n    state.selected_services = prompt_service_selection(detection_results)\n\n    # Step 5: Deployment method\n    state.deployment_method = prompt_deployment_method(\n        has_docker=detection_results.docker.available\n    )\n\n    # Step 6: Project metadata\n    metadata = prompt_project_metadata()\n\n    # Step 7: Build configuration\n    config = build_config_from_selections(\n        selected_services=state.selected_services,\n        deployment_method=state.deployment_method,\n        project_name=metadata["name"],\n        detection_results=detection_results,\n    )\n\n    # Step 8: Review and confirm\n    confirmed = show_configuration_review(config)\n    if not confirmed:\n        console.print("[yellow]Configuration not saved. Exiting.[/yellow]")\n        return None\n\n    return config\n\ndef build_config_from_selections(\n    selected_services: set[str],\n    deployment_method: str,\n    project_name: str,\n    detection_results: \'DetectionResults\',\n) -> \'MyceliumConfig\':\n    """Build MyceliumConfig from wizard selections."""\n    from mycelium_onboarding.config.schema import (\n        MyceliumConfig,\n        DeploymentConfig,\n        ServicesConfig,\n        RedisConfig,\n        PostgresConfig,\n    )\n\n    # Create service configs based on selections\n    redis_config = RedisConfig(\n        enabled="redis" in selected_services,\n        port=detection_results.redis.port if detection_results.redis.reachable else 6379,\n    )\n\n    postgres_config = PostgresConfig(\n        enabled="postgres" in selected_services,\n        port=detection_results.postgres.port if detection_results.postgres.reachable else 5432,\n    )\n\n    # Build full config\n    config = MyceliumConfig(\n        project_name=project_name,\n        deployment=DeploymentConfig(method=deployment_method),\n        services=ServicesConfig(\n            redis=redis_config,\n            postgres=postgres_config,\n            # ... other services ...\n        ),\n    )\n\n    return config'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_onboarding_milestones_M04_INTERACTIVE_ONBOARDING_5():
    """Test code snippet from projects/onboarding/milestones/M04_INTERACTIVE_ONBOARDING.md (line 462)."""
    code = '# mycelium_onboarding/wizard/persistence.py\n"""Configuration persistence after wizard completion."""\n\nfrom pathlib import Path\nfrom rich.console import Console\nfrom rich.panel import Panel\n\nfrom mycelium_onboarding.config.manager import ConfigManager\nfrom mycelium_onboarding.config.schema import MyceliumConfig\n\nconsole = Console()\n\ndef save_configuration(\n    config: MyceliumConfig,\n    project_local: bool = False\n) -> tuple[bool, Optional[Path]]:\n    """\n    Save configuration using ConfigManager.\n\n    Args:\n        config: Configuration to save\n        project_local: If True, save to project dir; else user config\n\n    Returns:\n        (success, config_path) tuple\n    """\n    try:\n        config_path = ConfigManager.save(config, project_local=project_local)\n\n        console.print(Panel(\n            f"[bold green]✓ Configuration saved successfully![/bold green]\\n\\n"\n            f"Location: [cyan]{config_path}[/cyan]\\n\\n"\n            f"Next steps:\\n"\n            f"1. Review configuration: [bold]cat {config_path}[/bold]\\n"\n            f"2. Generate deployment: [bold]/mycelium-generate[/bold]\\n"\n            f"3. Start services: [bold]just up[/bold] or [bold]docker-compose up[/bold]",\n            border_style="green",\n            title="Success"\n        ))\n\n        return True, config_path\n\n    except Exception as e:\n        console.print(Panel(\n            f"[bold red]✗ Failed to save configuration[/bold red]\\n\\n"\n            f"Error: {e}\\n\\n"\n            f"Please check permissions and try again.",\n            border_style="red",\n            title="Error"\n        ))\n\n        return False, None\n\ndef resume_from_previous() -> Optional[MyceliumConfig]:\n    """\n    Attempt to load previous configuration for resume.\n\n    Returns:\n        Previous config if found, else None\n    """\n    try:\n        config = ConfigManager.load()\n\n        console.print(Panel(\n            f"[bold yellow]Previous configuration found![/bold yellow]\\n\\n"\n            f"Project: {config.project_name}\\n"\n            f"Deployment: {config.deployment.method}\\n\\n"\n            f"Would you like to resume or start fresh?",\n            border_style="yellow",\n            title="Resume Onboarding"\n        ))\n\n        from InquirerPy import inquirer\n        choice = inquirer.select(\n            message="Choose action:",\n            choices=["Resume", "Start Fresh", "Cancel"],\n        ).execute()\n\n        if choice == "Resume":\n            return config\n        elif choice == "Cancel":\n            return None\n\n        # Start fresh - return None\n        return None\n\n    except FileNotFoundError:\n        # No previous config - this is expected\n        return None'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_onboarding_milestones_M04_INTERACTIVE_ONBOARDING_6():
    """Test code snippet from projects/onboarding/milestones/M04_INTERACTIVE_ONBOARDING.md (line 636)."""
    code = '# mycelium_onboarding/cli.py\n"""CLI entry point for onboarding command."""\n\nimport asyncio\nimport click\nfrom rich.console import Console\n\nfrom mycelium_onboarding.wizard.integration import run_wizard_with_detection\nfrom mycelium_onboarding.wizard.persistence import save_configuration, resume_from_previous\n\nconsole = Console()\n\n@click.command()\n@click.option(\n    \'--project-local\',\n    is_flag=True,\n    help=\'Save configuration to project directory\'\n)\n@click.option(\n    \'--force\',\n    is_flag=True,\n    help=\'Skip resume prompt and start fresh\'\n)\n@click.option(\n    \'--no-cache\',\n    is_flag=True,\n    help=\'Re-run service detection\'\n)\n@click.option(\n    \'--non-interactive\',\n    is_flag=True,\n    help=\'Run in non-interactive mode using defaults\'\n)\ndef onboard(project_local: bool, force: bool, no_cache: bool, non_interactive: bool):\n    """Launch Mycelium onboarding wizard."""\n\n    # Check for resume unless --force\n    if not force and not non_interactive:\n        previous_config = resume_from_previous()\n        if previous_config is not None:\n            # User chose to cancel\n            return\n\n    # Run wizard\n    config = asyncio.run(run_wizard_with_detection(use_cache=not no_cache))\n\n    if config is None:\n        # User cancelled during wizard\n        console.print("[yellow]Onboarding cancelled.[/yellow]")\n        return\n\n    # Save configuration\n    success, config_path = save_configuration(config, project_local=project_local)\n\n    if not success:\n        raise click.ClickException("Failed to save configuration")\n\nif __name__ == \'__main__\':\n    onboard()'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_onboarding_milestones_M04_INTERACTIVE_ONBOARDING_7():
    """Test code snippet from projects/onboarding/milestones/M04_INTERACTIVE_ONBOARDING.md (line 713)."""
    code = '# tests/integration/test_wizard_flow.py\n"""Integration tests for complete wizard flow."""\n\nimport pytest\nfrom unittest.mock import patch, AsyncMock\nfrom mycelium_onboarding.wizard.integration import run_wizard_with_detection\n\n@pytest.mark.asyncio\nasync def test_complete_wizard_flow():\n    """Test complete wizard flow from detection to config."""\n\n    # Mock detection results\n    mock_detection = AsyncMock(return_value=mock_detection_results())\n\n    # Mock user inputs\n    mock_inputs = {\n        \'service_selection\': {\'redis\', \'temporal\'},\n        \'deployment_method\': \'docker-compose\',\n        \'project_name\': \'test-project\',\n        \'confirm\': True,\n    }\n\n    with patch(\'mycelium_onboarding.wizard.integration.detect_all_services\', mock_detection):\n        with patch_wizard_prompts(mock_inputs):\n            config = await run_wizard_with_detection()\n\n    assert config is not None\n    assert config.project_name == \'test-project\'\n    assert config.services.redis.enabled is True\n    assert config.services.temporal.enabled is True\n    assert config.deployment.method == \'docker-compose\'\n\n@pytest.mark.asyncio\nasync def test_wizard_handles_no_docker():\n    """Wizard should default to Justfile when Docker unavailable."""\n    mock_detection = AsyncMock(return_value=mock_detection_results(docker_available=False))\n\n    with patch(\'mycelium_onboarding.wizard.integration.detect_all_services\', mock_detection):\n        # ... run wizard ...\n        config = await run_wizard_with_detection()\n\n    assert config.deployment.method == \'justfile\'\n\ndef test_wizard_resume_functionality():\n    """Resume should load previous config and offer choices."""\n    # Create previous config\n    # Mock resume prompt\n    # Verify correct behavior\n    pass'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_onboarding_milestones_M05_DEPLOYMENT_GENERATION_1():
    """Test code snippet from projects/onboarding/milestones/M05_DEPLOYMENT_GENERATION.md (line 253)."""
    code = '# mycelium_onboarding/generators/docker_compose.py\n"""Docker Compose file generator."""\n\nfrom pathlib import Path\nfrom typing import Optional\nimport jinja2\nimport yaml\n\nfrom mycelium_onboarding.config.schema import MyceliumConfig\n\nclass DockerComposeGenerator:\n    """Generates Docker Compose configuration from MyceliumConfig."""\n\n    TEMPLATE_NAME = "docker-compose.yml.j2"\n\n    def __init__(self, template_dir: Optional[Path] = None):\n        if template_dir is None:\n            template_dir = Path(__file__).parent.parent / "templates"\n\n        self.env = jinja2.Environment(\n            loader=jinja2.FileSystemLoader(str(template_dir)),\n            autoescape=False,  # YAML doesn\'t need escaping\n            trim_blocks=True,\n            lstrip_blocks=True,\n        )\n\n    def generate(self, config: MyceliumConfig) -> str:\n        """\n        Generate Docker Compose YAML from configuration.\n\n        Args:\n            config: Mycelium configuration\n\n        Returns:\n            Docker Compose YAML content as string\n        """\n        template = self.env.get_template(self.TEMPLATE_NAME)\n\n        # Prepare context with version information\n        context = {\n            \'config\': config,\n            \'redis_version\': \'7-alpine\',\n            \'postgres_version\': \'16-alpine\',\n            \'temporal_version\': \'1.22.4\',\n        }\n\n        rendered = template.render(**context)\n\n        # Validate YAML syntax\n        try:\n            yaml.safe_load(rendered)\n        except yaml.YAMLError as e:\n            raise ValueError(f"Generated invalid YAML: {e}") from e\n\n        return rendered\n\n    def generate_to_file(\n        self,\n        config: MyceliumConfig,\n        output_path: Path,\n        overwrite: bool = False\n    ) -> Path:\n        """\n        Generate Docker Compose file to disk.\n\n        Args:\n            config: Mycelium configuration\n            output_path: Where to write docker-compose.yml\n            overwrite: If True, overwrite existing file\n\n        Returns:\n            Path to generated file\n\n        Raises:\n            FileExistsError: If file exists and overwrite=False\n        """\n        if output_path.exists() and not overwrite:\n            raise FileExistsError(\n                f"{output_path} already exists. Use overwrite=True to replace."\n            )\n\n        content = self.generate(config)\n\n        output_path.parent.mkdir(parents=True, exist_ok=True)\n        output_path.write_text(content)\n\n        return output_path\n\n    def generate_env_example(self, config: MyceliumConfig) -> str:\n        """\n        Generate .env.example file with documented variables.\n\n        Args:\n            config: Mycelium configuration\n\n        Returns:\n            .env file content\n        """\n        lines = [\n            "# Mycelium Environment Configuration",\n            "# Copy this file to .env and fill in your values",\n            "",\n        ]\n\n        if config.services.postgres.enabled:\n            lines.extend([\n                "# PostgreSQL Configuration",\n                "POSTGRES_USER=mycelium",\n                "POSTGRES_PASSWORD=<generate-secure-password>",\n                "POSTGRES_DB=mycelium",\n                "",\n            ])\n\n        if config.services.temporal.enabled:\n            lines.extend([\n                "# Temporal Configuration",\n                "# (Uses PostgreSQL credentials above)",\n                "",\n            ])\n\n        lines.extend([\n            "# Project Configuration",\n            f"PROJECT_NAME={config.project_name}",\n            "",\n        ])\n\n        return "\\n".join(lines)\n\ndef validate_docker_compose(compose_file: Path) -> tuple[bool, Optional[str]]:\n    """\n    Validate Docker Compose file using docker-compose config.\n\n    Args:\n        compose_file: Path to docker-compose.yml\n\n    Returns:\n        (is_valid, error_message) tuple\n    """\n    import subprocess\n\n    try:\n        result = subprocess.run(\n            [\'docker-compose\', \'-f\', str(compose_file), \'config\'],\n            capture_output=True,\n            text=True,\n            check=True,\n        )\n        return True, None\n    except subprocess.CalledProcessError as e:\n        return False, e.stderr\n    except FileNotFoundError:\n        # docker-compose not installed\n        return False, "docker-compose command not found"'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_onboarding_milestones_M05_DEPLOYMENT_GENERATION_2():
    """Test code snippet from projects/onboarding/milestones/M05_DEPLOYMENT_GENERATION.md (line 411)."""
    code = '# tests/test_docker_compose_generator.py\n"""Tests for Docker Compose generator."""\n\nimport pytest\nfrom pathlib import Path\nimport yaml\n\nfrom mycelium_onboarding.generators.docker_compose import DockerComposeGenerator\nfrom mycelium_onboarding.config.schema import MyceliumConfig\n\ndef test_generate_valid_yaml():\n    """Generated content should be valid YAML."""\n    config = MyceliumConfig()  # Default config\n    generator = DockerComposeGenerator()\n\n    content = generator.generate(config)\n\n    # Should parse without errors\n    parsed = yaml.safe_load(content)\n    assert \'version\' in parsed\n    assert \'services\' in parsed\n\ndef test_redis_service_included_when_enabled():\n    """Redis service should be included when enabled."""\n    config = MyceliumConfig()\n    config.services.redis.enabled = True\n\n    generator = DockerComposeGenerator()\n    content = generator.generate(config)\n    parsed = yaml.safe_load(content)\n\n    assert \'redis\' in parsed[\'services\']\n    assert parsed[\'services\'][\'redis\'][\'image\'].startswith(\'redis:\')\n\ndef test_healthchecks_included():\n    """All services should have healthchecks."""\n    config = MyceliumConfig()\n    config.services.redis.enabled = True\n    config.services.postgres.enabled = True\n\n    generator = DockerComposeGenerator()\n    content = generator.generate(config)\n    parsed = yaml.safe_load(content)\n\n    for service_name in [\'redis\', \'postgres\']:\n        assert \'healthcheck\' in parsed[\'services\'][service_name]\n        hc = parsed[\'services\'][service_name][\'healthcheck\']\n        assert \'test\' in hc\n        assert \'interval\' in hc\n        assert \'retries\' in hc\n\ndef test_volumes_created_for_persistence():\n    """Volumes should be created when persistence enabled."""\n    config = MyceliumConfig()\n    config.services.redis.enabled = True\n    config.services.redis.persistence = True\n\n    generator = DockerComposeGenerator()\n    content = generator.generate(config)\n    parsed = yaml.safe_load(content)\n\n    assert \'volumes\' in parsed\n    assert \'redis-data\' in parsed[\'volumes\']\n\ndef test_env_example_generation():\n    """Should generate .env.example with required variables."""\n    config = MyceliumConfig()\n    config.services.postgres.enabled = True\n\n    generator = DockerComposeGenerator()\n    env_content = generator.generate_env_example(config)\n\n    assert \'POSTGRES_USER\' in env_content\n    assert \'POSTGRES_PASSWORD\' in env_content\n    assert \'<generate-secure-password>\' in env_content'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_onboarding_milestones_M05_DEPLOYMENT_GENERATION_3():
    """Test code snippet from projects/onboarding/milestones/M05_DEPLOYMENT_GENERATION.md (line 506)."""
    code = '# mycelium_onboarding/generators/justfile.py\n"""Justfile generator for bare-metal deployments."""\n\nfrom pathlib import Path\nfrom typing import Optional\nimport jinja2\n\nfrom mycelium_onboarding.config.schema import MyceliumConfig\n\nclass JustfileGenerator:\n    """Generates Justfile configuration from MyceliumConfig."""\n\n    TEMPLATE_NAME = "Justfile.j2"\n\n    def __init__(self, template_dir: Optional[Path] = None):\n        if template_dir is None:\n            template_dir = Path(__file__).parent.parent / "templates"\n\n        self.env = jinja2.Environment(\n            loader=jinja2.FileSystemLoader(str(template_dir)),\n            autoescape=False,\n            trim_blocks=True,\n            lstrip_blocks=True,\n        )\n\n    def generate(self, config: MyceliumConfig) -> str:\n        """\n        Generate Justfile from configuration.\n\n        Args:\n            config: Mycelium configuration\n\n        Returns:\n            Justfile content as string\n        """\n        template = self.env.get_template(self.TEMPLATE_NAME)\n\n        context = {\n            \'config\': config,\n        }\n\n        rendered = template.render(**context)\n        return rendered\n\n    def generate_to_file(\n        self,\n        config: MyceliumConfig,\n        output_path: Path,\n        overwrite: bool = False\n    ) -> Path:\n        """\n        Generate Justfile to disk.\n\n        Args:\n            config: Mycelium configuration\n            output_path: Where to write Justfile\n            overwrite: If True, overwrite existing file\n\n        Returns:\n            Path to generated file\n\n        Raises:\n            FileExistsError: If file exists and overwrite=False\n        """\n        if output_path.exists() and not overwrite:\n            raise FileExistsError(\n                f"{output_path} already exists. Use overwrite=True to replace."\n            )\n\n        content = self.generate(config)\n\n        output_path.parent.mkdir(parents=True, exist_ok=True)\n        output_path.write_text(content)\n\n        # Make executable\n        output_path.chmod(0o755)\n\n        return output_path\n\n    def generate_service_scripts(self, config: MyceliumConfig, output_dir: Path) -> list[Path]:\n        """\n        Generate individual service management scripts.\n\n        For bare-metal deployments, create helper scripts for each service.\n\n        Args:\n            config: Mycelium configuration\n            output_dir: Directory for scripts\n\n        Returns:\n            List of generated script paths\n        """\n        scripts = []\n        output_dir.mkdir(parents=True, exist_ok=True)\n\n        if config.services.redis.enabled:\n            redis_script = output_dir / "start-redis.sh"\n            redis_script.write_text(self._generate_redis_script(config))\n            redis_script.chmod(0o755)\n            scripts.append(redis_script)\n\n        if config.services.postgres.enabled:\n            postgres_script = output_dir / "start-postgres.sh"\n            postgres_script.write_text(self._generate_postgres_script(config))\n            postgres_script.chmod(0o755)\n            scripts.append(postgres_script)\n\n        return scripts\n\n    def _generate_redis_script(self, config: MyceliumConfig) -> str:\n        """Generate standalone Redis startup script."""\n        return f"""#!/usr/bin/env bash\n# Redis startup script for Mycelium\n# Generated by: /mycelium-onboarding\n\nset -euo pipefail\n\nREDIS_PORT={config.services.redis.port}\nREDIS_CONF="${{XDG_CONFIG_HOME:-$HOME/.config}}/mycelium/redis.conf"\nREDIS_LOG="${{XDG_DATA_HOME:-$HOME/.local/share}}/mycelium/logs/redis.log"\n\nmkdir -p "$(dirname "$REDIS_LOG")"\n\nredis-server \\\\\n    --port "$REDIS_PORT" \\\\\n    {"--appendonly yes \\\\" if config.services.redis.persistence else ""}\\\\\n    --maxmemory {config.services.redis.max_memory} \\\\\n    --logfile "$REDIS_LOG" \\\\\n    --daemonize yes\n\nsleep 2\n\nif redis-cli -p "$REDIS_PORT" ping > /dev/null 2>&1; then\n    echo "✓ Redis started successfully on port $REDIS_PORT"\nelse\n    echo "✗ Redis failed to start. Check logs: $REDIS_LOG"\n    exit 1\nfi\n"""\n\n    def _generate_postgres_script(self, config: MyceliumConfig) -> str:\n        """Generate standalone PostgreSQL startup script."""\n        return f"""#!/usr/bin/env bash\n# PostgreSQL startup script for Mycelium\n# Generated by: /mycelium-onboarding\n\nset -euo pipefail\n\nPOSTGRES_PORT={config.services.postgres.port}\nPGDATA="${{XDG_DATA_HOME:-$HOME/.local/share}}/mycelium/postgres"\n\nif [ ! -d "$PGDATA" ]; then\n    echo "Initializing PostgreSQL data directory..."\n    initdb -D "$PGDATA"\nfi\n\npg_ctl -D "$PGDATA" -l "${{PGDATA}}/logfile" start\n\nsleep 3\n\nif pg_isready -p "$POSTGRES_PORT" > /dev/null 2>&1; then\n    echo "✓ PostgreSQL started successfully on port $POSTGRES_PORT"\nelse\n    echo "✗ PostgreSQL failed to start. Check logs: ${{PGDATA}}/logfile"\n    exit 1\nfi\n"""'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_onboarding_milestones_M05_DEPLOYMENT_GENERATION_4():
    """Test code snippet from projects/onboarding/milestones/M05_DEPLOYMENT_GENERATION.md (line 692)."""
    code = '# mycelium_onboarding/generators/secrets.py\n"""Secrets generation and management."""\n\nimport secrets\nimport string\nfrom pathlib import Path\nfrom typing import Optional\nimport os\n\ndef generate_password(length: int = 32, include_symbols: bool = True) -> str:\n    """\n    Generate cryptographically secure password.\n\n    Args:\n        length: Password length\n        include_symbols: Include special characters\n\n    Returns:\n        Generated password\n    """\n    alphabet = string.ascii_letters + string.digits\n    if include_symbols:\n        alphabet += "!@#$%^&*()_+-=[]{}|;:,.<>?"\n\n    password = \'\'.join(secrets.choice(alphabet) for _ in range(length))\n    return password\n\ndef generate_env_file(\n    config: \'MyceliumConfig\',\n    output_path: Path,\n    overwrite: bool = False\n) -> Path:\n    """\n    Generate .env file with secrets.\n\n    Args:\n        config: Mycelium configuration\n        output_path: Where to write .env file\n        overwrite: If True, overwrite existing file\n\n    Returns:\n        Path to generated .env file\n\n    Raises:\n        FileExistsError: If file exists and overwrite=False\n    """\n    if output_path.exists() and not overwrite:\n        raise FileExistsError(\n            f"{output_path} already exists. Use overwrite=True to replace."\n        )\n\n    lines = [\n        "# Mycelium Environment Configuration",\n        "# Generated by: /mycelium-generate",\n        "# IMPORTANT: Keep this file secure and never commit to version control",\n        "",\n    ]\n\n    if config.services.postgres.enabled:\n        lines.extend([\n            "# PostgreSQL Configuration",\n            f"POSTGRES_USER=mycelium",\n            f"POSTGRES_PASSWORD={generate_password(32, include_symbols=False)}",\n            f"POSTGRES_DB=mycelium",\n            "",\n        ])\n\n    if config.services.redis.enabled and config.services.redis.password_protected:\n        lines.extend([\n            "# Redis Configuration",\n            f"REDIS_PASSWORD={generate_password(32, include_symbols=False)}",\n            "",\n        ])\n\n    lines.extend([\n        "# Project Configuration",\n        f"PROJECT_NAME={config.project_name}",\n        f"MYCELIUM_ENV=development",\n        "",\n    ])\n\n    output_path.parent.mkdir(parents=True, exist_ok=True)\n    output_path.write_text("\\n".join(lines))\n\n    # Set restrictive permissions\n    output_path.chmod(0o600)\n\n    return output_path\n\ndef load_env_file(env_path: Path) -> dict[str, str]:\n    """\n    Load environment variables from .env file.\n\n    Args:\n        env_path: Path to .env file\n\n    Returns:\n        Dictionary of environment variables\n    """\n    env_vars = {}\n\n    if not env_path.exists():\n        return env_vars\n\n    for line in env_path.read_text().splitlines():\n        line = line.strip()\n\n        # Skip comments and empty lines\n        if not line or line.startswith(\'#\'):\n            continue\n\n        # Parse KEY=VALUE\n        if \'=\' in line:\n            key, value = line.split(\'=\', 1)\n            env_vars[key.strip()] = value.strip()\n\n    return env_vars\n\ndef update_env_var(env_path: Path, key: str, value: str) -> None:\n    """\n    Update or add environment variable in .env file.\n\n    Args:\n        env_path: Path to .env file\n        key: Environment variable name\n        value: Environment variable value\n    """\n    env_vars = load_env_file(env_path)\n    env_vars[key] = value\n\n    lines = [f"{k}={v}" for k, v in env_vars.items()]\n    env_path.write_text("\\n".join(lines) + "\\n")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_onboarding_milestones_M05_DEPLOYMENT_GENERATION_5():
    """Test code snippet from projects/onboarding/milestones/M05_DEPLOYMENT_GENERATION.md (line 942)."""
    code = '# mycelium_onboarding/cli/generate.py\n"""CLI command for deployment generation."""\n\nimport click\nfrom pathlib import Path\nfrom rich.console import Console\nfrom rich.panel import Panel\n\nfrom mycelium_onboarding.config.manager import ConfigManager\nfrom mycelium_onboarding.generators.docker_compose import DockerComposeGenerator\nfrom mycelium_onboarding.generators.justfile import JustfileGenerator\nfrom mycelium_onboarding.generators.secrets import generate_env_file\n\nconsole = Console()\n\n@click.command()\n@click.option(\n    \'--method\',\n    type=click.Choice([\'docker-compose\', \'justfile\'], case_sensitive=False),\n    help=\'Deployment method (auto-detected if not specified)\'\n)\n@click.option(\n    \'--output\',\n    type=click.Path(),\n    default=\'.\',\n    help=\'Output directory for generated files\'\n)\n@click.option(\n    \'--force\',\n    is_flag=True,\n    help=\'Overwrite existing files\'\n)\n@click.option(\n    \'--no-secrets\',\n    is_flag=True,\n    help=\'Skip .env file generation\'\n)\ndef generate(method: str, output: str, force: bool, no_secrets: bool):\n    """Generate deployment files from configuration."""\n\n    # Load configuration\n    try:\n        config = ConfigManager.load()\n    except FileNotFoundError:\n        console.print("[red]✗ No configuration found. Run /mycelium-onboarding first.[/red]")\n        raise click.Abort()\n\n    # Determine deployment method\n    if method is None:\n        method = config.deployment.method\n\n    output_dir = Path(output).resolve()\n    output_dir.mkdir(parents=True, exist_ok=True)\n\n    console.print(f"[cyan]Generating {method} deployment...[/cyan]\\n")\n\n    # Generate based on method\n    generated_files = []\n\n    if method == \'docker-compose\':\n        generator = DockerComposeGenerator()\n\n        compose_file = output_dir / \'docker-compose.yml\'\n        generator.generate_to_file(config, compose_file, overwrite=force)\n        generated_files.append(compose_file)\n\n        env_example = output_dir / \'.env.example\'\n        env_example.write_text(generator.generate_env_example(config))\n        generated_files.append(env_example)\n\n    elif method == \'justfile\':\n        generator = JustfileGenerator()\n\n        justfile = output_dir / \'Justfile\'\n        generator.generate_to_file(config, justfile, overwrite=force)\n        generated_files.append(justfile)\n\n        scripts = generator.generate_service_scripts(config, output_dir / \'bin\')\n        generated_files.extend(scripts)\n\n    # Generate .env file with secrets\n    if not no_secrets:\n        env_file = output_dir / \'.env\'\n        generate_env_file(config, env_file, overwrite=force)\n        generated_files.append(env_file)\n\n    # Show success message\n    console.print(Panel(\n        f"[bold green]✓ Deployment files generated![/bold green]\\n\\n"\n        f"Output directory: [cyan]{output_dir}[/cyan]\\n\\n"\n        f"Generated files:\\n" +\n        "\\n".join(f"  • {f.relative_to(output_dir)}" for f in generated_files) +\n        f"\\n\\nNext steps:\\n"\n        f"1. Review generated files\\n"\n        f"2. Start services: [bold]just up[/bold] or [bold]docker-compose up[/bold]\\n"\n        f"3. Test coordination: [bold]/mycelium-test[/bold]",\n        border_style="green"\n    ))\n\nif __name__ == \'__main__\':\n    generate()'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_onboarding_milestones_M06_COORDINATION_TESTING_1():
    """Test code snippet from projects/onboarding/milestones/M06_COORDINATION_TESTING.md (line 67)."""
    code = '# mycelium_testing/orchestrator.py\n"""Test orchestration framework for coordination patterns."""\n\nimport asyncio\nfrom dataclasses import dataclass, field\nfrom typing import Optional, Callable, Any\nfrom enum import Enum\nimport time\nimport logging\n\nlogger = logging.getLogger(__name__)\n\nclass TestStatus(str, Enum):\n    PENDING = "pending"\n    RUNNING = "running"\n    PASSED = "passed"\n    FAILED = "failed"\n    SKIPPED = "skipped"\n\n@dataclass\nclass TestResult:\n    """Result of a single test execution."""\n    test_name: str\n    status: TestStatus\n    duration_ms: float\n    error: Optional[str] = None\n    metrics: dict[str, Any] = field(default_factory=dict)\n    logs: list[str] = field(default_factory=list)\n\n@dataclass\nclass TestSuite:\n    """Collection of coordination tests."""\n    name: str\n    tests: list[Callable]\n    setup: Optional[Callable] = None\n    teardown: Optional[Callable] = None\n\nclass TestOrchestrator:\n    """\n    Orchestrates parallel test execution with resource management.\n\n    Features:\n    - Parallel test execution using asyncio TaskGroup\n    - Per-test timeout protection\n    - Resource cleanup on failure\n    - Metrics aggregation\n    - Deterministic seeding\n    """\n\n    def __init__(\n        self,\n        parallel_limit: int = 5,\n        default_timeout: float = 30.0,\n        seed: int = 42,\n    ):\n        self.parallel_limit = parallel_limit\n        self.default_timeout = default_timeout\n        self.seed = seed\n        self.results: list[TestResult] = []\n\n    async def run_suite(\n        self,\n        suite: TestSuite,\n        fail_fast: bool = False,\n    ) -> list[TestResult]:\n        """\n        Execute test suite with setup/teardown.\n\n        Args:\n            suite: Test suite to execute\n            fail_fast: Stop on first failure\n\n        Returns:\n            List of test results\n        """\n        logger.info(f"Running test suite: {suite.name}")\n\n        # Setup\n        if suite.setup:\n            try:\n                await suite.setup()\n            except Exception as e:\n                logger.error(f"Suite setup failed: {e}")\n                return [TestResult(\n                    test_name=f"{suite.name}::setup",\n                    status=TestStatus.FAILED,\n                    duration_ms=0,\n                    error=str(e),\n                )]\n\n        # Run tests in parallel with limit\n        try:\n            async with asyncio.TaskGroup() as tg:\n                semaphore = asyncio.Semaphore(self.parallel_limit)\n\n                for test_func in suite.tests:\n                    if fail_fast and any(r.status == TestStatus.FAILED for r in self.results):\n                        break\n\n                    tg.create_task(\n                        self._run_single_test(test_func, semaphore)\n                    )\n        except Exception as e:\n            logger.error(f"Test execution failed: {e}")\n\n        # Teardown\n        if suite.teardown:\n            try:\n                await suite.teardown()\n            except Exception as e:\n                logger.error(f"Suite teardown failed: {e}")\n\n        return self.results\n\n    async def _run_single_test(\n        self,\n        test_func: Callable,\n        semaphore: asyncio.Semaphore,\n    ) -> TestResult:\n        """Execute single test with timeout and error handling."""\n        test_name = test_func.__name__\n\n        async with semaphore:\n            logger.info(f"Starting test: {test_name}")\n            start_time = time.perf_counter()\n\n            try:\n                # Run test with timeout\n                async with asyncio.timeout(self.default_timeout):\n                    result = await test_func()\n\n                duration_ms = (time.perf_counter() - start_time) * 1000\n\n                test_result = TestResult(\n                    test_name=test_name,\n                    status=TestStatus.PASSED,\n                    duration_ms=duration_ms,\n                    metrics=result.get(\'metrics\', {}) if isinstance(result, dict) else {},\n                )\n\n                logger.info(f"✓ {test_name} passed ({duration_ms:.2f}ms)")\n\n            except asyncio.TimeoutError:\n                duration_ms = (time.perf_counter() - start_time) * 1000\n                test_result = TestResult(\n                    test_name=test_name,\n                    status=TestStatus.FAILED,\n                    duration_ms=duration_ms,\n                    error=f"Test timeout after {self.default_timeout}s",\n                )\n                logger.error(f"✗ {test_name} timeout")\n\n            except Exception as e:\n                duration_ms = (time.perf_counter() - start_time) * 1000\n                test_result = TestResult(\n                    test_name=test_name,\n                    status=TestStatus.FAILED,\n                    duration_ms=duration_ms,\n                    error=str(e),\n                )\n                logger.error(f"✗ {test_name} failed: {e}")\n\n            self.results.append(test_result)\n            return test_result\n\n    def generate_report(self) -> str:\n        """Generate human-readable test report."""\n        total = len(self.results)\n        passed = sum(1 for r in self.results if r.status == TestStatus.PASSED)\n        failed = sum(1 for r in self.results if r.status == TestStatus.FAILED)\n\n        lines = [\n            "=" * 60,\n            "COORDINATION TEST REPORT",\n            "=" * 60,\n            f"Total Tests: {total}",\n            f"Passed: {passed}",\n            f"Failed: {failed}",\n            f"Success Rate: {(passed/total*100) if total > 0 else 0:.1f}%",\n            "",\n            "Test Details:",\n            "-" * 60,\n        ]\n\n        for result in self.results:\n            status_icon = "✓" if result.status == TestStatus.PASSED else "✗"\n            lines.append(\n                f"{status_icon} {result.test_name}: {result.status.value} "\n                f"({result.duration_ms:.2f}ms)"\n            )\n            if result.error:\n                lines.append(f"   Error: {result.error}")\n\n        lines.append("=" * 60)\n        return "\\n".join(lines)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_onboarding_milestones_M06_COORDINATION_TESTING_2():
    """Test code snippet from projects/onboarding/milestones/M06_COORDINATION_TESTING.md (line 281)."""
    code = '# tests/fixtures/mcp_clients.py\n"""Pytest fixtures for MCP client management."""\n\nimport pytest\nimport asyncio\nimport os\nfrom typing import AsyncGenerator\nfrom unittest.mock import AsyncMock\n\n# Real MCP client imports\ntry:\n    from mcp_redis import RedisClient\n    from mcp_taskqueue import TaskQueueClient\n    from mcp_temporal import TemporalClient\n    HAS_REAL_MCP = True\nexcept ImportError:\n    HAS_REAL_MCP = False\n\nUSE_MOCK_MCP = os.getenv(\'USE_MOCK_MCP\', \'false\').lower() == \'true\'\n\n@pytest.fixture\nasync def redis_client() -> AsyncGenerator:\n    """\n    Provide Redis MCP client (mock or real based on environment).\n\n    Set USE_MOCK_MCP=true to use mocks during development.\n    """\n    if USE_MOCK_MCP or not HAS_REAL_MCP:\n        # Mock Redis client for development\n        mock_client = AsyncMock()\n        mock_client.publish = AsyncMock(return_value=1)\n        mock_client.subscribe = AsyncMock()\n        mock_client.get = AsyncMock(return_value=None)\n        mock_client.set = AsyncMock(return_value=True)\n\n        yield mock_client\n    else:\n        # Real Redis client for CI/CD\n        client = RedisClient(\n            host=os.getenv(\'REDIS_HOST\', \'localhost\'),\n            port=int(os.getenv(\'REDIS_PORT\', 6379)),\n        )\n\n        await client.connect()\n\n        try:\n            yield client\n        finally:\n            await client.disconnect()\n\n@pytest.fixture\nasync def taskqueue_client() -> AsyncGenerator:\n    """\n    Provide TaskQueue MCP client (mock or real based on environment).\n    """\n    if USE_MOCK_MCP or not HAS_REAL_MCP:\n        # Mock TaskQueue client\n        mock_client = AsyncMock()\n        mock_client.create_project = AsyncMock(return_value={\'project_id\': \'proj-test-1\'})\n        mock_client.add_task = AsyncMock(return_value={\'task_id\': \'task-test-1\'})\n        mock_client.get_next_task = AsyncMock(return_value=None)\n\n        yield mock_client\n    else:\n        # Real TaskQueue client\n        client = TaskQueueClient()\n\n        await client.connect()\n\n        try:\n            yield client\n        finally:\n            await client.disconnect()\n\n@pytest.fixture\nasync def temporal_client() -> AsyncGenerator:\n    """\n    Provide Temporal MCP client (mock or real based on environment).\n    """\n    if USE_MOCK_MCP or not HAS_REAL_MCP:\n        # Mock Temporal client\n        mock_client = AsyncMock()\n        mock_client.start_workflow = AsyncMock(return_value={\'workflow_id\': \'wf-test-1\'})\n        mock_client.get_workflow_status = AsyncMock(return_value={\'status\': \'COMPLETED\'})\n\n        yield mock_client\n    else:\n        # Real Temporal client\n        client = TemporalClient(\n            host=os.getenv(\'TEMPORAL_HOST\', \'localhost\'),\n            port=int(os.getenv(\'TEMPORAL_PORT\', 7233)),\n        )\n\n        await client.connect()\n\n        try:\n            yield client\n        finally:\n            await client.disconnect()\n\n@pytest.fixture\nasync def mcp_clients(\n    redis_client,\n    taskqueue_client,\n    temporal_client,\n) -> dict:\n    """Provide all MCP clients as dictionary."""\n    return {\n        \'redis\': redis_client,\n        \'taskqueue\': taskqueue_client,\n        \'temporal\': temporal_client,\n    }\n\n@pytest.fixture(autouse=True)\nasync def cleanup_test_data(mcp_clients):\n    """Automatically cleanup test data after each test."""\n    yield\n\n    # Cleanup Redis test keys\n    if not USE_MOCK_MCP and HAS_REAL_MCP:\n        redis = mcp_clients[\'redis\']\n        test_keys = await redis.keys(\'test:*\')\n        if test_keys:\n            await redis.delete(*test_keys)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_onboarding_milestones_M06_COORDINATION_TESTING_3():
    """Test code snippet from projects/onboarding/milestones/M06_COORDINATION_TESTING.md (line 423)."""
    code = '# tests/functional/test_coordination_patterns.py\n"""Functional tests for coordination patterns."""\n\nimport pytest\nimport asyncio\nfrom typing import Any\n\npytestmark = pytest.mark.asyncio\n\n# ==================== PUB/SUB PATTERN ====================\n\nasync def test_pubsub_basic_message_delivery(redis_client):\n    """Test basic pub/sub message delivery."""\n    channel = "test:coordination:pubsub"\n    message = "Hello from agent-1"\n\n    # Subscribe to channel\n    pubsub = await redis_client.subscribe(channel)\n\n    # Publish message\n    await redis_client.publish(channel, message)\n\n    # Receive message\n    received = await asyncio.wait_for(pubsub.get_message(), timeout=5.0)\n\n    assert received is not None\n    assert received[\'data\'] == message\n\nasync def test_pubsub_multiple_subscribers(redis_client):\n    """Test pub/sub with multiple subscribers."""\n    channel = "test:coordination:multi_sub"\n    message = "Broadcast message"\n\n    # Create 3 subscribers\n    subscribers = [\n        await redis_client.subscribe(channel)\n        for _ in range(3)\n    ]\n\n    # Publish once\n    await redis_client.publish(channel, message)\n\n    # All subscribers should receive\n    for sub in subscribers:\n        received = await asyncio.wait_for(sub.get_message(), timeout=5.0)\n        assert received[\'data\'] == message\n\n# ==================== TASK QUEUE PATTERN ====================\n\nasync def test_task_queue_distribution(taskqueue_client):\n    """Test task distribution across agents."""\n    # Create project\n    project = await taskqueue_client.create_project(\n        name="test-project",\n        description="Coordination test"\n    )\n    project_id = project[\'project_id\']\n\n    # Add 5 tasks\n    tasks = []\n    for i in range(5):\n        task = await taskqueue_client.add_task(\n            project_id=project_id,\n            title=f"Task {i}",\n            description=f"Test task {i}"\n        )\n        tasks.append(task)\n\n    # Simulate 3 agents retrieving tasks\n    retrieved = []\n    for agent_id in range(3):\n        task = await taskqueue_client.get_next_task(project_id)\n        if task:\n            retrieved.append(task)\n            await taskqueue_client.update_task(\n                project_id=project_id,\n                task_id=task[\'task_id\'],\n                status=\'in_progress\'\n            )\n\n    # Should retrieve 3 tasks (one per agent)\n    assert len(retrieved) == 3\n\n    # All should be different tasks\n    task_ids = {t[\'task_id\'] for t in retrieved}\n    assert len(task_ids) == 3\n\nasync def test_task_queue_completion_flow(taskqueue_client):\n    """Test complete task lifecycle."""\n    project = await taskqueue_client.create_project(name="test-completion")\n    project_id = project[\'project_id\']\n\n    # Add task\n    task = await taskqueue_client.add_task(\n        project_id=project_id,\n        title="Complete me",\n        description="Test completion"\n    )\n    task_id = task[\'task_id\']\n\n    # Get task\n    retrieved = await taskqueue_client.get_next_task(project_id)\n    assert retrieved[\'task_id\'] == task_id\n    assert retrieved[\'status\'] == \'pending\'\n\n    # Mark in progress\n    await taskqueue_client.update_task(\n        project_id=project_id,\n        task_id=task_id,\n        status=\'in_progress\'\n    )\n\n    # Complete task\n    await taskqueue_client.update_task(\n        project_id=project_id,\n        task_id=task_id,\n        status=\'done\',\n        completed_details=\'Task finished successfully\'\n    )\n\n    # Verify status\n    task_status = await taskqueue_client.get_task(project_id, task_id)\n    assert task_status[\'status\'] == \'done\'\n\n# ==================== REQUEST-REPLY PATTERN ====================\n\nasync def test_request_reply_pattern(redis_client):\n    """Test request-reply coordination."""\n    request_channel = "test:requests"\n    reply_channel = "test:replies"\n\n    # Subscriber (responder)\n    async def responder():\n        pubsub = await redis_client.subscribe(request_channel)\n        msg = await pubsub.get_message()\n        request_id = msg[\'data\']\n\n        # Send reply\n        await redis_client.publish(reply_channel, f"reply-{request_id}")\n\n    # Start responder\n    responder_task = asyncio.create_task(responder())\n\n    # Requester\n    request_id = "req-12345"\n    reply_sub = await redis_client.subscribe(reply_channel)\n\n    # Send request\n    await redis_client.publish(request_channel, request_id)\n\n    # Wait for reply\n    reply = await asyncio.wait_for(reply_sub.get_message(), timeout=5.0)\n\n    assert reply[\'data\'] == f"reply-{request_id}"\n    await responder_task\n\n# ==================== SCATTER-GATHER PATTERN ====================\n\nasync def test_scatter_gather_pattern(redis_client):\n    """Test scatter-gather coordination."""\n    scatter_channel = "test:scatter"\n    gather_channel = "test:gather"\n\n    num_workers = 5\n\n    # Workers (process and reply)\n    async def worker(worker_id: int):\n        pubsub = await redis_client.subscribe(scatter_channel)\n        msg = await pubsub.get_message()\n        task_id = msg[\'data\']\n\n        # Simulate work\n        await asyncio.sleep(0.1)\n\n        # Send result\n        await redis_client.publish(gather_channel, f"result-{worker_id}-{task_id}")\n\n    # Start workers\n    worker_tasks = [asyncio.create_task(worker(i)) for i in range(num_workers)]\n\n    # Coordinator\n    gather_sub = await redis_client.subscribe(gather_channel)\n\n    # Scatter task\n    task_id = "task-xyz"\n    await redis_client.publish(scatter_channel, task_id)\n\n    # Gather results\n    results = []\n    for _ in range(num_workers):\n        result = await asyncio.wait_for(gather_sub.get_message(), timeout=10.0)\n        results.append(result[\'data\'])\n\n    # Verify all workers responded\n    assert len(results) == num_workers\n    assert all(task_id in r for r in results)\n\n    await asyncio.gather(*worker_tasks)\n\n# ==================== BARRIER SYNCHRONIZATION ====================\n\nasync def test_barrier_synchronization(redis_client):\n    """Test barrier synchronization pattern."""\n    barrier_key = "test:barrier:sync"\n    num_agents = 4\n\n    # Agents wait at barrier\n    async def agent(agent_id: int):\n        # Increment barrier counter\n        count = await redis_client.incr(barrier_key)\n\n        # Wait until all agents reach barrier\n        while True:\n            current = await redis_client.get(barrier_key)\n            if int(current) >= num_agents:\n                break\n            await asyncio.sleep(0.05)\n\n        return agent_id\n\n    # Run all agents\n    results = await asyncio.gather(*[agent(i) for i in range(num_agents)])\n\n    # All agents should complete\n    assert len(results) == num_agents\n    assert set(results) == set(range(num_agents))\n\n# ==================== CIRCUIT BREAKER PATTERN ====================\n\nasync def test_circuit_breaker_pattern(redis_client):\n    """Test circuit breaker for fault tolerance."""\n    service_key = "test:circuit_breaker:failures"\n    threshold = 3\n\n    # Simulate service failures\n    for _ in range(threshold):\n        await redis_client.incr(service_key)\n\n    failure_count = int(await redis_client.get(service_key))\n\n    # Circuit should be open (too many failures)\n    assert failure_count >= threshold\n\n    # Reset after timeout\n    await redis_client.delete(service_key)\n    failure_count = await redis_client.get(service_key)\n\n    # Circuit should be closed\n    assert failure_count is None or int(failure_count) == 0'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_onboarding_milestones_M06_COORDINATION_TESTING_4():
    """Test code snippet from projects/onboarding/milestones/M06_COORDINATION_TESTING.md (line 698)."""
    code = '# mycelium_testing/failure_injection.py\n"""Failure injection for coordination testing."""\n\nimport asyncio\nimport random\nfrom typing import Callable, Any\nfrom functools import wraps\n\nclass FailureInjector:\n    """Inject failures into coordination operations."""\n\n    def __init__(self, seed: int = 42):\n        self.random = random.Random(seed)\n\n    def inject_delay(\n        self,\n        min_ms: float = 10,\n        max_ms: float = 100,\n        probability: float = 0.3,\n    ):\n        """\n        Decorator to inject random delays.\n\n        Args:\n            min_ms: Minimum delay in milliseconds\n            max_ms: Maximum delay in milliseconds\n            probability: Probability of delay injection (0-1)\n        """\n        def decorator(func: Callable) -> Callable:\n            @wraps(func)\n            async def wrapper(*args, **kwargs):\n                if self.random.random() < probability:\n                    delay_ms = self.random.uniform(min_ms, max_ms)\n                    await asyncio.sleep(delay_ms / 1000)\n\n                return await func(*args, **kwargs)\n\n            return wrapper\n        return decorator\n\n    def inject_timeout(\n        self,\n        probability: float = 0.1,\n    ):\n        """Inject timeout errors."""\n        def decorator(func: Callable) -> Callable:\n            @wraps(func)\n            async def wrapper(*args, **kwargs):\n                if self.random.random() < probability:\n                    raise asyncio.TimeoutError("Injected timeout")\n\n                return await func(*args, **kwargs)\n\n            return wrapper\n        return decorator\n\n    def inject_error(\n        self,\n        error_type: type = Exception,\n        probability: float = 0.05,\n        message: str = "Injected error",\n    ):\n        """Inject arbitrary errors."""\n        def decorator(func: Callable) -> Callable:\n            @wraps(func)\n            async def wrapper(*args, **kwargs):\n                if self.random.random() < probability:\n                    raise error_type(message)\n\n                return await func(*args, **kwargs)\n\n            return wrapper\n        return decorator\n\n# mycelium_testing/metrics.py\n"""Metrics collection for coordination tests."""\n\nimport time\nfrom dataclasses import dataclass, field\nfrom typing import Optional\nfrom collections import defaultdict\n\n@dataclass\nclass MetricsCollector:\n    """Collect and aggregate test metrics."""\n\n    latencies: dict[str, list[float]] = field(default_factory=lambda: defaultdict(list))\n    throughput: dict[str, int] = field(default_factory=lambda: defaultdict(int))\n    errors: dict[str, int] = field(default_factory=lambda: defaultdict(int))\n\n    def record_latency(self, operation: str, latency_ms: float) -> None:\n        """Record operation latency."""\n        self.latencies[operation].append(latency_ms)\n\n    def record_throughput(self, operation: str, count: int = 1) -> None:\n        """Record successful operations."""\n        self.throughput[operation] += count\n\n    def record_error(self, operation: str, count: int = 1) -> None:\n        """Record errors."""\n        self.errors[operation] += count\n\n    def get_stats(self, operation: str) -> dict:\n        """Get statistics for operation."""\n        latencies = self.latencies.get(operation, [])\n\n        if not latencies:\n            return {}\n\n        return {\n            \'count\': len(latencies),\n            \'min_ms\': min(latencies),\n            \'max_ms\': max(latencies),\n            \'avg_ms\': sum(latencies) / len(latencies),\n            \'p50_ms\': self._percentile(latencies, 0.5),\n            \'p95_ms\': self._percentile(latencies, 0.95),\n            \'p99_ms\': self._percentile(latencies, 0.99),\n            \'throughput\': self.throughput.get(operation, 0),\n            \'errors\': self.errors.get(operation, 0),\n        }\n\n    @staticmethod\n    def _percentile(data: list[float], percentile: float) -> float:\n        """Calculate percentile."""\n        sorted_data = sorted(data)\n        index = int(len(sorted_data) * percentile)\n        return sorted_data[min(index, len(sorted_data) - 1)]\n\n    def generate_report(self) -> str:\n        """Generate metrics report."""\n        lines = ["METRICS REPORT", "=" * 60]\n\n        for operation in sorted(self.latencies.keys()):\n            stats = self.get_stats(operation)\n            lines.extend([\n                f"\\n{operation}:",\n                f"  Count: {stats[\'count\']}",\n                f"  Latency (ms): min={stats[\'min_ms\']:.2f}, avg={stats[\'avg_ms\']:.2f}, max={stats[\'max_ms\']:.2f}",\n                f"  Percentiles (ms): p50={stats[\'p50_ms\']:.2f}, p95={stats[\'p95_ms\']:.2f}, p99={stats[\'p99_ms\']:.2f}",\n                f"  Throughput: {stats[\'throughput\']} ops",\n                f"  Errors: {stats[\'errors\']}",\n            ])\n\n        return "\\n".join(lines)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_onboarding_milestones_M06_COORDINATION_TESTING_5():
    """Test code snippet from projects/onboarding/milestones/M06_COORDINATION_TESTING.md (line 847)."""
    code = '# tests/functional/test_with_failures.py\n"""Tests with failure injection."""\n\nimport pytest\nfrom mycelium_testing.failure_injection import FailureInjector\nfrom mycelium_testing.metrics import MetricsCollector\n\npytestmark = pytest.mark.asyncio\n\n@pytest.fixture\ndef failure_injector():\n    return FailureInjector(seed=42)\n\n@pytest.fixture\ndef metrics():\n    return MetricsCollector()\n\nasync def test_pubsub_with_network_delays(redis_client, failure_injector, metrics):\n    """Test pub/sub resilience to network delays."""\n    channel = "test:delays"\n\n    # Wrap publish with delay injection\n    original_publish = redis_client.publish\n    redis_client.publish = failure_injector.inject_delay(\n        min_ms=50,\n        max_ms=200,\n        probability=0.5,\n    )(original_publish)\n\n    # Measure latency\n    import time\n    for i in range(10):\n        start = time.perf_counter()\n        await redis_client.publish(channel, f"msg-{i}")\n        latency_ms = (time.perf_counter() - start) * 1000\n\n        metrics.record_latency("publish", latency_ms)\n        metrics.record_throughput("publish")\n\n    # Verify metrics\n    stats = metrics.get_stats("publish")\n    assert stats[\'count\'] == 10\n    assert stats[\'avg_ms\'] > 0  # Some operations were delayed'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_onboarding_milestones_M06_COORDINATION_TESTING_6():
    """Test code snippet from projects/onboarding/milestones/M06_COORDINATION_TESTING.md (line 983)."""
    code = '# mycelium_onboarding/cli/test.py\n"""CLI command for coordination testing."""\n\nimport click\nimport asyncio\nimport os\nfrom rich.console import Console\n\nfrom mycelium_testing.orchestrator import TestOrchestrator, TestSuite\nfrom tests.functional import test_coordination_patterns\n\nconsole = Console()\n\n@click.command()\n@click.option(\n    \'--pattern\',\n    type=click.Choice([\'pubsub\', \'taskqueue\', \'request-reply\', \'scatter-gather\', \'barrier\', \'circuit-breaker\', \'all\']),\n    default=\'all\',\n    help=\'Test pattern to run\'\n)\n@click.option(\'--mock\', is_flag=True, help=\'Use mock MCP servers\')\n@click.option(\'--verbose\', is_flag=True, help=\'Verbose output\')\n@click.option(\'--report\', is_flag=True, help=\'Generate metrics report\')\n@click.option(\'--fail-fast\', is_flag=True, help=\'Stop on first failure\')\ndef test(pattern: str, mock: bool, verbose: bool, report: bool, fail_fast: bool):\n    """Run coordination pattern tests."""\n\n    # Set mock mode\n    if mock:\n        os.environ[\'USE_MOCK_MCP\'] = \'true\'\n\n    console.print(f"[cyan]Running {pattern} tests...[/cyan]\\n")\n\n    # Create test suite\n    suite = TestSuite(\n        name=f"coordination-{pattern}",\n        tests=_get_tests_for_pattern(pattern),\n    )\n\n    # Run tests\n    orchestrator = TestOrchestrator()\n    results = asyncio.run(orchestrator.run_suite(suite, fail_fast=fail_fast))\n\n    # Show report\n    console.print(orchestrator.generate_report())\n\n    if report:\n        # Generate metrics report if requested\n        console.print("\\n" + metrics.generate_report())\n\n    # Exit with appropriate code\n    failed = sum(1 for r in results if r.status == \'failed\')\n    if failed > 0:\n        raise click.ClickException(f"{failed} tests failed")\n\ndef _get_tests_for_pattern(pattern: str) -> list:\n    """Get test functions for pattern."""\n    # Import test module and filter by pattern\n    import tests.functional.test_coordination_patterns as tests_module\n\n    if pattern == \'all\':\n        return [\n            getattr(tests_module, name)\n            for name in dir(tests_module)\n            if name.startswith(\'test_\')\n        ]\n    else:\n        pattern_prefix = f"test_{pattern.replace(\'-\', \'_\')}"\n        return [\n            getattr(tests_module, name)\n            for name in dir(tests_module)\n            if name.startswith(pattern_prefix)\n        ]\n\nif __name__ == \'__main__\':\n    test()'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_onboarding_milestones_M07_CONFIGURATION_MANAGEMENT_1():
    """Test code snippet from projects/onboarding/milestones/M07_CONFIGURATION_MANAGEMENT.md (line 64)."""
    code = '# mycelium_onboarding/cli/config.py\n"""Configuration management CLI commands."""\n\nimport click\nfrom pathlib import Path\nfrom rich.console import Console\nfrom rich.syntax import Syntax\nfrom rich.table import Table\nfrom rich.panel import Panel\nimport yaml\nimport json\n\nfrom mycelium_onboarding.config.manager import ConfigManager\nfrom mycelium_onboarding.config.schema import MyceliumConfig\n\nconsole = Console()\n\n@click.group()\ndef config():\n    """Manage Mycelium configuration."""\n    pass\n\n@config.command()\n@click.option(\n    \'--format\',\n    type=click.Choice([\'yaml\', \'json\', \'table\'], case_sensitive=False),\n    default=\'table\',\n    help=\'Output format\'\n)\n@click.option(\n    \'--path\',\n    is_flag=True,\n    help=\'Show configuration file path\'\n)\n@click.option(\n    \'--project\',\n    is_flag=True,\n    help=\'Use project-local configuration\'\n)\ndef show(format: str, path: bool, project: bool):\n    """Display current configuration."""\n\n    try:\n        # Load configuration\n        config = ConfigManager.load(prefer_project=project)\n        config_path = ConfigManager.get_config_path(prefer_project=project)\n\n        if path:\n            # Just show path\n            console.print(f"[cyan]{config_path}[/cyan]")\n            return\n\n        # Display based on format\n        if format == \'table\':\n            _show_table_format(config)\n        elif format == \'yaml\':\n            _show_yaml_format(config)\n        elif format == \'json\':\n            _show_json_format(config)\n\n        # Show file location\n        console.print(f"\\n[dim]Configuration: {config_path}[/dim]")\n\n    except FileNotFoundError:\n        console.print("[yellow]⚠ No configuration found. Run /mycelium-onboarding to create one.[/yellow]")\n        raise click.Abort()\n\ndef _show_table_format(config: MyceliumConfig):\n    """Display configuration as formatted table."""\n\n    # Project Info\n    table = Table(title="Project Configuration", show_header=False)\n    table.add_column("Setting", style="cyan")\n    table.add_column("Value", style="white")\n\n    table.add_row("Project Name", config.project_name)\n    table.add_row("Deployment Method", config.deployment.method)\n\n    console.print(table)\n    console.print()\n\n    # Services\n    table = Table(title="Enabled Services")\n    table.add_column("Service", style="cyan")\n    table.add_column("Status", style="green")\n    table.add_column("Configuration", style="white")\n\n    if config.services.redis.enabled:\n        table.add_row(\n            "Redis",\n            "✓ Enabled",\n            f"Port: {config.services.redis.port}, Persistence: {config.services.redis.persistence}"\n        )\n\n    if config.services.postgres.enabled:\n        table.add_row(\n            "PostgreSQL",\n            "✓ Enabled",\n            f"Port: {config.services.postgres.port}"\n        )\n\n    if config.services.temporal.enabled:\n        table.add_row(\n            "Temporal",\n            "✓ Enabled",\n            f"Port: {config.services.temporal.frontend_port}"\n        )\n\n    if config.services.taskqueue.enabled:\n        table.add_row(\n            "TaskQueue",\n            "✓ Enabled",\n            "MCP Server"\n        )\n\n    console.print(table)\n\ndef _show_yaml_format(config: MyceliumConfig):\n    """Display configuration as YAML with syntax highlighting."""\n    config_dict = config.model_dump()\n\n    # Mask sensitive data\n    config_dict = _mask_sensitive_data(config_dict)\n\n    yaml_str = yaml.dump(config_dict, default_flow_style=False, sort_keys=False)\n\n    syntax = Syntax(yaml_str, "yaml", theme="monokai", line_numbers=False)\n    console.print(syntax)\n\ndef _show_json_format(config: MyceliumConfig):\n    """Display configuration as JSON."""\n    config_dict = config.model_dump()\n\n    # Mask sensitive data\n    config_dict = _mask_sensitive_data(config_dict)\n\n    json_str = json.dumps(config_dict, indent=2)\n\n    syntax = Syntax(json_str, "json", theme="monokai", line_numbers=False)\n    console.print(syntax)\n\ndef _mask_sensitive_data(config_dict: dict) -> dict:\n    """Mask sensitive values like passwords."""\n    sensitive_keys = {\'password\', \'secret\', \'api_key\', \'token\'}\n\n    def mask_recursive(obj):\n        if isinstance(obj, dict):\n            return {\n                k: "***REDACTED***" if any(s in k.lower() for s in sensitive_keys) else mask_recursive(v)\n                for k, v in obj.items()\n            }\n        elif isinstance(obj, list):\n            return [mask_recursive(item) for item in obj]\n        else:\n            return obj\n\n    return mask_recursive(config_dict)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_onboarding_milestones_M07_CONFIGURATION_MANAGEMENT_2():
    """Test code snippet from projects/onboarding/milestones/M07_CONFIGURATION_MANAGEMENT.md (line 226)."""
    code = '# tests/test_config_show.py\n"""Tests for config show command."""\n\nimport pytest\nfrom click.testing import CliRunner\nfrom mycelium_onboarding.cli.config import show\n\ndef test_show_table_format(tmp_config):\n    """Show command should display table format."""\n    runner = CliRunner()\n    result = runner.invoke(show, [\'--format\', \'table\'])\n\n    assert result.exit_code == 0\n    assert \'Project Configuration\' in result.output\n\ndef test_show_yaml_format(tmp_config):\n    """Show command should display YAML format."""\n    runner = CliRunner()\n    result = runner.invoke(show, [\'--format\', \'yaml\'])\n\n    assert result.exit_code == 0\n    assert \'project_name:\' in result.output\n\ndef test_show_masks_sensitive_data(tmp_config_with_password):\n    """Sensitive data should be masked."""\n    runner = CliRunner()\n    result = runner.invoke(show, [\'--format\', \'yaml\'])\n\n    assert \'***REDACTED***\' in result.output\n    assert \'actual_password\' not in result.output\n\ndef test_show_path_only():\n    """Show --path should only display config path."""\n    runner = CliRunner()\n    result = runner.invoke(show, [\'--path\'])\n\n    assert result.exit_code == 0\n    assert \'mycelium.yaml\' in result.output'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_onboarding_milestones_M07_CONFIGURATION_MANAGEMENT_3():
    """Test code snippet from projects/onboarding/milestones/M07_CONFIGURATION_MANAGEMENT.md (line 283)."""
    code = '# mycelium_onboarding/cli/config.py (continued)\n\nimport subprocess\nimport os\nimport tempfile\n\n@config.command()\n@click.option(\n    \'--project\',\n    is_flag=True,\n    help=\'Edit project-local configuration\'\n)\n@click.option(\n    \'--editor\',\n    envvar=\'EDITOR\',\n    default=\'nano\',\n    help=\'Editor to use (default: $EDITOR or nano)\'\n)\ndef edit(project: bool, editor: str):\n    """Edit configuration in your preferred editor."""\n\n    try:\n        # Load current configuration\n        config = ConfigManager.load(prefer_project=project)\n        config_path = ConfigManager.get_config_path(prefer_project=project)\n\n    except FileNotFoundError:\n        console.print("[yellow]⚠ No configuration found. Creating new one...[/yellow]")\n        config = MyceliumConfig()\n        config_path = ConfigManager.get_config_path(prefer_project=project)\n        config_path.parent.mkdir(parents=True, exist_ok=True)\n\n    # Write to temporary file\n    with tempfile.NamedTemporaryFile(mode=\'w\', suffix=\'.yaml\', delete=False) as tmp:\n        tmp_path = Path(tmp.name)\n        yaml_content = yaml.dump(\n            config.model_dump(),\n            default_flow_style=False,\n            sort_keys=False\n        )\n        tmp.write(yaml_content)\n\n    # Open in editor\n    try:\n        subprocess.run([editor, str(tmp_path)], check=True)\n\n    except subprocess.CalledProcessError:\n        console.print(f"[red]✗ Editor \'{editor}\' failed[/red]")\n        tmp_path.unlink()\n        raise click.Abort()\n\n    except FileNotFoundError:\n        console.print(f"[red]✗ Editor \'{editor}\' not found[/red]")\n        console.print(f"[dim]Set EDITOR environment variable or use --editor[/dim]")\n        tmp_path.unlink()\n        raise click.Abort()\n\n    # Load edited content\n    try:\n        edited_yaml = tmp_path.read_text()\n        edited_dict = yaml.safe_load(edited_yaml)\n\n        # Validate\n        edited_config = MyceliumConfig(**edited_dict)\n\n        # Save if valid\n        ConfigManager.save(edited_config, project_local=project)\n\n        console.print(f"[green]✓ Configuration saved to {config_path}[/green]")\n\n    except yaml.YAMLError as e:\n        console.print(f"[red]✗ Invalid YAML syntax:[/red]")\n        console.print(str(e))\n        console.print("\\n[yellow]Configuration not saved. Fix errors and try again.[/yellow]")\n\n    except Exception as e:\n        console.print(f"[red]✗ Validation failed:[/red]")\n        console.print(str(e))\n        console.print("\\n[yellow]Configuration not saved. Fix errors and try again.[/yellow]")\n\n    finally:\n        # Cleanup temp file\n        tmp_path.unlink()'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_onboarding_milestones_M07_CONFIGURATION_MANAGEMENT_4():
    """Test code snippet from projects/onboarding/milestones/M07_CONFIGURATION_MANAGEMENT.md (line 385)."""
    code = '# mycelium_onboarding/cli/config.py (continued)\n\n@config.command()\n@click.option(\n    \'--project\',\n    is_flag=True,\n    help=\'Validate project-local configuration\'\n)\n@click.option(\n    \'--strict\',\n    is_flag=True,\n    help=\'Enable strict validation (warnings as errors)\'\n)\ndef validate(project: bool, strict: bool):\n    """Validate configuration file."""\n\n    try:\n        config_path = ConfigManager.get_config_path(prefer_project=project)\n\n        if not config_path.exists():\n            console.print(f"[yellow]⚠ Configuration file not found: {config_path}[/yellow]")\n            raise click.Abort()\n\n        # Load and validate\n        console.print(f"[cyan]Validating: {config_path}[/cyan]\\n")\n\n        config = ConfigManager.load_from_path(config_path)\n\n        # Run additional checks\n        warnings = _check_configuration_warnings(config)\n\n        if warnings:\n            console.print("[yellow]Warnings:[/yellow]")\n            for warning in warnings:\n                console.print(f"  ⚠ {warning}")\n\n            if strict:\n                console.print("\\n[red]✗ Validation failed (strict mode)[/red]")\n                raise click.ClickException("Configuration has warnings")\n\n        # Success\n        console.print("\\n[green]✓ Configuration is valid[/green]")\n\n        # Show summary\n        _show_validation_summary(config)\n\n    except Exception as e:\n        console.print(f"\\n[red]✗ Validation failed:[/red]")\n        console.print(f"  {e}")\n        raise click.ClickException("Invalid configuration")\n\ndef _check_configuration_warnings(config: MyceliumConfig) -> list[str]:\n    """Check for configuration warnings (non-fatal issues)."""\n    warnings = []\n\n    # Check for deprecated settings\n    # (Add checks as configuration evolves)\n\n    # Check for unusual port numbers\n    if config.services.redis.enabled:\n        if config.services.redis.port < 1024:\n            warnings.append("Redis port < 1024 requires root privileges")\n\n    # Check for missing recommended settings\n    if config.services.redis.enabled and not config.services.redis.persistence:\n        warnings.append("Redis persistence disabled (data loss on restart)")\n\n    return warnings\n\ndef _show_validation_summary(config: MyceliumConfig):\n    """Show validation summary."""\n    table = Table(title="Configuration Summary", show_header=False)\n    table.add_column("Item", style="cyan")\n    table.add_column("Value", style="white")\n\n    table.add_row("Version", config.version)\n    table.add_row("Project Name", config.project_name)\n    table.add_row("Deployment Method", config.deployment.method)\n\n    enabled_services = []\n    if config.services.redis.enabled:\n        enabled_services.append("Redis")\n    if config.services.postgres.enabled:\n        enabled_services.append("PostgreSQL")\n    if config.services.temporal.enabled:\n        enabled_services.append("Temporal")\n    if config.services.taskqueue.enabled:\n        enabled_services.append("TaskQueue")\n\n    table.add_row("Enabled Services", ", ".join(enabled_services))\n\n    console.print(table)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_onboarding_milestones_M07_CONFIGURATION_MANAGEMENT_5():
    """Test code snippet from projects/onboarding/milestones/M07_CONFIGURATION_MANAGEMENT.md (line 482)."""
    code = '# tests/test_config_validate.py\n"""Tests for config validate command."""\n\ndef test_validate_success(tmp_valid_config):\n    """Validate should pass for valid configuration."""\n    runner = CliRunner()\n    result = runner.invoke(validate)\n\n    assert result.exit_code == 0\n    assert \'✓ Configuration is valid\' in result.output\n\ndef test_validate_detects_warnings(tmp_config_with_warnings):\n    """Validate should show warnings."""\n    runner = CliRunner()\n    result = runner.invoke(validate)\n\n    assert result.exit_code == 0\n    assert \'⚠\' in result.output\n\ndef test_validate_strict_fails_on_warnings(tmp_config_with_warnings):\n    """Validate --strict should fail on warnings."""\n    runner = CliRunner()\n    result = runner.invoke(validate, [\'--strict\'])\n\n    assert result.exit_code != 0\n\ndef test_validate_invalid_config(tmp_invalid_config):\n    """Validate should fail for invalid configuration."""\n    runner = CliRunner()\n    result = runner.invoke(validate)\n\n    assert result.exit_code != 0\n    assert \'Validation failed\' in result.output'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_onboarding_milestones_M07_CONFIGURATION_MANAGEMENT_6():
    """Test code snippet from projects/onboarding/milestones/M07_CONFIGURATION_MANAGEMENT.md (line 534)."""
    code = '# mycelium_onboarding/cli/config.py (continued)\n\n@config.command()\n@click.option(\n    \'--project\',\n    is_flag=True,\n    help=\'Create project-local configuration\'\n)\n@click.option(\n    \'--template\',\n    type=click.Choice([\'minimal\', \'docker\', \'justfile\', \'full\']),\n    default=\'minimal\',\n    help=\'Configuration template to use\'\n)\n@click.option(\n    \'--force\',\n    is_flag=True,\n    help=\'Overwrite existing configuration\'\n)\ndef init(project: bool, template: str, force: bool):\n    """Initialize new configuration."""\n\n    config_path = ConfigManager.get_config_path(prefer_project=project)\n\n    if config_path.exists() and not force:\n        console.print(f"[yellow]⚠ Configuration already exists: {config_path}[/yellow]")\n        console.print(f"[dim]Use --force to overwrite[/dim]")\n        raise click.Abort()\n\n    # Create configuration from template\n    config = _create_from_template(template)\n\n    # Save configuration\n    ConfigManager.save(config, project_local=project)\n\n    console.print(Panel(\n        f"[bold green]✓ Configuration initialized![/bold green]\\n\\n"\n        f"Location: [cyan]{config_path}[/cyan]\\n"\n        f"Template: [cyan]{template}[/cyan]\\n\\n"\n        f"Next steps:\\n"\n        f"1. Review configuration: [bold]/mycelium-configuration show[/bold]\\n"\n        f"2. Edit if needed: [bold]/mycelium-configuration edit[/bold]\\n"\n        f"3. Generate deployment: [bold]/mycelium-generate[/bold]",\n        border_style="green"\n    ))\n\ndef _create_from_template(template: str) -> MyceliumConfig:\n    """Create configuration from template."""\n    from mycelium_onboarding.config.schema import (\n        MyceliumConfig,\n        DeploymentConfig,\n        ServicesConfig,\n        RedisConfig,\n        PostgresConfig,\n        TemporalConfig,\n        TaskQueueConfig,\n    )\n\n    if template == \'minimal\':\n        # Minimal: Redis + TaskQueue\n        return MyceliumConfig(\n            project_name="mycelium",\n            deployment=DeploymentConfig(method="docker-compose"),\n            services=ServicesConfig(\n                redis=RedisConfig(enabled=True),\n                postgres=PostgresConfig(enabled=False),\n                temporal=TemporalConfig(enabled=False),\n                taskqueue=TaskQueueConfig(enabled=True),\n            ),\n        )\n\n    elif template == \'docker\':\n        # Docker Compose with all services\n        return MyceliumConfig(\n            project_name="mycelium",\n            deployment=DeploymentConfig(method="docker-compose"),\n            services=ServicesConfig(\n                redis=RedisConfig(enabled=True, persistence=True),\n                postgres=PostgresConfig(enabled=True),\n                temporal=TemporalConfig(enabled=True),\n                taskqueue=TaskQueueConfig(enabled=True),\n            ),\n        )\n\n    elif template == \'justfile\':\n        # Justfile with core services\n        return MyceliumConfig(\n            project_name="mycelium",\n            deployment=DeploymentConfig(method="justfile"),\n            services=ServicesConfig(\n                redis=RedisConfig(enabled=True),\n                postgres=PostgresConfig(enabled=True),\n                temporal=TemporalConfig(enabled=False),  # Complex for bare-metal\n                taskqueue=TaskQueueConfig(enabled=True),\n            ),\n        )\n\n    elif template == \'full\':\n        # All services with recommended settings\n        return MyceliumConfig(\n            project_name="mycelium",\n            deployment=DeploymentConfig(method="docker-compose", healthcheck_timeout=90),\n            services=ServicesConfig(\n                redis=RedisConfig(\n                    enabled=True,\n                    persistence=True,\n                    max_memory="512mb",\n                ),\n                postgres=PostgresConfig(\n                    enabled=True,\n                    max_connections=100,\n                ),\n                temporal=TemporalConfig(\n                    enabled=True,\n                ),\n                taskqueue=TaskQueueConfig(enabled=True),\n            ),\n        )\n\n    else:\n        raise ValueError(f"Unknown template: {template}")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_onboarding_milestones_M08_DOCUMENTATION_1():
    """Test code snippet from projects/onboarding/milestones/M08_DOCUMENTATION.md (line 744)."""
    code = 'from mycelium_onboarding.config.manager import ConfigManager\n\n# Load configuration\nconfig = ConfigManager.load()\nprint(f"Project: {config.project_name}")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_onboarding_milestones_M09_TESTING_SUITE_1():
    """Test code snippet from projects/onboarding/milestones/M09_TESTING_SUITE.md (line 83)."""
    code = '# tests/unit/test_config_manager.py\n"""Unit tests for ConfigManager."""\n\nimport pytest\nfrom pathlib import Path\nfrom pydantic import ValidationError\n\nfrom mycelium.config import ConfigManager, MyceliumConfig, ServicesConfig, RedisConfig\n\n\nclass TestConfigManagerLoad:\n    """Tests for ConfigManager.load()."""\n\n    def test_load_from_project_local(self, tmp_path, sample_config):\n        """Test loading configuration from project-local path."""\n        # Arrange\n        project_config = tmp_path / ".mycelium" / "config.yaml"\n        project_config.parent.mkdir(parents=True)\n        ConfigManager.save(sample_config, project_local=True, config_dir=tmp_path)\n\n        # Act\n        loaded = ConfigManager.load(prefer_project=True, project_dir=tmp_path)\n\n        # Assert\n        assert loaded.services.redis.enabled == sample_config.services.redis.enabled\n        assert loaded.services.redis.port == sample_config.services.redis.port\n\n    def test_load_from_user_global(self, tmp_path, sample_config):\n        """Test loading configuration from user global path (~/.config/mycelium)."""\n        # Arrange\n        user_config = tmp_path / "config.yaml"\n        ConfigManager.save(sample_config, project_local=False, config_dir=tmp_path)\n\n        # Act\n        loaded = ConfigManager.load(prefer_project=False, user_config_dir=tmp_path)\n\n        # Assert\n        assert loaded.services.redis.enabled == sample_config.services.redis.enabled\n\n    def test_load_creates_default_if_missing(self, tmp_path):\n        """Test that load creates default config if no config exists."""\n        # Act\n        loaded = ConfigManager.load(\n            prefer_project=False,\n            user_config_dir=tmp_path / "nonexistent",\n            create_default=True\n        )\n\n        # Assert\n        assert isinstance(loaded, MyceliumConfig)\n        assert loaded.services.redis.enabled  # Default has Redis enabled\n\n    def test_load_raises_if_missing_and_no_default(self, tmp_path):\n        """Test that load raises error if config missing and no default creation."""\n        # Act & Assert\n        with pytest.raises(FileNotFoundError):\n            ConfigManager.load(\n                prefer_project=False,\n                user_config_dir=tmp_path / "nonexistent",\n                create_default=False\n            )\n\n\nclass TestConfigManagerSave:\n    """Tests for ConfigManager.save()."""\n\n    def test_save_to_project_local(self, tmp_path, sample_config):\n        """Test saving configuration to project-local directory."""\n        # Act\n        config_path = ConfigManager.save(\n            sample_config,\n            project_local=True,\n            config_dir=tmp_path\n        )\n\n        # Assert\n        assert config_path.exists()\n        assert config_path.parent.name == ".mycelium"\n        assert config_path.name == "config.yaml"\n\n    def test_save_creates_directory_if_missing(self, tmp_path, sample_config):\n        """Test that save creates config directory if it doesn\'t exist."""\n        # Arrange\n        config_dir = tmp_path / "new_dir"\n        assert not config_dir.exists()\n\n        # Act\n        config_path = ConfigManager.save(\n            sample_config,\n            project_local=True,\n            config_dir=config_dir\n        )\n\n        # Assert\n        assert config_path.exists()\n        assert config_path.parent.exists()\n\n    def test_save_overwrites_existing_config(self, tmp_path, sample_config):\n        """Test that save overwrites existing configuration."""\n        # Arrange\n        config_path = ConfigManager.save(sample_config, project_local=True, config_dir=tmp_path)\n        original_content = config_path.read_text()\n\n        # Modify config\n        sample_config.services.redis.port = 9999\n\n        # Act\n        ConfigManager.save(sample_config, project_local=True, config_dir=tmp_path)\n\n        # Assert\n        new_content = config_path.read_text()\n        assert new_content != original_content\n        assert "9999" in new_content\n\n\nclass TestConfigManagerValidation:\n    """Tests for configuration validation."""\n\n    def test_validate_rejects_invalid_port(self):\n        """Test that validation rejects ports outside valid range."""\n        # Act & Assert\n        with pytest.raises(ValidationError):\n            MyceliumConfig(\n                services=ServicesConfig(\n                    redis=RedisConfig(enabled=True, port=70000)  # Invalid port\n                )\n            )\n\n    def test_validate_rejects_negative_memory(self):\n        """Test that validation rejects negative memory values."""\n        # Act & Assert\n        with pytest.raises(ValidationError):\n            MyceliumConfig(\n                services=ServicesConfig(\n                    redis=RedisConfig(enabled=True, max_memory=-100)  # Invalid\n                )\n            )\n\n    def test_validate_accepts_valid_config(self, sample_config):\n        """Test that validation accepts valid configuration."""\n        # Act & Assert (no exception raised)\n        assert sample_config.services.redis.enabled\n        assert 1024 <= sample_config.services.redis.port <= 65535\n\n\n@pytest.fixture\ndef sample_config() -> MyceliumConfig:\n    """Provide sample valid configuration for testing."""\n    return MyceliumConfig(\n        services=ServicesConfig(\n            redis=RedisConfig(\n                enabled=True,\n                port=6379,\n                max_memory=512,\n                persistence=True\n            )\n        )\n    )'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_onboarding_milestones_M09_TESTING_SUITE_2():
    """Test code snippet from projects/onboarding/milestones/M09_TESTING_SUITE.md (line 246)."""
    code = '# tests/unit/test_detection.py\n"""Unit tests for infrastructure detection."""\n\nimport pytest\nfrom unittest.mock import Mock, patch, MagicMock\n\nfrom mycelium.detection import (\n    InfraDetector,\n    DetectionResults,\n    ServiceStatus,\n    RedisDetection,\n)\n\n\nclass TestRedisDetection:\n    """Tests for Redis service detection."""\n\n    @patch(\'subprocess.run\')\n    def test_detect_docker_redis(self, mock_run):\n        """Test detection of Redis running in Docker."""\n        # Arrange\n        mock_run.return_value = Mock(\n            returncode=0,\n            stdout="mycelium-redis\\n6379/tcp\\nrunning"\n        )\n\n        detector = InfraDetector()\n\n        # Act\n        result = detector.detect_redis()\n\n        # Assert\n        assert result.available\n        assert result.method == "docker"\n        assert result.port == 6379\n        mock_run.assert_called_once()\n\n    @patch(\'subprocess.run\')\n    def test_detect_native_redis(self, mock_run):\n        """Test detection of Redis running natively (systemd)."""\n        # Arrange\n        mock_run.side_effect = [\n            Mock(returncode=1, stdout=""),  # Docker check fails\n            Mock(returncode=0, stdout="active")  # Systemd check succeeds\n        ]\n\n        detector = InfraDetector()\n\n        # Act\n        result = detector.detect_redis()\n\n        # Assert\n        assert result.available\n        assert result.method == "systemd"\n        assert mock_run.call_count == 2\n\n    @patch(\'subprocess.run\')\n    def test_detect_redis_not_found(self, mock_run):\n        """Test detection when Redis is not running."""\n        # Arrange\n        mock_run.return_value = Mock(returncode=1, stdout="")\n\n        detector = InfraDetector()\n\n        # Act\n        result = detector.detect_redis()\n\n        # Assert\n        assert not result.available\n        assert result.method is None\n\n    @patch(\'socket.socket\')\n    def test_detect_redis_port_in_use(self, mock_socket):\n        """Test detection of Redis by checking if port 6379 is in use."""\n        # Arrange\n        mock_sock = MagicMock()\n        mock_socket.return_value.__enter__.return_value = mock_sock\n        mock_sock.connect_ex.return_value = 0  # Port is open\n\n        detector = InfraDetector()\n\n        # Act\n        result = detector._check_redis_port()\n\n        # Assert\n        assert result\n        mock_sock.connect_ex.assert_called_with((\'localhost\', 6379))\n\n\nclass TestInfraDetectorFullScan:\n    """Tests for complete infrastructure scanning."""\n\n    @patch.object(InfraDetector, \'detect_redis\')\n    @patch.object(InfraDetector, \'detect_postgres\')\n    @patch.object(InfraDetector, \'detect_docker\')\n    def test_scan_all_services(self, mock_docker, mock_postgres, mock_redis):\n        """Test scanning all services returns complete results."""\n        # Arrange\n        mock_redis.return_value = RedisDetection(available=True, method="docker")\n        mock_postgres.return_value = Mock(available=False)\n        mock_docker.return_value = Mock(available=True, version="24.0.0")\n\n        detector = InfraDetector()\n\n        # Act\n        results = detector.scan_all()\n\n        # Assert\n        assert isinstance(results, DetectionResults)\n        assert results.redis.available\n        assert not results.postgres.available\n        assert results.docker.available\n        mock_redis.assert_called_once()\n        mock_postgres.assert_called_once()\n        mock_docker.assert_called_once()'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_onboarding_milestones_M09_TESTING_SUITE_3():
    """Test code snippet from projects/onboarding/milestones/M09_TESTING_SUITE.md (line 377)."""
    code = '# tests/integration/test_full_flow.py\n"""Integration tests for complete onboarding workflow."""\n\nimport pytest\nfrom pathlib import Path\nfrom unittest.mock import patch, Mock\n\nfrom mycelium.detection import InfraDetector\nfrom mycelium.config import ConfigManager, MyceliumConfig\nfrom mycelium.wizard import OnboardingWizard\nfrom mycelium.generators import DockerComposeGenerator, JustfileGenerator\n\n\n@pytest.mark.integration\nclass TestFullOnboardingFlow:\n    """Tests for complete onboarding workflow: detect → wizard → config → generate."""\n\n    @pytest.mark.asyncio\n    async def test_docker_deployment_flow(self, tmp_path, monkeypatch):\n        """Test complete flow for Docker deployment method."""\n        # Arrange: Mock detection results\n        detection_results = Mock(\n            redis=Mock(available=True, method="docker"),\n            postgres=Mock(available=True, method="docker"),\n            docker=Mock(available=True, version="24.0.0"),\n        )\n\n        with patch.object(InfraDetector, \'scan_all\', return_value=detection_results):\n            # Arrange: Mock wizard user selections\n            mock_selections = {\n                \'services\': {\'redis\', \'postgres\', \'taskqueue\'},\n                \'deployment_method\': \'docker-compose\',\n                \'project_local\': True,\n            }\n\n            with patch(\'inquirer.checkbox\', side_effect=[\n                mock_selections[\'services\'],  # Service selection\n            ]):\n                with patch(\'inquirer.select\', return_value=mock_selections[\'deployment_method\']):\n                    with patch(\'inquirer.confirm\', return_value=mock_selections[\'project_local\']):\n                        # Act: Run wizard\n                        wizard = OnboardingWizard()\n                        config = await wizard.run(config_dir=tmp_path)\n\n        # Assert: Configuration created correctly\n        assert isinstance(config, MyceliumConfig)\n        assert config.services.redis.enabled\n        assert config.services.postgres.enabled\n        assert config.services.taskqueue.enabled\n        assert config.deployment.method == "docker-compose"\n\n        # Act: Save configuration\n        config_path = ConfigManager.save(config, project_local=True, config_dir=tmp_path)\n\n        # Assert: Configuration file exists\n        assert config_path.exists()\n        assert config_path.name == "config.yaml"\n\n        # Act: Generate deployment files\n        docker_gen = DockerComposeGenerator()\n        docker_compose = docker_gen.generate(config)\n\n        justfile_gen = JustfileGenerator()\n        justfile = justfile_gen.generate(config)\n\n        # Assert: Deployment files generated\n        assert "services:" in docker_compose\n        assert "redis:" in docker_compose\n        assert "postgres:" in docker_compose\n        assert "up:" in justfile\n        assert "down:" in justfile\n\n    @pytest.mark.asyncio\n    async def test_native_deployment_flow(self, tmp_path, monkeypatch):\n        """Test complete flow for native (Justfile) deployment method."""\n        # Arrange: Mock detection results (native services)\n        detection_results = Mock(\n            redis=Mock(available=True, method="systemd"),\n            postgres=Mock(available=True, method="systemd"),\n            docker=Mock(available=False),\n        )\n\n        with patch.object(InfraDetector, \'scan_all\', return_value=detection_results):\n            # Arrange: Mock wizard selections\n            mock_selections = {\n                \'services\': {\'redis\', \'taskqueue\'},\n                \'deployment_method\': \'justfile\',\n                \'project_local\': False,\n            }\n\n            with patch(\'inquirer.checkbox\', return_value=mock_selections[\'services\']):\n                with patch(\'inquirer.select\', return_value=mock_selections[\'deployment_method\']):\n                    with patch(\'inquirer.confirm\', return_value=mock_selections[\'project_local\']):\n                        # Act: Run wizard\n                        wizard = OnboardingWizard()\n                        config = await wizard.run(config_dir=tmp_path)\n\n        # Assert: Configuration created for native deployment\n        assert config.deployment.method == "justfile"\n        assert config.services.redis.enabled\n        assert config.services.taskqueue.enabled\n\n        # Act: Generate Justfile\n        justfile_gen = JustfileGenerator()\n        justfile = justfile_gen.generate(config)\n\n        # Assert: Justfile contains native service management\n        assert "systemctl" in justfile\n        assert "redis-cli" in justfile\n\n\n@pytest.mark.integration\nclass TestComponentIntegration:\n    """Tests for integration between specific component pairs."""\n\n    def test_detection_to_config_mapping(self):\n        """Test that detection results correctly map to configuration."""\n        # Arrange\n        detection_results = Mock(\n            redis=Mock(available=True, method="docker", port=6379),\n            postgres=Mock(available=True, method="docker", port=5432),\n        )\n\n        # Act\n        config = MyceliumConfig.from_detection(detection_results)\n\n        # Assert\n        assert config.services.redis.enabled\n        assert config.services.redis.port == 6379\n        assert config.services.postgres.enabled\n        assert config.services.postgres.port == 5432\n\n    def test_config_to_generator_input(self, sample_config):\n        """Test that configuration provides valid input for generators."""\n        # Act\n        docker_gen = DockerComposeGenerator()\n        output = docker_gen.generate(sample_config)\n\n        # Assert: Valid YAML structure\n        import yaml\n        parsed = yaml.safe_load(output)\n        assert \'services\' in parsed\n        assert \'redis\' in parsed[\'services\']\n        assert parsed[\'services\'][\'redis\'][\'image\'].startswith(\'redis:\')'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_onboarding_milestones_M09_TESTING_SUITE_4():
    """Test code snippet from projects/onboarding/milestones/M09_TESTING_SUITE.md (line 771)."""
    code = '# tests/conftest.py\n"""Shared pytest fixtures for all tests."""\n\nimport pytest\nfrom pathlib import Path\nfrom typing import Generator\nfrom unittest.mock import Mock\n\nfrom mycelium.config import MyceliumConfig, ServicesConfig, RedisConfig, PostgresConfig\n\n\n@pytest.fixture\ndef tmp_project_dir(tmp_path: Path) -> Path:\n    """Provide temporary project directory with standard structure."""\n    project_dir = tmp_path / "test_project"\n    project_dir.mkdir()\n\n    # Create standard directories\n    (project_dir / ".mycelium").mkdir()\n    (project_dir / "deployment").mkdir()\n\n    return project_dir\n\n\n@pytest.fixture\ndef sample_config() -> MyceliumConfig:\n    """Provide sample valid configuration for testing."""\n    return MyceliumConfig(\n        services=ServicesConfig(\n            redis=RedisConfig(\n                enabled=True,\n                port=6379,\n                max_memory=512,\n                persistence=True\n            ),\n            postgres=PostgresConfig(\n                enabled=True,\n                port=5432,\n                database="mycelium",\n                max_connections=100\n            )\n        )\n    )\n\n\n@pytest.fixture\ndef mock_detection_results() -> Mock:\n    """Provide mock detection results."""\n    return Mock(\n        redis=Mock(available=True, method="docker", port=6379),\n        postgres=Mock(available=True, method="docker", port=5432),\n        docker=Mock(available=True, version="24.0.0"),\n        taskqueue=Mock(available=False),\n        temporal=Mock(available=False),\n    )\n\n\n@pytest.fixture(autouse=True)\ndef reset_singletons():\n    """Reset singleton instances between tests."""\n    # Clear any cached singleton state\n    from mycelium.config import ConfigManager\n    ConfigManager._instance = None\n\n    yield\n\n    # Cleanup after test\n    ConfigManager._instance = None\n\n\n@pytest.fixture\ndef mock_docker_client() -> Generator[Mock, None, None]:\n    """Provide mocked Docker client."""\n    mock_client = Mock()\n    mock_client.containers.list.return_value = []\n    mock_client.images.list.return_value = []\n\n    yield mock_client\n\n    mock_client.close()\n\n\n# Mark slow tests\ndef pytest_configure(config):\n    """Configure pytest with custom settings."""\n    config.addinivalue_line(\n        "markers",\n        "slow: marks tests as slow (deselect with \'-m \\"not slow\\"\')"\n    )'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_onboarding_milestones_M09_TESTING_SUITE_5():
    """Test code snippet from projects/onboarding/milestones/M09_TESTING_SUITE.md (line 865)."""
    code = '# scripts/coverage_report.py\n"""Generate and display coverage report with color coding."""\n\nimport subprocess\nimport sys\nfrom pathlib import Path\n\n\ndef run_coverage() -> tuple[float, str]:\n    """Run pytest with coverage and return coverage percentage."""\n    result = subprocess.run(\n        [\n            "pytest",\n            "tests/",\n            "--cov=mycelium",\n            "--cov-report=term-missing",\n            "--cov-report=html",\n            "--cov-report=xml",\n        ],\n        capture_output=True,\n        text=True\n    )\n\n    # Parse coverage percentage from output\n    for line in result.stdout.split(\'\\n\'):\n        if \'TOTAL\' in line:\n            parts = line.split()\n            coverage_pct = float(parts[-1].rstrip(\'%\'))\n            return coverage_pct, result.stdout\n\n    return 0.0, result.stdout\n\n\ndef main():\n    """Main entry point."""\n    print("Running test suite with coverage analysis...\\n")\n\n    coverage_pct, output = run_coverage()\n\n    print(output)\n    print("\\n" + "=" * 60)\n\n    if coverage_pct >= 80:\n        print(f"✓ Coverage: {coverage_pct:.2f}% (Target: ≥80%) - PASS")\n        sys.exit(0)\n    elif coverage_pct >= 70:\n        print(f"⚠ Coverage: {coverage_pct:.2f}% (Target: ≥80%) - WARNING")\n        sys.exit(0)\n    else:\n        print(f"✗ Coverage: {coverage_pct:.2f}% (Target: ≥80%) - FAIL")\n        sys.exit(1)\n\n\nif __name__ == "__main__":\n    main()'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_onboarding_milestones_M09_TESTING_SUITE_6():
    """Test code snippet from projects/onboarding/milestones/M09_TESTING_SUITE.md (line 934)."""
    code = '# tests/fixtures/mcp_fixtures.py\n"""Mock fixtures for MCP server interactions."""\n\nimport pytest\nfrom unittest.mock import AsyncMock, Mock\nfrom typing import AsyncGenerator\n\n\n@pytest.fixture\nasync def mock_redis_mcp() -> AsyncGenerator[AsyncMock, None]:\n    """Provide mocked Redis MCP client."""\n    mock_client = AsyncMock()\n\n    # Mock common Redis operations\n    mock_client.hset = AsyncMock(return_value=1)\n    mock_client.hget = AsyncMock(return_value=b"mocked_value")\n    mock_client.hdel = AsyncMock(return_value=1)\n    mock_client.hgetall = AsyncMock(return_value={b"key": b"value"})\n    mock_client.publish = AsyncMock(return_value=1)\n    mock_client.subscribe = AsyncMock()\n\n    yield mock_client\n\n    # Cleanup\n    await mock_client.close()\n\n\n@pytest.fixture\nasync def mock_taskqueue_mcp() -> AsyncGenerator[AsyncMock, None]:\n    """Provide mocked TaskQueue MCP client."""\n    mock_client = AsyncMock()\n\n    # Mock task queue operations\n    mock_client.create_project = AsyncMock(return_value={"project_id": "proj-1"})\n    mock_client.add_tasks_to_project = AsyncMock(return_value={"task_ids": ["task-1"]})\n    mock_client.get_next_task = AsyncMock(return_value={\n        "task_id": "task-1",\n        "title": "Test Task",\n        "status": "not started"\n    })\n    mock_client.update_task = AsyncMock(return_value={"status": "completed"})\n\n    yield mock_client\n\n\n@pytest.fixture\ndef mock_subprocess_run(monkeypatch):\n    """Provide mocked subprocess.run for system command tests."""\n    mock_run = Mock()\n    mock_run.return_value = Mock(\n        returncode=0,\n        stdout="mocked output",\n        stderr=""\n    )\n\n    monkeypatch.setattr("subprocess.run", mock_run)\n\n    return mock_run'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_onboarding_milestones_M09_TESTING_SUITE_7():
    """Test code snippet from projects/onboarding/milestones/M09_TESTING_SUITE.md (line 997)."""
    code = '# tests/fixtures/config_fixtures.py\n"""Factory functions for creating test data."""\n\nfrom dataclasses import dataclass, field\nfrom typing import Optional\nimport factory\nfrom factory import Factory, SubFactory, Faker\n\nfrom mycelium.config import (\n    MyceliumConfig,\n    ServicesConfig,\n    RedisConfig,\n    PostgresConfig,\n    DeploymentConfig,\n)\n\n\nclass RedisConfigFactory(Factory):\n    """Factory for generating RedisConfig instances."""\n\n    class Meta:\n        model = RedisConfig\n\n    enabled = True\n    port = 6379\n    max_memory = 512\n    persistence = True\n\n\nclass PostgresConfigFactory(Factory):\n    """Factory for generating PostgresConfig instances."""\n\n    class Meta:\n        model = PostgresConfig\n\n    enabled = True\n    port = 5432\n    database = "mycelium"\n    max_connections = 100\n\n\nclass ServicesConfigFactory(Factory):\n    """Factory for generating ServicesConfig instances."""\n\n    class Meta:\n        model = ServicesConfig\n\n    redis = SubFactory(RedisConfigFactory)\n    postgres = SubFactory(PostgresConfigFactory)\n\n\nclass DeploymentConfigFactory(Factory):\n    """Factory for generating DeploymentConfig instances."""\n\n    class Meta:\n        model = DeploymentConfig\n\n    method = "docker-compose"\n\n\nclass MyceliumConfigFactory(Factory):\n    """Factory for generating complete MyceliumConfig instances."""\n\n    class Meta:\n        model = MyceliumConfig\n\n    services = SubFactory(ServicesConfigFactory)\n    deployment = SubFactory(DeploymentConfigFactory)\n\n\n# Convenience functions\ndef create_minimal_config() -> MyceliumConfig:\n    """Create minimal valid configuration (Redis only)."""\n    return MyceliumConfigFactory.build(\n        services__postgres__enabled=False,\n        services__taskqueue__enabled=False,\n    )\n\n\ndef create_full_config() -> MyceliumConfig:\n    """Create configuration with all services enabled."""\n    return MyceliumConfigFactory.build()\n\n\ndef create_docker_config() -> MyceliumConfig:\n    """Create configuration for Docker deployment."""\n    return MyceliumConfigFactory.build(\n        deployment__method="docker-compose"\n    )\n\n\ndef create_justfile_config() -> MyceliumConfig:\n    """Create configuration for Justfile deployment."""\n    return MyceliumConfigFactory.build(\n        deployment__method="justfile"\n    )'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_onboarding_milestones_M09_TESTING_SUITE_8():
    """Test code snippet from projects/onboarding/milestones/M09_TESTING_SUITE.md (line 1098)."""
    code = '# tests/unit/test_config_validation.py\n"""Parametrized tests for configuration validation."""\n\nimport pytest\nfrom pydantic import ValidationError\n\nfrom mycelium.config import RedisConfig\n\n\n@pytest.mark.parametrize("port,should_pass", [\n    (1024, True),      # Valid: lower bound\n    (6379, True),      # Valid: standard\n    (65535, True),     # Valid: upper bound\n    (0, False),        # Invalid: too low\n    (70000, False),    # Invalid: too high\n    (-1, False),       # Invalid: negative\n])\ndef test_redis_port_validation(port: int, should_pass: bool):\n    """Test Redis port validation with various inputs."""\n    if should_pass:\n        config = RedisConfig(enabled=True, port=port)\n        assert config.port == port\n    else:\n        with pytest.raises(ValidationError):\n            RedisConfig(enabled=True, port=port)\n\n\n@pytest.mark.parametrize("max_memory,should_pass", [\n    (128, True),       # Valid: minimum\n    (512, True),       # Valid: standard\n    (4096, True),      # Valid: large\n    (0, False),        # Invalid: zero\n    (-100, False),     # Invalid: negative\n])\ndef test_redis_memory_validation(max_memory: int, should_pass: bool):\n    """Test Redis max_memory validation with various inputs."""\n    if should_pass:\n        config = RedisConfig(enabled=True, max_memory=max_memory)\n        assert config.max_memory == max_memory\n    else:\n        with pytest.raises(ValidationError):\n            RedisConfig(enabled=True, max_memory=max_memory)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_onboarding_milestones_M10_POLISH_RELEASE_1():
    """Test code snippet from projects/onboarding/milestones/M10_POLISH_RELEASE.md (line 71)."""
    code = '# scripts/qa_validation.py\n"""Automated QA validation script for multi-platform testing."""\n\nimport subprocess\nimport sys\nimport platform\nfrom pathlib import Path\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport json\n\n\n@dataclass\nclass QATestResult:\n    """Result of a single QA test."""\n    test_name: str\n    status: str  # "pass", "fail", "skip"\n    duration_sec: float\n    error_message: Optional[str] = None\n\n\nclass QAValidator:\n    """Orchestrates comprehensive QA validation."""\n\n    def __init__(self):\n        self.results: List[QATestResult] = []\n        self.platform_info = self._gather_platform_info()\n\n    def _gather_platform_info(self) -> dict:\n        """Gather platform information for reporting."""\n        return {\n            "os": platform.system(),\n            "os_version": platform.version(),\n            "python_version": platform.python_version(),\n            "architecture": platform.machine(),\n        }\n\n    def run_all_checks(self) -> bool:\n        """Run all QA checks and return overall pass/fail."""\n        print("=" * 60)\n        print("Starting QA Validation")\n        print("=" * 60)\n        print(f"Platform: {self.platform_info[\'os\']}")\n        print(f"Python: {self.platform_info[\'python_version\']}")\n        print()\n\n        # Category 1: Installation & Setup\n        self._check_dependencies()\n        self._check_installation()\n\n        # Category 2: Detection System\n        self._check_docker_detection()\n        self._check_redis_detection()\n        self._check_postgres_detection()\n\n        # Category 3: Onboarding Wizard\n        self._check_wizard_flow()\n        self._check_configuration_persistence()\n\n        # Category 4: Deployment Generation\n        self._check_docker_compose_generation()\n        self._check_justfile_generation()\n        self._check_secrets_generation()\n\n        # Category 5: Testing Framework\n        self._check_coordination_tests()\n        self._check_unit_tests()\n        self._check_integration_tests()\n\n        # Category 6: CLI Commands\n        self._check_slash_commands()\n\n        # Category 7: Documentation\n        self._check_documentation_accuracy()\n\n        # Generate report\n        self._generate_report()\n\n        # Return overall status\n        failed_count = sum(1 for r in self.results if r.status == "fail")\n        return failed_count == 0\n\n    def _check_dependencies(self):\n        """Verify all required dependencies are installed."""\n        print("Checking dependencies...")\n\n        # Check uv\n        result = subprocess.run(\n            ["uv", "--version"],\n            capture_output=True,\n            text=True\n        )\n        self._record_result("uv_installed", result.returncode == 0)\n\n        # Check Docker (if available)\n        result = subprocess.run(\n            ["docker", "--version"],\n            capture_output=True,\n            text=True\n        )\n        self._record_result("docker_available", result.returncode == 0)\n\n    def _check_installation(self):\n        """Verify mycelium package is correctly installed."""\n        print("Checking installation...")\n\n        result = subprocess.run(\n            ["uv", "run", "python", "-c", "import mycelium; print(mycelium.__version__)"],\n            capture_output=True,\n            text=True\n        )\n        self._record_result("mycelium_installed", result.returncode == 0)\n\n    def _check_docker_detection(self):\n        """Test Docker detection accuracy."""\n        print("Checking Docker detection...")\n\n        result = subprocess.run(\n            ["uv", "run", "python", "-c",\n             "from mycelium.detection import InfraDetector; "\n             "d = InfraDetector(); "\n             "r = d.detect_docker(); "\n             "print(\'available\' if r.available else \'unavailable\')"],\n            capture_output=True,\n            text=True\n        )\n\n        self._record_result("docker_detection", result.returncode == 0)\n\n    def _check_wizard_flow(self):\n        """Test onboarding wizard completion."""\n        print("Checking wizard flow...")\n\n        # Create test inputs file\n        test_inputs = """redis\npostgres\n\ndocker-compose\ny\n"""\n        inputs_file = Path("/tmp/qa_wizard_inputs.txt")\n        inputs_file.write_text(test_inputs)\n\n        result = subprocess.run(\n            ["uv", "run", "mycelium-onboarding", "--non-interactive"],\n            input=test_inputs,\n            capture_output=True,\n            text=True\n        )\n\n        self._record_result("wizard_flow", result.returncode == 0)\n\n    def _check_docker_compose_generation(self):\n        """Test Docker Compose file generation."""\n        print("Checking Docker Compose generation...")\n\n        result = subprocess.run(\n            ["uv", "run", "python", "-c",\n             "from mycelium.generators import DockerComposeGenerator; "\n             "from mycelium.config import MyceliumConfig; "\n             "config = MyceliumConfig(); "\n             "gen = DockerComposeGenerator(); "\n             "output = gen.generate(config); "\n             "print(\'valid\' if \'services:\' in output else \'invalid\')"],\n            capture_output=True,\n            text=True\n        )\n\n        self._record_result(\n            "docker_compose_generation",\n            result.returncode == 0 and "valid" in result.stdout\n        )\n\n    def _check_coordination_tests(self):\n        """Run coordination tests from M06."""\n        print("Running coordination tests...")\n\n        result = subprocess.run(\n            ["uv", "run", "pytest", "tests/integration/test_coordination.py", "-v"],\n            capture_output=True,\n            text=True\n        )\n\n        self._record_result("coordination_tests", result.returncode == 0)\n\n    def _check_unit_tests(self):\n        """Run unit tests from M09."""\n        print("Running unit tests...")\n\n        result = subprocess.run(\n            ["uv", "run", "pytest", "tests/unit/", "-v"],\n            capture_output=True,\n            text=True\n        )\n\n        self._record_result("unit_tests", result.returncode == 0)\n\n    def _check_slash_commands(self):\n        """Verify all slash commands are accessible."""\n        print("Checking slash commands...")\n\n        commands = [\n            "mycelium-onboarding",\n            "mycelium-generate",\n            "mycelium-test",\n            "mycelium-configuration",\n        ]\n\n        for cmd in commands:\n            result = subprocess.run(\n                ["uv", "run", cmd, "--help"],\n                capture_output=True,\n                text=True\n            )\n            self._record_result(f"slash_command_{cmd}", result.returncode == 0)\n\n    def _check_documentation_accuracy(self):\n        """Verify documentation examples are accurate."""\n        print("Checking documentation accuracy...")\n\n        # Check installation guide\n        install_guide = Path("docs/INSTALLATION.md")\n        self._record_result(\n            "installation_guide_exists",\n            install_guide.exists()\n        )\n\n        # Check getting started tutorial\n        tutorial = Path("docs/GETTING_STARTED.md")\n        self._record_result(\n            "getting_started_exists",\n            tutorial.exists()\n        )\n\n    def _record_result(self, test_name: str, passed: bool, error: Optional[str] = None):\n        """Record test result."""\n        result = QATestResult(\n            test_name=test_name,\n            status="pass" if passed else "fail",\n            duration_sec=0.0,\n            error_message=error\n        )\n        self.results.append(result)\n\n        status_symbol = "✓" if passed else "✗"\n        print(f"  {status_symbol} {test_name}")\n\n    def _generate_report(self):\n        """Generate QA validation report."""\n        print("\\n" + "=" * 60)\n        print("QA Validation Report")\n        print("=" * 60)\n\n        total = len(self.results)\n        passed = sum(1 for r in self.results if r.status == "pass")\n        failed = sum(1 for r in self.results if r.status == "fail")\n\n        print(f"Total Tests: {total}")\n        print(f"Passed: {passed} ({passed/total*100:.1f}%)")\n        print(f"Failed: {failed} ({failed/total*100:.1f}%)")\n\n        if failed > 0:\n            print("\\nFailed Tests:")\n            for result in self.results:\n                if result.status == "fail":\n                    print(f"  ✗ {result.test_name}")\n                    if result.error_message:\n                        print(f"    Error: {result.error_message}")\n\n        # Save JSON report\n        report_path = Path("qa_report.json")\n        report_data = {\n            "platform": self.platform_info,\n            "results": [\n                {\n                    "test": r.test_name,\n                    "status": r.status,\n                    "duration": r.duration_sec,\n                    "error": r.error_message\n                }\n                for r in self.results\n            ],\n            "summary": {\n                "total": total,\n                "passed": passed,\n                "failed": failed,\n                "pass_rate": passed / total if total > 0 else 0\n            }\n        }\n        report_path.write_text(json.dumps(report_data, indent=2))\n        print(f"\\nDetailed report saved to: {report_path}")\n\n\ndef main():\n    """Main entry point."""\n    validator = QAValidator()\n    success = validator.run_all_checks()\n\n    sys.exit(0 if success else 1)\n\n\nif __name__ == "__main__":\n    main()'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_onboarding_milestones_M10_POLISH_RELEASE_2():
    """Test code snippet from projects/onboarding/milestones/M10_POLISH_RELEASE.md (line 418)."""
    code = '# scripts/performance_benchmark.py\n"""Performance benchmarking for key operations."""\n\nimport time\nimport statistics\nfrom typing import List, Callable\nfrom dataclasses import dataclass\nimport cProfile\nimport pstats\nfrom io import StringIO\n\n\n@dataclass\nclass BenchmarkResult:\n    """Result of a performance benchmark."""\n    operation_name: str\n    mean_ms: float\n    median_ms: float\n    p95_ms: float\n    p99_ms: float\n    min_ms: float\n    max_ms: float\n    iterations: int\n\n\nclass PerformanceBenchmark:\n    """Performance benchmarking suite."""\n\n    def __init__(self, iterations: int = 100):\n        self.iterations = iterations\n        self.results: List[BenchmarkResult] = []\n\n    def benchmark_operation(\n        self,\n        name: str,\n        operation: Callable,\n        warmup: int = 10\n    ) -> BenchmarkResult:\n        """Benchmark a single operation."""\n        print(f"Benchmarking: {name}")\n\n        # Warmup\n        for _ in range(warmup):\n            operation()\n\n        # Measure\n        timings: List[float] = []\n        for _ in range(self.iterations):\n            start = time.perf_counter()\n            operation()\n            end = time.perf_counter()\n            timings.append((end - start) * 1000)  # Convert to ms\n\n        # Calculate statistics\n        result = BenchmarkResult(\n            operation_name=name,\n            mean_ms=statistics.mean(timings),\n            median_ms=statistics.median(timings),\n            p95_ms=self._percentile(timings, 95),\n            p99_ms=self._percentile(timings, 99),\n            min_ms=min(timings),\n            max_ms=max(timings),\n            iterations=self.iterations\n        )\n\n        self.results.append(result)\n        self._print_result(result)\n\n        return result\n\n    def profile_operation(\n        self,\n        name: str,\n        operation: Callable\n    ):\n        """Profile operation with cProfile to identify hotspots."""\n        print(f"\\nProfiling: {name}")\n\n        profiler = cProfile.Profile()\n        profiler.enable()\n\n        operation()\n\n        profiler.disable()\n\n        # Print stats\n        stream = StringIO()\n        stats = pstats.Stats(profiler, stream=stream)\n        stats.strip_dirs()\n        stats.sort_stats(\'cumulative\')\n        stats.print_stats(20)  # Top 20 functions\n\n        print(stream.getvalue())\n\n    def _percentile(self, data: List[float], percentile: int) -> float:\n        """Calculate percentile of data."""\n        sorted_data = sorted(data)\n        index = int(len(sorted_data) * percentile / 100)\n        return sorted_data[index]\n\n    def _print_result(self, result: BenchmarkResult):\n        """Print benchmark result."""\n        print(f"  Mean: {result.mean_ms:.2f}ms")\n        print(f"  Median: {result.median_ms:.2f}ms")\n        print(f"  P95: {result.p95_ms:.2f}ms")\n        print(f"  P99: {result.p99_ms:.2f}ms")\n        print(f"  Range: [{result.min_ms:.2f}ms - {result.max_ms:.2f}ms]")\n        print()\n\n    def generate_report(self):\n        """Generate performance benchmark report."""\n        print("=" * 60)\n        print("Performance Benchmark Report")\n        print("=" * 60)\n\n        for result in self.results:\n            status = "✓ PASS" if result.mean_ms < 100 else "⚠ SLOW"\n            print(f"{status} {result.operation_name}: {result.mean_ms:.2f}ms (mean)")\n\n\ndef main():\n    """Run performance benchmarks."""\n    from mycelium.detection import InfraDetector\n    from mycelium.config import ConfigManager, MyceliumConfig\n    from mycelium.generators import DockerComposeGenerator, JustfileGenerator\n\n    benchmark = PerformanceBenchmark(iterations=100)\n\n    # Benchmark detection operations\n    detector = InfraDetector()\n    benchmark.benchmark_operation(\n        "Docker Detection",\n        lambda: detector.detect_docker()\n    )\n    benchmark.benchmark_operation(\n        "Redis Detection",\n        lambda: detector.detect_redis()\n    )\n    benchmark.benchmark_operation(\n        "Full Infrastructure Scan",\n        lambda: detector.scan_all()\n    )\n\n    # Benchmark configuration operations\n    sample_config = MyceliumConfig()\n    benchmark.benchmark_operation(\n        "Configuration Validation",\n        lambda: MyceliumConfig.model_validate(sample_config.model_dump())\n    )\n\n    # Benchmark generation operations\n    docker_gen = DockerComposeGenerator()\n    benchmark.benchmark_operation(\n        "Docker Compose Generation",\n        lambda: docker_gen.generate(sample_config)\n    )\n\n    justfile_gen = JustfileGenerator()\n    benchmark.benchmark_operation(\n        "Justfile Generation",\n        lambda: justfile_gen.generate(sample_config)\n    )\n\n    # Generate report\n    benchmark.generate_report()\n\n    # Profile slowest operation\n    print("\\n" + "=" * 60)\n    print("Detailed Profiling")\n    print("=" * 60)\n    benchmark.profile_operation(\n        "Full Infrastructure Scan (detailed)",\n        lambda: detector.scan_all()\n    )\n\n\nif __name__ == "__main__":\n    main()'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_onboarding_milestones_M10_POLISH_RELEASE_3():
    """Test code snippet from projects/onboarding/milestones/M10_POLISH_RELEASE.md (line 867)."""
    code = '# scripts/generate_changelog.py\n"""Generate changelog from git commits."""\n\nimport subprocess\nimport sys\nfrom datetime import datetime\nfrom typing import List, Dict\nimport re\n\n\ndef get_commits_since_last_tag() -> List[str]:\n    """Get commits since last release tag."""\n    # Get last tag\n    result = subprocess.run(\n        ["git", "describe", "--tags", "--abbrev=0"],\n        capture_output=True,\n        text=True\n    )\n\n    if result.returncode == 0:\n        last_tag = result.stdout.strip()\n        commit_range = f"{last_tag}..HEAD"\n    else:\n        # No previous tags, get all commits\n        commit_range = "HEAD"\n\n    # Get commits\n    result = subprocess.run(\n        ["git", "log", commit_range, "--pretty=format:%H|%s|%an|%ad"],\n        capture_output=True,\n        text=True\n    )\n\n    return result.stdout.strip().split(\'\\n\') if result.stdout else []\n\n\ndef parse_commit(commit_line: str) -> Dict[str, str]:\n    """Parse commit line into structured data."""\n    parts = commit_line.split(\'|\')\n    return {\n        \'hash\': parts[0][:7],\n        \'subject\': parts[1],\n        \'author\': parts[2],\n        \'date\': parts[3],\n    }\n\n\ndef categorize_commits(commits: List[Dict]) -> Dict[str, List[Dict]]:\n    """Categorize commits by type (feat, fix, docs, etc.)."""\n    categories = {\n        \'Features\': [],\n        \'Bug Fixes\': [],\n        \'Documentation\': [],\n        \'Performance\': [],\n        \'Refactoring\': [],\n        \'Testing\': [],\n        \'Chores\': [],\n        \'Other\': [],\n    }\n\n    for commit in commits:\n        subject = commit[\'subject\']\n\n        if re.match(r\'^feat(\\(.*\\))?:\', subject):\n            categories[\'Features\'].append(commit)\n        elif re.match(r\'^fix(\\(.*\\))?:\', subject):\n            categories[\'Bug Fixes\'].append(commit)\n        elif re.match(r\'^docs(\\(.*\\))?:\', subject):\n            categories[\'Documentation\'].append(commit)\n        elif re.match(r\'^perf(\\(.*\\))?:\', subject):\n            categories[\'Performance\'].append(commit)\n        elif re.match(r\'^refactor(\\(.*\\))?:\', subject):\n            categories[\'Refactoring\'].append(commit)\n        elif re.match(r\'^test(\\(.*\\))?:\', subject):\n            categories[\'Testing\'].append(commit)\n        elif re.match(r\'^chore(\\(.*\\))?:\', subject):\n            categories[\'Chores\'].append(commit)\n        else:\n            categories[\'Other\'].append(commit)\n\n    return categories\n\n\ndef generate_changelog(version: str) -> str:\n    """Generate changelog in markdown format."""\n    today = datetime.now(UTC).strftime(\'%Y-%m-%d\')\n\n    changelog = f"# Release {version}\\n\\n"\n    changelog += f"**Release Date**: {today}\\n\\n"\n\n    # Get and parse commits\n    commit_lines = get_commits_since_last_tag()\n    commits = [parse_commit(line) for line in commit_lines if line]\n\n    if not commits:\n        changelog += "No changes since last release.\\n"\n        return changelog\n\n    # Categorize\n    categories = categorize_commits(commits)\n\n    # Generate sections\n    for category, commits_in_category in categories.items():\n        if not commits_in_category:\n            continue\n\n        changelog += f"## {category}\\n\\n"\n\n        for commit in commits_in_category:\n            # Clean up commit subject (remove conventional commit prefix)\n            subject = re.sub(r\'^[a-z]+(\\(.*\\))?:\\s*\', \'\', commit[\'subject\'])\n            changelog += f"- {subject} ([{commit[\'hash\']}](https://github.com/your-org/mycelium/commit/{commit[\'hash\']}))\\n"\n\n        changelog += "\\n"\n\n    # Add contributors\n    contributors = sorted(set(c[\'author\'] for c in commits))\n    changelog += "## Contributors\\n\\n"\n    changelog += "Thank you to all contributors:\\n\\n"\n    for contributor in contributors:\n        changelog += f"- @{contributor}\\n"\n\n    return changelog\n\n\ndef main():\n    """Main entry point."""\n    if len(sys.argv) < 2:\n        print("Usage: python generate_changelog.py <version>")\n        sys.exit(1)\n\n    version = sys.argv[1]\n    changelog = generate_changelog(version)\n\n    print(changelog)\n\n\nif __name__ == "__main__":\n    main()'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_onboarding_milestones_M10_POLISH_RELEASE_4():
    """Test code snippet from projects/onboarding/milestones/M10_POLISH_RELEASE.md (line 1166)."""
    code = '# mycelium/telemetry.py\n"""Optional telemetry for usage analytics (opt-in only)."""\n\nimport os\nimport platform\nfrom typing import Optional\nimport requests\nfrom pathlib import Path\n\n\nclass TelemetryClient:\n    """Client for sending anonymous usage telemetry."""\n\n    TELEMETRY_ENDPOINT = "https://telemetry.mycelium.dev/v1/events"\n\n    def __init__(self):\n        self.enabled = self._check_telemetry_enabled()\n        self.session_id = self._generate_session_id()\n\n    def _check_telemetry_enabled(self) -> bool:\n        """Check if user has opted into telemetry."""\n        # Check environment variable\n        if os.getenv("MYCELIUM_TELEMETRY", "0") == "1":\n            return True\n\n        # Check config file\n        config_file = Path.home() / ".config" / "mycelium" / "telemetry"\n        return config_file.exists()\n\n    def _generate_session_id(self) -> str:\n        """Generate anonymous session ID."""\n        import uuid\n        return str(uuid.uuid4())\n\n    def track_event(\n        self,\n        event_name: str,\n        properties: Optional[dict] = None\n    ):\n        """Track usage event (async, non-blocking)."""\n        if not self.enabled:\n            return\n\n        event_data = {\n            "event": event_name,\n            "properties": properties or {},\n            "session_id": self.session_id,\n            "platform": platform.system(),\n            "python_version": platform.python_version(),\n        }\n\n        # Send asynchronously, don\'t block on failure\n        try:\n            requests.post(\n                self.TELEMETRY_ENDPOINT,\n                json=event_data,\n                timeout=1.0\n            )\n        except Exception:\n            # Silently fail, never disrupt user experience\n            pass\n\n\n# Global telemetry client\ntelemetry = TelemetryClient()\n\n\n# Example usage in code\ndef track_wizard_completion(deployment_method: str):\n    """Track wizard completion event."""\n    telemetry.track_event("wizard_completed", {\n        "deployment_method": deployment_method\n    })'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_onboarding_templates_task_template_1():
    """Test code snippet from projects/onboarding/templates/task_template.md (line 34)."""
    code = '# Example implementation demonstrating key concepts\n# Include type hints, docstrings, and error handling\n\ndef example_function(param: str) -> dict:\n    """Clear docstring explaining purpose and usage.\n\n    Args:\n        param: Description of parameter\n\n    Returns:\n        Description of return value\n\n    Raises:\n        Exception: When this error occurs\n    """\n    # Implementation here\n    pass'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_projects_onboarding_templates_task_template_2():
    """Test code snippet from projects/onboarding/templates/task_template.md (line 136)."""
    code = '# mycelium/generators/justfile.py\n"""Justfile generator for native service deployment."""\n\nfrom jinja2 import Environment, FileSystemLoader\nfrom pathlib import Path\nfrom mycelium.config import MyceliumConfig\n\n\nclass JustfileGenerator:\n    """Generates Justfile configuration from MyceliumConfig."""\n\n    TEMPLATE_NAME = "justfile.j2"\n\n    def __init__(self):\n        template_dir = Path(__file__).parent.parent / "templates"\n        self.env = Environment(loader=FileSystemLoader(template_dir))\n\n    def generate(self, config: MyceliumConfig) -> str:\n        """Generate Justfile from configuration.\n\n        Args:\n            config: Configuration specifying enabled services\n\n        Returns:\n            Rendered Justfile content as string\n\n        Raises:\n            ValueError: If configuration is invalid for native deployment\n        """\n        if config.deployment.method != "justfile":\n            raise ValueError(\n                f"Config deployment method is {config.deployment.method}, "\n                "expected \'justfile\'"\n            )\n\n        template = self.env.get_template(self.TEMPLATE_NAME)\n\n        context = {\n            \'config\': config,\n            \'services\': self._get_enabled_services(config),\n        }\n\n        return template.render(**context)\n\n    def _get_enabled_services(self, config: MyceliumConfig) -> list[str]:\n        """Extract list of enabled service names."""\n        services = []\n        if config.services.redis.enabled:\n            services.append(\'redis\')\n        if config.services.postgres.enabled:\n            services.append(\'postgres\')\n        return services'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_skills_S1_agent_discovery_fastmcp_1():
    """Test code snippet from skills/S1-agent-discovery-fastmcp.md (line 18)."""
    code = 'from pydantic import BaseModel, Field, field_validator\nfrom typing import List, Optional\nfrom enum import Enum\n\nclass AgentCategory(str, Enum):\n    """Agent categories for filtering."""\n    CORE = "core"\n    SPECIALIZED = "specialized"\n    INFRASTRUCTURE = "infrastructure"\n    ANALYSIS = "analysis"\n    SECURITY = "security"\n    TESTING = "testing"\n\n\nclass DiscoverAgentsRequest(BaseModel):\n    """Request model for discover_agents tool."""\n\n    query: str = Field(\n        ...,\n        description="Natural language description of desired capabilities",\n        min_length=1,\n        max_length=500,\n        examples=["Python backend development", "database optimization"]\n    )\n\n    limit: int = Field(\n        default=5,\n        ge=1,\n        le=20,\n        description="Maximum number of agents to return"\n    )\n\n    threshold: float = Field(\n        default=0.6,\n        ge=0.0,\n        le=1.0,\n        description="Minimum confidence threshold (0.0-1.0)"\n    )\n\n    category_filter: Optional[AgentCategory] = Field(\n        default=None,\n        description="Optional category filter"\n    )\n\n    @field_validator(\'query\')\n    @classmethod\n    def query_not_empty(cls, v: str) -> str:\n        """Ensure query is not just whitespace."""\n        if not v.strip():\n            raise ValueError(\'Query cannot be empty or whitespace\')\n        return v.strip()\n\n\nclass GetAgentDetailsRequest(BaseModel):\n    """Request model for get_agent_details tool."""\n\n    agent_id: str = Field(\n        ...,\n        description="Agent ID or agent type",\n        min_length=1,\n        examples=["backend-developer", "python-pro", "01-core-backend-developer"]\n    )\n\n    @field_validator(\'agent_id\')\n    @classmethod\n    def agent_id_valid(cls, v: str) -> str:\n        """Validate agent_id format."""\n        if not v.strip():\n            raise ValueError(\'agent_id cannot be empty\')\n        return v.strip()'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_skills_S1_agent_discovery_fastmcp_2():
    """Test code snippet from skills/S1-agent-discovery-fastmcp.md (line 93)."""
    code = 'from datetime import datetime\nfrom typing import List, Optional, Dict, Any\n\n\nclass AgentMatch(BaseModel):\n    """Single agent match result."""\n\n    id: str = Field(..., description="Agent identifier")\n    type: str = Field(..., description="Agent type")\n    name: str = Field(..., description="Agent display name")\n    display_name: str = Field(..., description="Formatted display name")\n    category: AgentCategory = Field(..., description="Agent category")\n    description: str = Field(..., description="Agent description")\n\n    capabilities: List[str] = Field(\n        default_factory=list,\n        description="Agent capabilities"\n    )\n\n    tools: List[str] = Field(\n        default_factory=list,\n        description="Tools the agent uses"\n    )\n\n    keywords: List[str] = Field(\n        default_factory=list,\n        description="Keywords for matching"\n    )\n\n    confidence: float = Field(\n        ...,\n        ge=0.0,\n        le=1.0,\n        description="Match confidence score"\n    )\n\n    match_reason: str = Field(\n        ...,\n        description="Explanation of why agent matched"\n    )\n\n    estimated_tokens: int = Field(\n        default=0,\n        ge=0,\n        description="Estimated token count for agent"\n    )\n\n    avg_response_time_ms: float = Field(\n        default=0.0,\n        ge=0.0,\n        description="Average response time in milliseconds"\n    )\n\n\nclass DiscoverAgentsResponse(BaseModel):\n    """Response model for discover_agents tool."""\n\n    success: bool = Field(default=True, description="Request success status")\n    query: str = Field(..., description="Original query")\n\n    agents: List[AgentMatch] = Field(\n        default_factory=list,\n        description="Matching agents"\n    )\n\n    total_count: int = Field(\n        ...,\n        ge=0,\n        description="Total number of matches"\n    )\n\n    processing_time_ms: float = Field(\n        ...,\n        ge=0.0,\n        description="Processing time in milliseconds"\n    )\n\n\nclass AgentDetailsMetadata(BaseModel):\n    """Agent metadata."""\n\n    dependencies: List[str] = Field(\n        default_factory=list,\n        description="Agent dependencies"\n    )\n\n    examples: List[str] = Field(\n        default_factory=list,\n        description="Example use cases"\n    )\n\n    tags: List[str] = Field(\n        default_factory=list,\n        description="Additional tags"\n    )\n\n\nclass AgentDetails(BaseModel):\n    """Detailed agent information."""\n\n    id: str\n    type: str\n    name: str\n    display_name: str\n    category: AgentCategory\n    description: str\n    capabilities: List[str]\n    tools: List[str]\n    keywords: List[str]\n\n    file_path: str = Field(..., description="Path to agent definition file")\n    estimated_tokens: int\n    avg_response_time_ms: float\n\n    success_rate: float = Field(\n        default=0.95,\n        ge=0.0,\n        le=1.0,\n        description="Historical success rate"\n    )\n\n    usage_count: int = Field(\n        default=0,\n        ge=0,\n        description="Number of times agent has been used"\n    )\n\n    created_at: datetime = Field(\n        default_factory=datetime.now,\n        description="Agent creation timestamp"\n    )\n\n    updated_at: datetime = Field(\n        default_factory=datetime.now,\n        description="Last update timestamp"\n    )\n\n    last_used_at: Optional[datetime] = Field(\n        default=None,\n        description="Last usage timestamp"\n    )\n\n\nclass GetAgentDetailsResponse(BaseModel):\n    """Response model for get_agent_details tool."""\n\n    success: bool = Field(default=True)\n    agent: AgentDetails = Field(..., description="Agent details")\n    metadata: AgentDetailsMetadata = Field(\n        default_factory=AgentDetailsMetadata,\n        description="Additional metadata"\n    )'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_skills_S1_agent_discovery_fastmcp_3():
    """Test code snippet from skills/S1-agent-discovery-fastmcp.md (line 254)."""
    code = 'from fastmcp import FastMCP\nfrom fastmcp.tools import Tool\n\n# Initialize FastMCP server\nmcp = FastMCP("Mycelium Agent Discovery")\n\n\n@mcp.tool()\nasync def discover_agents(\n    request: DiscoverAgentsRequest\n) -> DiscoverAgentsResponse:\n    """\n    Discover agents using natural language query.\n\n    This tool enables Claude Code to find appropriate agents based on\n    task descriptions, capabilities, or domain expertise.\n\n    Args:\n        request: Discovery request with query and filters\n\n    Returns:\n        Matching agents with confidence scores\n\n    Example:\n        >>> request = DiscoverAgentsRequest(\n        ...     query="Python backend development",\n        ...     limit=5,\n        ...     threshold=0.7\n        ... )\n        >>> response = await discover_agents(request)\n        >>> print(response.agents[0].name)\n        "Backend Developer"\n    """\n    import time\n    from mycelium_core.agent_discovery import AgentDiscoveryService\n\n    start_time = time.perf_counter()\n\n    # Initialize discovery service\n    service = AgentDiscoveryService()\n\n    # Execute search\n    matches = await service.search(\n        query=request.query,\n        limit=request.limit,\n        threshold=request.threshold,\n        category_filter=request.category_filter.value if request.category_filter else None\n    )\n\n    # Convert to response model\n    agents = [\n        AgentMatch(\n            id=match["id"],\n            type=match["type"],\n            name=match["name"],\n            display_name=match["display_name"],\n            category=match["category"],\n            description=match["description"],\n            capabilities=match.get("capabilities", []),\n            tools=match.get("tools", []),\n            keywords=match.get("keywords", []),\n            confidence=match["confidence"],\n            match_reason=match["match_reason"],\n            estimated_tokens=match.get("estimated_tokens", 0),\n            avg_response_time_ms=match.get("avg_response_time_ms", 0.0)\n        )\n        for match in matches\n    ]\n\n    processing_time_ms = (time.perf_counter() - start_time) * 1000\n\n    return DiscoverAgentsResponse(\n        success=True,\n        query=request.query,\n        agents=agents,\n        total_count=len(agents),\n        processing_time_ms=processing_time_ms\n    )\n\n\n@mcp.tool()\nasync def get_agent_details(\n    request: GetAgentDetailsRequest\n) -> GetAgentDetailsResponse:\n    """\n    Get detailed information about a specific agent.\n\n    This tool retrieves comprehensive metadata about an agent including\n    capabilities, performance metrics, and usage statistics.\n\n    Args:\n        request: Request with agent_id\n\n    Returns:\n        Detailed agent information\n\n    Example:\n        >>> request = GetAgentDetailsRequest(agent_id="backend-developer")\n        >>> response = await get_agent_details(request)\n        >>> print(response.agent.description)\n        "Expert in full-stack backend development..."\n    """\n    from mycelium_core.agent_discovery import AgentDiscoveryService\n\n    service = AgentDiscoveryService()\n\n    # Fetch agent details\n    details = await service.get_details(request.agent_id)\n\n    if not details:\n        raise ValueError(f"Agent not found: {request.agent_id}")\n\n    # Convert to response model\n    agent = AgentDetails(\n        id=details["id"],\n        type=details["type"],\n        name=details["name"],\n        display_name=details["display_name"],\n        category=details["category"],\n        description=details["description"],\n        capabilities=details.get("capabilities", []),\n        tools=details.get("tools", []),\n        keywords=details.get("keywords", []),\n        file_path=details["file_path"],\n        estimated_tokens=details.get("estimated_tokens", 0),\n        avg_response_time_ms=details.get("avg_response_time_ms", 0.0),\n        success_rate=details.get("success_rate", 0.95),\n        usage_count=details.get("usage_count", 0),\n        created_at=details.get("created_at", datetime.now(UTC)),\n        updated_at=details.get("updated_at", datetime.now(UTC)),\n        last_used_at=details.get("last_used_at")\n    )\n\n    metadata = AgentDetailsMetadata(\n        dependencies=details.get("dependencies", []),\n        examples=details.get("examples", []),\n        tags=details.get("tags", [])\n    )\n\n    return GetAgentDetailsResponse(\n        success=True,\n        agent=agent,\n        metadata=metadata\n    )\n\n\n# Error handling middleware\n@mcp.error_handler()\nasync def handle_discovery_error(error: Exception) -> Dict[str, Any]:\n    """Handle discovery errors gracefully."""\n    import logging\n\n    logger = logging.getLogger("mycelium.discovery")\n    logger.error(f"Discovery error: {error}", exc_info=True)\n\n    return {\n        "success": False,\n        "error": str(error),\n        "error_type": type(error).__name__\n    }'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_skills_S1_agent_discovery_fastmcp_4():
    """Test code snippet from skills/S1-agent-discovery-fastmcp.md (line 423)."""
    code = 'from typing import List, Dict, Any, Optional\nfrom mycelium_core.registry import AgentRegistry\nfrom mycelium_core.matching import NLPMatcher\n\n\nclass AgentDiscoveryService:\n    """Agent discovery service with NLP matching."""\n\n    def __init__(self):\n        """Initialize discovery service."""\n        self.registry = AgentRegistry()\n        self.matcher = NLPMatcher()\n\n    async def search(\n        self,\n        query: str,\n        limit: int = 5,\n        threshold: float = 0.6,\n        category_filter: Optional[str] = None\n    ) -> List[Dict[str, Any]]:\n        """\n        Search for agents matching query.\n\n        Args:\n            query: Search query\n            limit: Maximum results\n            threshold: Minimum confidence\n            category_filter: Optional category\n\n        Returns:\n            List of matching agents with scores\n        """\n        # Get all agents from registry\n        agents = await self.registry.get_all_agents()\n\n        # Filter by category if specified\n        if category_filter:\n            agents = [a for a in agents if a.get("category") == category_filter]\n\n        # Generate embeddings and compute similarity\n        matches = await self.matcher.match(\n            query=query,\n            candidates=agents,\n            threshold=threshold\n        )\n\n        # Sort by confidence and limit results\n        matches.sort(key=lambda m: m["confidence"], reverse=True)\n        matches = matches[:limit]\n\n        return matches\n\n    async def get_details(self, agent_id: str) -> Optional[Dict[str, Any]]:\n        """\n        Get detailed agent information.\n\n        Args:\n            agent_id: Agent identifier\n\n        Returns:\n            Agent details or None if not found\n        """\n        return await self.registry.get_agent(agent_id)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_skills_S1_agent_discovery_fastmcp_5():
    """Test code snippet from skills/S1-agent-discovery-fastmcp.md (line 491)."""
    code = 'from typing import List, Dict, Any\nimport numpy as np\nfrom sentence_transformers import SentenceTransformer\nfrom sklearn.metrics.pairwise import cosine_similarity\n\n\nclass NLPMatcher:\n    """NLP-based agent matching using sentence embeddings."""\n\n    def __init__(self, model_name: str = "all-MiniLM-L6-v2"):\n        """\n        Initialize matcher with sentence transformer.\n\n        Args:\n            model_name: HuggingFace model name\n        """\n        self.model = SentenceTransformer(model_name)\n        self.agent_embeddings = {}\n\n    async def match(\n        self,\n        query: str,\n        candidates: List[Dict[str, Any]],\n        threshold: float = 0.6\n    ) -> List[Dict[str, Any]]:\n        """\n        Match query against candidate agents.\n\n        Args:\n            query: Search query\n            candidates: Agent candidates\n            threshold: Minimum confidence\n\n        Returns:\n            Matched agents with confidence scores\n        """\n        # Generate query embedding\n        query_embedding = self.model.encode([query])[0]\n\n        matches = []\n        for agent in candidates:\n            # Generate or retrieve agent embedding\n            agent_key = agent["id"]\n            if agent_key not in self.agent_embeddings:\n                agent_text = self._prepare_agent_text(agent)\n                agent_embedding = self.model.encode([agent_text])[0]\n                self.agent_embeddings[agent_key] = agent_embedding\n            else:\n                agent_embedding = self.agent_embeddings[agent_key]\n\n            # Compute similarity\n            similarity = cosine_similarity(\n                [query_embedding],\n                [agent_embedding]\n            )[0][0]\n\n            # Apply threshold\n            if similarity >= threshold:\n                matches.append({\n                    **agent,\n                    "confidence": float(similarity),\n                    "match_reason": self._explain_match(query, agent, similarity)\n                })\n\n        return matches\n\n    def _prepare_agent_text(self, agent: Dict[str, Any]) -> str:\n        """\n        Prepare agent text for embedding.\n\n        Args:\n            agent: Agent metadata\n\n        Returns:\n            Combined text representation\n        """\n        parts = [\n            agent.get("name", ""),\n            agent.get("description", ""),\n            " ".join(agent.get("capabilities", [])),\n            " ".join(agent.get("keywords", []))\n        ]\n        return " ".join(filter(None, parts))\n\n    def _explain_match(\n        self,\n        query: str,\n        agent: Dict[str, Any],\n        score: float\n    ) -> str:\n        """\n        Generate match explanation.\n\n        Args:\n            query: Search query\n            agent: Agent metadata\n            score: Similarity score\n\n        Returns:\n            Human-readable explanation\n        """\n        query_words = set(query.lower().split())\n        agent_keywords = set(agent.get("keywords", []))\n\n        matches = query_words.intersection(agent_keywords)\n\n        if matches:\n            return f"Matches keywords: {\', \'.join(matches)}"\n        else:\n            return agent.get("description", "")[:100]'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_skills_S1_agent_discovery_fastmcp_6():
    """Test code snippet from skills/S1-agent-discovery-fastmcp.md (line 610)."""
    code = 'from mycelium_core.mcp.tools.discovery_tools import discover_agents, DiscoverAgentsRequest\n\n# Create request\nrequest = DiscoverAgentsRequest(\n    query="Python backend API development",\n    limit=5,\n    threshold=0.7\n)\n\n# Execute discovery\nresponse = await discover_agents(request)\n\n# Process results\nprint(f"Found {response.total_count} agents in {response.processing_time_ms}ms")\nfor agent in response.agents:\n    print(f"{agent.name} (confidence: {agent.confidence:.2f})")\n    print(f"  Reason: {agent.match_reason}")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_skills_S1_agent_discovery_fastmcp_7():
    """Test code snippet from skills/S1-agent-discovery-fastmcp.md (line 632)."""
    code = 'from typing import List\n\nasync def find_best_agent(task: str) -> Optional[AgentMatch]:\n    """Find best agent for task with type safety."""\n    request = DiscoverAgentsRequest(\n        query=task,\n        limit=1,\n        threshold=0.8\n    )\n\n    response: DiscoverAgentsResponse = await discover_agents(request)\n\n    if response.agents:\n        return response.agents[0]\n    else:\n        return None\n\n# Usage\nbest_agent = await find_best_agent("database performance optimization")\nif best_agent:\n    print(f"Using: {best_agent.name}")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_skills_S1_agent_discovery_fastmcp_8():
    """Test code snippet from skills/S1-agent-discovery-fastmcp.md (line 658)."""
    code = 'async def find_security_agents(task: str) -> List[AgentMatch]:\n    """Find security-focused agents."""\n    request = DiscoverAgentsRequest(\n        query=task,\n        limit=5,\n        threshold=0.6,\n        category_filter=AgentCategory.SECURITY\n    )\n\n    response = await discover_agents(request)\n    return response.agents\n\n# Usage\nsecurity_experts = await find_security_agents("authentication audit")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_skills_S1_agent_discovery_fastmcp_9():
    """Test code snippet from skills/S1-agent-discovery-fastmcp.md (line 681)."""
    code = 'import pytest\nfrom pydantic import ValidationError\n\n\ndef test_discover_agents_request_validation():\n    """Test request model validation."""\n\n    # Valid request\n    request = DiscoverAgentsRequest(\n        query="Python development",\n        limit=5\n    )\n    assert request.query == "Python development"\n    assert request.limit == 5\n    assert request.threshold == 0.6  # default\n\n    # Invalid: empty query\n    with pytest.raises(ValidationError):\n        DiscoverAgentsRequest(query="")\n\n    # Invalid: limit out of range\n    with pytest.raises(ValidationError):\n        DiscoverAgentsRequest(query="test", limit=0)\n\n    with pytest.raises(ValidationError):\n        DiscoverAgentsRequest(query="test", limit=100)\n\n    # Invalid: threshold out of range\n    with pytest.raises(ValidationError):\n        DiscoverAgentsRequest(query="test", threshold=1.5)\n\n\ndef test_get_agent_details_request_validation():\n    """Test agent details request validation."""\n\n    # Valid request\n    request = GetAgentDetailsRequest(agent_id="backend-developer")\n    assert request.agent_id == "backend-developer"\n\n    # Invalid: empty agent_id\n    with pytest.raises(ValidationError):\n        GetAgentDetailsRequest(agent_id="")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_skills_S1_agent_discovery_fastmcp_10():
    """Test code snippet from skills/S1-agent-discovery-fastmcp.md (line 728)."""
    code = 'def test_agent_match_model():\n    """Test agent match model."""\n    match = AgentMatch(\n        id="test-agent",\n        type="test",\n        name="Test Agent",\n        display_name="Test Agent",\n        category=AgentCategory.CORE,\n        description="Test description",\n        confidence=0.95,\n        match_reason="Test match"\n    )\n\n    assert match.id == "test-agent"\n    assert match.confidence == 0.95\n    assert 0.0 <= match.confidence <= 1.0\n\n\ndef test_discover_agents_response_serialization():\n    """Test response serialization."""\n    response = DiscoverAgentsResponse(\n        success=True,\n        query="test",\n        agents=[],\n        total_count=0,\n        processing_time_ms=10.5\n    )\n\n    # Serialize to dict\n    data = response.model_dump()\n    assert data["success"] is True\n    assert data["query"] == "test"\n\n    # Serialize to JSON\n    json_str = response.model_dump_json()\n    assert "test" in json_str'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_skills_S1_agent_discovery_fastmcp_11():
    """Test code snippet from skills/S1-agent-discovery-fastmcp.md (line 773)."""
    code = '# config/fastmcp.yaml\nserver:\n  name: "Mycelium Agent Discovery"\n  version: "1.0.0"\n  description: "Agent discovery with NLP matching"\n\ntools:\n  discover_agents:\n    enabled: true\n    timeout_seconds: 30\n    rate_limit: 100  # requests per minute\n\n  get_agent_details:\n    enabled: true\n    timeout_seconds: 10\n    rate_limit: 200\n\nregistry:\n  database_url: "postgresql://localhost:5432/mycelium_registry"\n  cache_ttl_seconds: 3600\n  embeddings_cache_size: 1000\n\nnlp:\n  model: "all-MiniLM-L6-v2"\n  batch_size: 32\n  device: "cpu"  # or "cuda"'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_skills_S1_agent_discovery_fastmcp_12():
    """Test code snippet from skills/S1-agent-discovery-fastmcp.md (line 825)."""
    code = 'from functools import lru_cache\nfrom typing import Dict, Any\n\nclass CachedNLPMatcher(NLPMatcher):\n    """NLP matcher with LRU caching."""\n\n    @lru_cache(maxsize=1000)\n    def _get_query_embedding(self, query: str) -> np.ndarray:\n        """Cache query embeddings."""\n        return self.model.encode([query])[0]\n\n    async def match(\n        self,\n        query: str,\n        candidates: List[Dict[str, Any]],\n        threshold: float = 0.6\n    ) -> List[Dict[str, Any]]:\n        """Match with cached embeddings."""\n        # Use cached query embedding\n        query_embedding = self._get_query_embedding(query)\n\n        # Rest of matching logic...'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_skills_S1_agent_discovery_fastmcp_13():
    """Test code snippet from skills/S1-agent-discovery-fastmcp.md (line 852)."""
    code = 'async def batch_discover(\n    queries: List[str],\n    limit: int = 5\n) -> List[DiscoverAgentsResponse]:\n    """Batch process multiple discovery queries."""\n    import asyncio\n\n    requests = [\n        DiscoverAgentsRequest(query=q, limit=limit)\n        for q in queries\n    ]\n\n    # Process in parallel\n    responses = await asyncio.gather(*[\n        discover_agents(req) for req in requests\n    ])\n\n    return responses\n\n# Usage\nqueries = ["Python dev", "database optimization", "security audit"]\nresults = await batch_discover(queries)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_skills_S1_agent_discovery_fastmcp_14():
    """Test code snippet from skills/S1-agent-discovery-fastmcp.md (line 883)."""
    code = 'from mycelium_analytics import TelemetryCollector\n\nclass InstrumentedDiscoveryService(AgentDiscoveryService):\n    """Discovery service with telemetry."""\n\n    def __init__(self):\n        super().__init__()\n        self.telemetry = TelemetryCollector()\n\n    async def search(self, query: str, **kwargs) -> List[Dict[str, Any]]:\n        """Search with telemetry."""\n        import time\n\n        start = time.perf_counter()\n\n        try:\n            results = await super().search(query, **kwargs)\n\n            # Record success metrics\n            self.telemetry.record_event(\n                event_type="discovery_search",\n                data={\n                    "query": query,\n                    "results_count": len(results),\n                    "latency_ms": (time.perf_counter() - start) * 1000,\n                    "success": True\n                }\n            )\n\n            return results\n\n        except Exception as e:\n            # Record failure metrics\n            self.telemetry.record_event(\n                event_type="discovery_search",\n                data={\n                    "query": query,\n                    "latency_ms": (time.perf_counter() - start) * 1000,\n                    "success": False,\n                    "error": str(e)\n                }\n            )\n            raise'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_skills_S1_agent_discovery_fastmcp_15():
    """Test code snippet from skills/S1-agent-discovery-fastmcp.md (line 935)."""
    code = '# Before (Legacy)\nfrom scripts.agent_discovery import AgentDiscovery\n\ndiscovery = AgentDiscovery()\nresults = discovery.search("Python development")\n\n# After (FastMCP)\nfrom mycelium_core.mcp.tools.discovery_tools import discover_agents, DiscoverAgentsRequest\n\nrequest = DiscoverAgentsRequest(query="Python development")\nresponse = await discover_agents(request)\nresults = [agent.model_dump() for agent in response.agents]'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_skills_S1_agent_discovery_1():
    """Test code snippet from skills/S1-agent-discovery.md (line 38)."""
    code = 'async def discover_agents(\n    query: str,\n    limit: int = 5,\n    threshold: float = 0.6,\n) -> dict'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_skills_S1_agent_discovery_2():
    """Test code snippet from skills/S1-agent-discovery.md (line 86)."""
    code = '# Basic discovery\nresult = await discover_agents("I need help with Python development")\n\n# Specific requirements with higher confidence\nresult = await discover_agents(\n    query="PostgreSQL performance tuning and query optimization",\n    limit=3,\n    threshold=0.8\n)\n\n# Broad search for multiple options\nresult = await discover_agents(\n    query="frontend development",\n    limit=10,\n    threshold=0.5\n)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_skills_S1_agent_discovery_3():
    """Test code snippet from skills/S1-agent-discovery.md (line 110)."""
    code = 'async def get_agent_details(\n    agent_id: str,\n) -> dict'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_skills_S1_agent_discovery_4():
    """Test code snippet from skills/S1-agent-discovery.md (line 157)."""
    code = '# Get details by agent ID\nresult = await get_agent_details("backend-developer")\n\n# Get details by agent type (file prefix)\nresult = await get_agent_details("01-core-backend-developer")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_skills_S1_agent_discovery_5():
    """Test code snippet from skills/S1-agent-discovery.md (line 171)."""
    code = '# 1. Discover agents for the task\nresult = await discover_agents(\n    query="optimize slow PostgreSQL queries",\n    limit=3,\n    threshold=0.7\n)\n\n# 2. Review top matches\nfor agent in result["agents"]:\n    print(f"{agent[\'name\']} (confidence: {agent[\'confidence\']})")\n    print(f"  Reason: {agent[\'match_reason\']}")\n    print(f"  Capabilities: {\', \'.join(agent[\'capabilities\'])}")\n\n# 3. Get detailed information about top choice\nif result["agents"]:\n    top_agent = result["agents"][0]\n    details = await get_agent_details(top_agent["id"])\n    # Use agent based on detailed capabilities'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_skills_S1_agent_discovery_6():
    """Test code snippet from skills/S1-agent-discovery.md (line 196)."""
    code = '# Broad search to see available options\nresult = await discover_agents(\n    query="web development",\n    limit=10,\n    threshold=0.5  # Lower threshold for exploration\n)\n\n# Review categories of agents found\ncategories = {}\nfor agent in result["agents"]:\n    cat = agent["category"]\n    if cat not in categories:\n        categories[cat] = []\n    categories[cat].append(agent["name"])\n\n# Examine specific agents of interest\nfor agent_id in interesting_agents:\n    details = await get_agent_details(agent_id)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_skills_S1_agent_discovery_7():
    """Test code snippet from skills/S1-agent-discovery.md (line 221)."""
    code = '# Find specialists for different aspects\nbackend_agents = await discover_agents("backend API development")\nfrontend_agents = await discover_agents("React frontend development")\ndatabase_agents = await discover_agents("database design and optimization")\n\n# Combine into workflow team\nteam = []\nif backend_agents["agents"]:\n    team.append(backend_agents["agents"][0])\nif frontend_agents["agents"]:\n    team.append(frontend_agents["agents"][0])\nif database_agents["agents"]:\n    team.append(database_agents["agents"][0])\n\n# Get detailed info for each team member\nfor agent in team:\n    details = await get_agent_details(agent["id"])\n    # Plan workflow based on capabilities'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_skills_S1_agent_discovery_8():
    """Test code snippet from skills/S1-agent-discovery.md (line 276)."""
    code = '# Discover agents for workflow steps\nstep1_agents = await discover_agents("data validation")\nstep2_agents = await discover_agents("database migration")\nstep3_agents = await discover_agents("API endpoint creation")\n\n# Coordinate workflow (S2 skill)\nawait coordinate_workflow(\n    steps=[\n        {"agent": step1_agents["agents"][0]["id"], "task": "Validate data"},\n        {"agent": step2_agents["agents"][0]["id"], "task": "Migrate schema"},\n        {"agent": step3_agents["agents"][0]["id"], "task": "Create endpoints"},\n    ]\n)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_skills_S1_agent_discovery_9():
    """Test code snippet from skills/S1-agent-discovery.md (line 329)."""
    code = 'try:\n    result = await discover_agents("Python development")\n    if not result["agents"]:\n        print("No agents found for query")\n        # Provide fallback or ask user to refine\n    else:\n        # Use discovered agents\n        pass\nexcept DiscoveryTimeoutError:\n    print("Discovery timed out, try again")\nexcept DiscoveryAPIError as e:\n    print(f"Discovery failed: {e}")\n    # Fall back to known agents or manual selection'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_skills_S1_agent_discovery_10():
    """Test code snippet from skills/S1-agent-discovery.md (line 413)."""
    code = '# Check API health\nfrom mcp.tools.discovery_tools import check_discovery_health\n\nhealth = await check_discovery_health()\nprint(f"Status: {health[\'status\']}")\nprint(f"Agents: {health[\'agent_count\']}")\n\n# Test with broad query\nresult = await discover_agents("development", limit=20, threshold=0.3)\nprint(f"Found {result[\'total_count\']} agents")\n\n# Verify specific agent exists\ntry:\n    details = await get_agent_details("backend-developer")\n    print(f"Agent found: {details[\'agent\'][\'name\']}")\nexcept DiscoveryAPIError:\n    print("Agent not in registry")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_skills_S2_coordination_1():
    """Test code snippet from skills/S2-coordination.md (line 47)."""
    code = 'async def coordinate_workflow(\n    steps: List[Dict],\n    execution_mode: str = "sequential",\n    failure_strategy: str = "retry",\n) -> dict'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_skills_S2_coordination_2():
    """Test code snippet from skills/S2-coordination.md (line 96)."""
    code = '# Sequential code review workflow\nworkflow = await coordinate_workflow(\n    steps=[\n        {\n            "agent": "python-pro",\n            "task": "Review code style and best practices",\n            "params": {"file": "api.py"}\n        },\n        {\n            "agent": "security-expert",\n            "task": "Security audit focusing on authentication",\n            "depends_on": ["step-0"],\n            "params": {"file": "api.py"}\n        },\n        {\n            "agent": "performance-optimizer",\n            "task": "Performance analysis and recommendations",\n            "depends_on": ["step-0"],\n            "params": {"file": "api.py"}\n        }\n    ],\n    execution_mode="sequential",\n    failure_strategy="retry"\n)\n\n# Parallel data processing workflow\nworkflow = await coordinate_workflow(\n    steps=[\n        {\n            "agent": "data-engineer",\n            "task": "Process dataset A",\n            "params": {"dataset": "customers.csv"}\n        },\n        {\n            "agent": "data-engineer",\n            "task": "Process dataset B",\n            "params": {"dataset": "orders.csv"}\n        },\n        {\n            "agent": "ml-engineer",\n            "task": "Train model on combined data",\n            "depends_on": ["step-0", "step-1"],\n            "params": {"model_type": "random_forest"}\n        }\n    ],\n    execution_mode="parallel"\n)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_skills_S2_coordination_3():
    """Test code snippet from skills/S2-coordination.md (line 151)."""
    code = 'async def handoff_to_agent(\n    target_agent: str,\n    task: str,\n    context: Dict = None,\n    wait_for_completion: bool = True,\n) -> dict'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_skills_S2_coordination_4():
    """Test code snippet from skills/S2-coordination.md (line 196)."""
    code = '# Simple handoff with context\nresult = await handoff_to_agent(\n    target_agent="security-expert",\n    task="Review authentication implementation in auth.py",\n    context={\n        "files": ["auth.py", "models/user.py"],\n        "concerns": ["password hashing", "session management"]\n    }\n)\n\n# Handoff without waiting\nresult = await handoff_to_agent(\n    target_agent="documentation-specialist",\n    task="Update API documentation",\n    wait_for_completion=False\n)\n# Returns immediately with handoff_id for later status check'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_skills_S2_coordination_5():
    """Test code snippet from skills/S2-coordination.md (line 221)."""
    code = 'async def get_workflow_status(\n    workflow_id: str,\n    include_steps: bool = True,\n) -> dict'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_skills_S2_coordination_6():
    """Test code snippet from skills/S2-coordination.md (line 281)."""
    code = '# Check workflow progress\nstatus = await get_workflow_status("wf-abc-123")\n\nif status["status"] == "in_progress":\n    print(f"Progress: {status[\'progress_percent\']}%")\n    print(f"Current step: {status[\'current_step\']} of {status[\'steps_total\']}")\n\n# Lightweight status check without step details\nstatus = await get_workflow_status("wf-abc-123", include_steps=False)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_skills_S2_coordination_7():
    """Test code snippet from skills/S2-coordination.md (line 298)."""
    code = 'async def get_coordination_events(\n    workflow_id: str = None,\n    agent_id: str = None,\n    event_type: str = None,\n    limit: int = 100,\n) -> dict'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_skills_S2_coordination_8():
    """Test code snippet from skills/S2-coordination.md (line 340)."""
    code = '# Get all events for a workflow\nevents = await get_coordination_events(workflow_id="wf-abc-123")\n\n# Get handoff events only\nevents = await get_coordination_events(\n    event_type="handoff",\n    limit=50\n)\n\n# Get events for a specific agent\nevents = await get_coordination_events(\n    agent_id="security-expert",\n    limit=20\n)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_skills_S2_coordination_9():
    """Test code snippet from skills/S2-coordination.md (line 363)."""
    code = '# 1. Discover review agents\nstyle_agent = await discover_agents("Python code style review", limit=1)\nsecurity_agent = await discover_agents("security audit", limit=1)\nperf_agent = await discover_agents("performance optimization", limit=1)\n\n# 2. Create workflow\nworkflow = await coordinate_workflow(\n    steps=[\n        {\n            "agent": style_agent["agents"][0]["id"],\n            "task": "Review code style, structure, and best practices",\n            "params": {"file": "api/endpoints.py"}\n        },\n        {\n            "agent": security_agent["agents"][0]["id"],\n            "task": "Audit for security vulnerabilities",\n            "depends_on": ["step-0"],\n            "params": {\n                "file": "api/endpoints.py",\n                "focus": ["authentication", "injection", "validation"]\n            }\n        },\n        {\n            "agent": perf_agent["agents"][0]["id"],\n            "task": "Analyze performance and suggest optimizations",\n            "depends_on": ["step-0", "step-1"],\n            "params": {"file": "api/endpoints.py"}\n        }\n    ],\n    execution_mode="sequential",\n    failure_strategy="retry"\n)\n\n# 3. Monitor progress\nwhile workflow["status"] != "completed":\n    status = await get_workflow_status(workflow["workflow_id"])\n    print(f"Progress: {status[\'progress_percent\']}%")\n    await asyncio.sleep(2)\n\n# 4. Review results\nfor result in workflow["results"]:\n    print(f"{result[\'agent\']}: {result[\'output\']}")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_skills_S2_coordination_10():
    """Test code snippet from skills/S2-coordination.md (line 412)."""
    code = '# Process multiple data sources in parallel\nworkflow = await coordinate_workflow(\n    steps=[\n        {\n            "agent": "data-engineer",\n            "task": "Clean and validate customer data",\n            "params": {"dataset": "customers.csv", "validations": ["email", "phone"]}\n        },\n        {\n            "agent": "data-engineer",\n            "task": "Clean and validate order data",\n            "params": {"dataset": "orders.csv", "validations": ["amounts", "dates"]}\n        },\n        {\n            "agent": "data-engineer",\n            "task": "Clean and validate product data",\n            "params": {"dataset": "products.csv", "validations": ["prices", "stock"]}\n        },\n        {\n            "agent": "analytics-expert",\n            "task": "Generate insights from cleaned data",\n            "depends_on": ["step-0", "step-1", "step-2"],\n            "params": {"analysis_types": ["trends", "correlations", "anomalies"]}\n        }\n    ],\n    execution_mode="parallel"  # Steps 0-2 run in parallel\n)\n\nprint(f"Processed data in {workflow[\'total_duration_ms\']}ms")\nprint(f"Parallelization saved {workflow[\'metadata\'][\'time_saved_ms\']}ms")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_skills_S2_coordination_11():
    """Test code snippet from skills/S2-coordination.md (line 449)."""
    code = '# Backend developer needs database expertise\nasync def optimize_database_queries():\n    # 1. Identify slow queries\n    slow_queries = analyze_query_performance()\n\n    # 2. Hand off to database expert\n    result = await handoff_to_agent(\n        target_agent="postgres-pro",\n        task="Optimize these slow queries",\n        context={\n            "queries": slow_queries,\n            "schema": "schema.sql",\n            "current_indexes": get_current_indexes(),\n            "performance_targets": {\n                "p95_latency_ms": 100,\n                "throughput_qps": 1000\n            }\n        }\n    )\n\n    # 3. Apply recommendations\n    apply_optimizations(result["result"]["recommendations"])\n\n    return result'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_skills_S2_coordination_12():
    """Test code snippet from skills/S2-coordination.md (line 480)."""
    code = '# Code quality workflow with conditional steps\nworkflow = await coordinate_workflow(\n    steps=[\n        {\n            "agent": "code-analyzer",\n            "task": "Analyze code quality metrics",\n            "params": {"file": "main.py"}\n        },\n        {\n            "agent": "refactoring-expert",\n            "task": "Refactor complex functions",\n            "depends_on": ["step-0"],\n            "condition": "complexity_score > 10",  # Only run if complex\n            "params": {"focus": "reduce_complexity"}\n        },\n        {\n            "agent": "test-generator",\n            "task": "Generate missing tests",\n            "depends_on": ["step-0"],\n            "condition": "coverage < 80",  # Only run if coverage low\n            "params": {"target_coverage": 90}\n        }\n    ],\n    execution_mode="conditional"\n)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_skills_S2_coordination_13():
    """Test code snippet from skills/S2-coordination.md (line 512)."""
    code = '# Deployment workflow with automatic fallbacks\nworkflow = await coordinate_workflow(\n    steps=[\n        {\n            "agent": "build-engineer",\n            "task": "Build application",\n            "params": {"target": "production"}\n        },\n        {\n            "agent": "qa-expert",\n            "task": "Run integration tests",\n            "depends_on": ["step-0"],\n            "params": {"test_suite": "integration"}\n        },\n        {\n            "agent": "devops-engineer",\n            "task": "Deploy to production",\n            "depends_on": ["step-1"],\n            "params": {"environment": "production"},\n            "fallback": {\n                "agent": "devops-engineer",\n                "task": "Deploy to staging instead",\n                "params": {"environment": "staging"}\n            }\n        }\n    ],\n    failure_strategy="fallback"\n)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_skills_S2_coordination_14():
    """Test code snippet from skills/S2-coordination.md (line 589)."""
    code = '# Combined discovery + coordination pattern\nasync def execute_task_with_experts(task_description):\n    # 1. Discover appropriate agents\n    agents = await discover_agents(task_description, limit=3)\n\n    # 2. Build workflow from discovered agents\n    steps = []\n    for idx, agent in enumerate(agents["agents"]):\n        steps.append({\n            "agent": agent["id"],\n            "task": f"Handle {task_description} - your specialty",\n            "depends_on": [f"step-{idx-1}"] if idx > 0 else []\n        })\n\n    # 3. Execute coordinated workflow\n    workflow = await coordinate_workflow(steps)\n\n    return workflow'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_skills_S2_coordination_15():
    """Test code snippet from skills/S2-coordination.md (line 614)."""
    code = '# Token-aware coordination (M03)\nworkflow = await coordinate_workflow(\n    steps=[...],\n    token_budget=10000,  # Total budget\n    budget_allocation="proportional"  # Or "equal", "weighted"\n)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_skills_S2_coordination_16():
    """Test code snippet from skills/S2-coordination.md (line 627)."""
    code = '# Meta-skill orchestration (M04)\nworkflow = await coordinate_workflow(\n    steps=[\n        {"skill": "code-analysis", "params": {...}},\n        {"skill": "refactoring", "depends_on": ["step-0"]},\n        {"skill": "test-generation", "depends_on": ["step-1"]}\n    ]\n)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_skills_S2_coordination_17():
    """Test code snippet from skills/S2-coordination.md (line 649)."""
    code = '# ✅ Good: Clear dependencies and descriptions\nworkflow = await coordinate_workflow(\n    steps=[\n        {\n            "agent": "data-engineer",\n            "task": "Load and validate customer data from CSV",\n            "params": {"file": "customers.csv", "validations": ["email", "phone"]}\n        },\n        {\n            "agent": "ml-engineer",\n            "task": "Train churn prediction model using validated data",\n            "depends_on": ["step-0"],\n            "params": {"model": "random_forest", "features": ["tenure", "usage"]}\n        }\n    ]\n)\n\n# ❌ Bad: Vague tasks, unclear dependencies\nworkflow = await coordinate_workflow(\n    steps=[\n        {"agent": "data-engineer", "task": "process data"},\n        {"agent": "ml-engineer", "task": "train model"}\n    ]\n)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_skills_S2_coordination_18():
    """Test code snippet from skills/S2-coordination.md (line 686)."""
    code = '# Critical deployment: abort on failure\nworkflow = await coordinate_workflow(\n    steps=[...],\n    failure_strategy="abort"\n)\n\n# Best-effort analysis: continue on failure\nworkflow = await coordinate_workflow(\n    steps=[...],\n    failure_strategy="continue"\n)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_skills_S2_coordination_19():
    """Test code snippet from skills/S2-coordination.md (line 709)."""
    code = '# ✅ Good: Minimal, structured context\ncontext = {\n    "files": ["auth.py", "models/user.py"],\n    "focus_areas": ["password_hashing", "session_management"],\n    "standards": {"reference": "OWASP_ASVS_4.0"}\n}\n\n# ❌ Bad: Massive, unstructured context\ncontext = {\n    "entire_codebase": read_all_files(),  # Too large\n    "random_notes": "check security stuff",  # Too vague\n}'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_skills_S2_coordination_20():
    """Test code snippet from skills/S2-coordination.md (line 727)."""
    code = '# Start workflow\nworkflow = await coordinate_workflow(steps=[...])\nworkflow_id = workflow["workflow_id"]\n\n# Monitor progress\nasync def monitor_workflow(wf_id):\n    while True:\n        status = await get_workflow_status(wf_id)\n\n        if status["status"] == "completed":\n            print(f"✅ Workflow completed in {status[\'total_duration_ms\']}ms")\n            break\n        elif status["status"] == "failed":\n            print(f"❌ Workflow failed at step {status[\'current_step\']}")\n            # Get failure events\n            events = await get_coordination_events(\n                workflow_id=wf_id,\n                event_type="failure"\n            )\n            for event in events["events"]:\n                print(f"  Error: {event[\'metadata\'][\'error\']}")\n            break\n        else:\n            print(f"⏳ Progress: {status[\'progress_percent\']}%")\n            await asyncio.sleep(1)\n\nawait monitor_workflow(workflow_id)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_skills_S2_coordination_21():
    """Test code snippet from skills/S2-coordination.md (line 825)."""
    code = '# Check orchestration system health\nfrom coordination import check_coordination_health\n\nhealth = await check_coordination_health()\nprint(f"Status: {health[\'status\']}")\nprint(f"Active workflows: {health[\'active_workflows\']}")\nprint(f"Queue depth: {health[\'queue_depth\']}")\n\n# Analyze workflow performance\nevents = await get_coordination_events(workflow_id="wf-abc-123")\ntotal_handoff_time = sum(\n    e["metadata"]["duration_ms"]\n    for e in events["events"]\n    if e["event_type"] == "handoff"\n)\nprint(f"Total handoff overhead: {total_handoff_time}ms")\n\n# Debug failed workflow\nworkflow_id = "wf-failed-123"\nstatus = await get_workflow_status(workflow_id)\nfailed_step = status["steps"][status["current_step"]]\nprint(f"Failed at step {status[\'current_step\']}: {failed_step[\'agent\']}")\n\nevents = await get_coordination_events(\n    workflow_id=workflow_id,\n    event_type="failure"\n)\nprint(f"Failure reason: {events[\'events\'][0][\'metadata\'][\'error\']}")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_technical_orchestration_engine_1():
    """Test code snippet from technical/orchestration-engine.md (line 70)."""
    code = '@dataclass\nclass WorkflowState:\n    workflow_id: str\n    status: WorkflowStatus  # PENDING, RUNNING, COMPLETED, FAILED, CANCELLED\n    tasks: Dict[str, TaskState]\n    created_at: str\n    updated_at: str\n    started_at: Optional[str]\n    completed_at: Optional[str]\n    variables: Dict[str, Any]\n    metadata: Dict[str, Any]\n    error: Optional[str]\n    version: int'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_technical_orchestration_engine_2():
    """Test code snippet from technical/orchestration-engine.md (line 90)."""
    code = '@dataclass\nclass TaskState:\n    task_id: str\n    agent_id: str\n    agent_type: str\n    status: TaskStatus  # PENDING, READY, RUNNING, COMPLETED, FAILED, SKIPPED\n    started_at: Optional[str]\n    completed_at: Optional[str]\n    execution_time: Optional[float]  # milliseconds\n    result: Optional[Dict[str, Any]]\n    error: Optional[Dict[str, Any]]\n    retry_count: int\n    dependencies: List[str]'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_technical_orchestration_engine_3():
    """Test code snippet from technical/orchestration-engine.md (line 110)."""
    code = '@dataclass\nclass TaskDefinition:\n    task_id: str\n    agent_id: str\n    agent_type: str\n    dependencies: List[str] = []\n    retry_policy: RetryPolicy = RetryPolicy()\n    timeout: Optional[float] = None  # seconds\n    allow_failure: bool = False\n    metadata: Dict[str, Any] = {}'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_technical_orchestration_engine_4():
    """Test code snippet from technical/orchestration-engine.md (line 127)."""
    code = '@dataclass\nclass RetryPolicy:\n    max_attempts: int = 3\n    initial_delay: float = 1.0  # seconds\n    max_delay: float = 60.0  # seconds\n    exponential_base: float = 2.0'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_technical_orchestration_engine_5():
    """Test code snippet from technical/orchestration-engine.md (line 140)."""
    code = 'from coordination import (\n    WorkflowOrchestrator,\n    StateManager,\n    TaskDefinition,\n)\n\n# Initialize\nstate_manager = StateManager()\nawait state_manager.initialize()\norchestrator = WorkflowOrchestrator(state_manager)\n\n# Define tasks\ntasks = [\n    TaskDefinition(\n        task_id="parse",\n        agent_id="parser-1",\n        agent_type="python-parser",\n    ),\n    TaskDefinition(\n        task_id="analyze",\n        agent_id="analyzer-1",\n        agent_type="code-analyzer",\n        dependencies=["parse"],\n    ),\n    TaskDefinition(\n        task_id="report",\n        agent_id="reporter-1",\n        agent_type="report-generator",\n        dependencies=["analyze"],\n    ),\n]\n\n# Create and execute\nworkflow_id = await orchestrator.create_workflow(tasks)\nresult = await orchestrator.execute_workflow(workflow_id)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_technical_orchestration_engine_6():
    """Test code snippet from technical/orchestration-engine.md (line 180)."""
    code = '# Tasks with no dependencies execute in parallel\ntasks = [\n    TaskDefinition(task_id="lint", agent_id="linter", agent_type="linter"),\n    TaskDefinition(task_id="test", agent_id="tester", agent_type="tester"),\n    TaskDefinition(task_id="type_check", agent_id="mypy", agent_type="type-checker"),\n]\n\nworkflow_id = await orchestrator.create_workflow(tasks)\nresult = await orchestrator.execute_workflow(workflow_id)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_technical_orchestration_engine_7():
    """Test code snippet from technical/orchestration-engine.md (line 194)."""
    code = '# Complex dependency pattern:\n#     parse\n#    /     \\\n#  analyze  validate\n#    \\     /\n#     merge\n\ntasks = [\n    TaskDefinition(task_id="parse", agent_id="p1", agent_type="parser"),\n    TaskDefinition(\n        task_id="analyze",\n        agent_id="a1",\n        agent_type="analyzer",\n        dependencies=["parse"],\n    ),\n    TaskDefinition(\n        task_id="validate",\n        agent_id="v1",\n        agent_type="validator",\n        dependencies=["parse"],\n    ),\n    TaskDefinition(\n        task_id="merge",\n        agent_id="m1",\n        agent_type="merger",\n        dependencies=["analyze", "validate"],\n    ),\n]\n\nworkflow_id = await orchestrator.create_workflow(tasks)\nresult = await orchestrator.execute_workflow(workflow_id)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_technical_orchestration_engine_8():
    """Test code snippet from technical/orchestration-engine.md (line 230)."""
    code = 'from coordination.orchestrator import RetryPolicy\n\ntask = TaskDefinition(\n    task_id="flaky-task",\n    agent_id="agent-1",\n    agent_type="network-caller",\n    retry_policy=RetryPolicy(\n        max_attempts=5,\n        initial_delay=2.0,\n        max_delay=30.0,\n        exponential_base=2.0,\n    ),\n)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_technical_orchestration_engine_9():
    """Test code snippet from technical/orchestration-engine.md (line 248)."""
    code = '# Non-critical task that won\'t abort workflow if it fails\ntask = TaskDefinition(\n    task_id="optional-optimization",\n    agent_id="optimizer",\n    agent_type="optimizer",\n    allow_failure=True,  # Workflow continues even if this fails\n)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_technical_orchestration_engine_10():
    """Test code snippet from technical/orchestration-engine.md (line 260)."""
    code = 'task = TaskDefinition(\n    task_id="bounded-task",\n    agent_id="agent-1",\n    agent_type="slow-processor",\n    timeout=30.0,  # 30 second timeout\n)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_technical_orchestration_engine_11():
    """Test code snippet from technical/orchestration-engine.md (line 271)."""
    code = '# Start workflow in background\nawait orchestrator.execute_workflow(workflow_id, background=True)\n\n# Check status later\nstatus = await orchestrator.get_workflow_status(workflow_id)\nprint(f"Status: {status.status}")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_technical_orchestration_engine_12():
    """Test code snippet from technical/orchestration-engine.md (line 282)."""
    code = '# Pause workflow\nawait orchestrator.pause_workflow(workflow_id)\n\n# Resume workflow\nawait orchestrator.resume_workflow(workflow_id)\n\n# Cancel workflow\nawait orchestrator.cancel_workflow(workflow_id)\n\n# Rollback to previous version\nawait orchestrator.rollback_workflow(workflow_id, version=1)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_technical_orchestration_engine_13():
    """Test code snippet from technical/orchestration-engine.md (line 300)."""
    code = 'from coordination.orchestrator import TaskExecutionContext\n\nasync def my_task_executor(ctx: TaskExecutionContext) -> Dict[str, Any]:\n    """\n    Task executor function.\n\n    Args:\n        ctx: Execution context containing:\n            - task_def: TaskDefinition\n            - workflow_id: str\n            - workflow_context: HandoffContext\n            - previous_results: List[Dict] (from dependencies)\n            - variables: Dict (workflow variables)\n\n    Returns:\n        Result dictionary to be stored in task state\n    """\n    # Access task definition\n    task_id = ctx.task_def.task_id\n\n    # Access results from dependencies\n    for prev in ctx.previous_results:\n        dep_task_id = prev["task_id"]\n        dep_result = prev["result"]\n        # Process dependency result\n\n    # Access workflow variables\n    config = ctx.variables.get("config", {})\n\n    # Perform task work\n    result = await perform_work(ctx)\n\n    return {"output": result, "status": "success"}\n\n# Register executor\norchestrator.register_executor("my-agent-type", my_task_executor)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_technical_orchestration_engine_14():
    """Test code snippet from technical/orchestration-engine.md (line 389)."""
    code = '# Initial version\nstate = await state_manager.create_workflow(tasks)\nassert state.version == 1\n\n# After update\nstate.status = WorkflowStatus.RUNNING\nupdated = await state_manager.update_workflow(state)\nassert updated.version == 2\n\n# Rollback to previous version\nrestored = await state_manager.rollback_workflow(workflow_id, version=1)\nassert restored.version == 1'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_technical_orchestration_engine_15():
    """Test code snippet from technical/orchestration-engine.md (line 410)."""
    code = '@dataclass\nclass HandoffMessage:\n    version: str\n    handoff_id: str\n    workflow_id: str\n    source: AgentInfo\n    target: AgentInfo\n    context: HandoffContext\n    state: HandoffState\n    metadata: HandoffMetadata\n    timestamp: str'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_technical_orchestration_engine_16():
    """Test code snippet from technical/orchestration-engine.md (line 426)."""
    code = 'from coordination import HandoffProtocol\n\nmessage = HandoffProtocol.create_handoff(\n    source_agent_id="agent-1",\n    source_agent_type="parser",\n    target_agent_id="agent-2",\n    target_agent_type="analyzer",\n    task_description="Analyze parsed code",\n    workflow_id=workflow_id,\n)\n\n# Validate\nHandoffProtocol.validate(message)\n\n# Serialize\njson_str = HandoffProtocol.serialize(message)\n\n# Deserialize\nrestored = HandoffProtocol.deserialize(json_str)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_technical_orchestration_engine_17():
    """Test code snippet from technical/orchestration-engine.md (line 517)."""
    code = '# Get current status\nstate = await orchestrator.get_workflow_status(workflow_id)\n\nprint(f"Status: {state.status}")\nprint(f"Version: {state.version}")\nprint(f"Started: {state.started_at}")\n\n# Check individual tasks\nfor task_id, task in state.tasks.items():\n    print(f"{task_id}: {task.status}")\n    if task.error:\n        print(f"  Error: {task.error}")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_technical_orchestration_engine_18():
    """Test code snippet from technical/orchestration-engine.md (line 534)."""
    code = '# List all workflows\nall_workflows = await state_manager.list_workflows()\n\n# List by status\nrunning = await state_manager.list_workflows(status=WorkflowStatus.RUNNING)\nfailed = await state_manager.list_workflows(status=WorkflowStatus.FAILED)\n\n# Limit results\nrecent = await state_manager.list_workflows(limit=10)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_technical_orchestration_engine_19():
    """Test code snippet from technical/orchestration-engine.md (line 548)."""
    code = '# View state history\nstate = await state_manager.get_workflow(workflow_id)\nprint(f"Current version: {state.version}")\n\n# Rollback to inspect previous state\nfor version in range(1, state.version):\n    historical = await state_manager.rollback_workflow(workflow_id, version)\n    print(f"Version {version}: {historical.status}")\n\n    # Restore to current version\n    await state_manager.rollback_workflow(workflow_id, state.version)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_technical_orchestration_engine_20():
    """Test code snippet from technical/orchestration-engine.md (line 567)."""
    code = 'tasks = [\n    TaskDefinition(task_id="parse", agent_id="parser", agent_type="parser"),\n    TaskDefinition(task_id="validate", agent_id="validator", agent_type="validator"),\n    TaskDefinition(task_id="transform", agent_id="transformer", agent_type="transformer"),\n]'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_technical_orchestration_engine_21():
    """Test code snippet from technical/orchestration-engine.md (line 576)."""
    code = '# Avoid single task doing everything\ntasks = [\n    TaskDefinition(task_id="do_everything", agent_id="agent", agent_type="all-in-one"),\n]'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_technical_orchestration_engine_22():
    """Test code snippet from technical/orchestration-engine.md (line 586)."""
    code = '# Linear dependencies\ntasks = [\n    TaskDefinition(task_id="A", ...),\n    TaskDefinition(task_id="B", dependencies=["A"], ...),\n    TaskDefinition(task_id="C", dependencies=["B"], ...),\n]'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_technical_orchestration_engine_23():
    """Test code snippet from technical/orchestration-engine.md (line 596)."""
    code = '# C doesn\'t actually need A\'s output\ntasks = [\n    TaskDefinition(task_id="A", ...),\n    TaskDefinition(task_id="B", dependencies=["A"], ...),\n    TaskDefinition(task_id="C", dependencies=["A", "B"], ...),  # Remove A\n]'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_technical_orchestration_engine_24():
    """Test code snippet from technical/orchestration-engine.md (line 608)."""
    code = 'tasks = [\n    TaskDefinition(task_id="critical", allow_failure=False, ...),  # Must succeed\n    TaskDefinition(task_id="optional", allow_failure=True, ...),  # Nice to have\n]'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_technical_orchestration_engine_25():
    """Test code snippet from technical/orchestration-engine.md (line 618)."""
    code = '# Quick operations - fail fast\nfast_task = TaskDefinition(\n    retry_policy=RetryPolicy(max_attempts=2, initial_delay=0.5)\n)\n\n# Network operations - more retries\nnetwork_task = TaskDefinition(\n    retry_policy=RetryPolicy(max_attempts=5, initial_delay=2.0, max_delay=30.0)\n)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_technical_orchestration_engine_26():
    """Test code snippet from technical/orchestration-engine.md (line 633)."""
    code = 'state_manager = StateManager()\ntry:\n    await state_manager.initialize()\n    # Use state manager\nfinally:\n    await state_manager.close()'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_technical_orchestration_engine_27():
    """Test code snippet from technical/orchestration-engine.md (line 691)."""
    code = 'class WorkflowOrchestrator:\n    def __init__(\n        self,\n        state_manager: StateManager,\n        default_retry_policy: Optional[RetryPolicy] = None,\n        max_parallel_tasks: int = 10,\n    )\n\n    def register_executor(self, agent_type: str, executor: TaskExecutor) -> None\n\n    async def create_workflow(\n        self,\n        tasks: List[TaskDefinition],\n        workflow_id: Optional[str] = None,\n        context: Optional[HandoffContext] = None,\n        metadata: Optional[Dict[str, Any]] = None,\n    ) -> str\n\n    async def execute_workflow(\n        self,\n        workflow_id: str,\n        background: bool = False,\n    ) -> Optional[WorkflowState]\n\n    async def get_workflow_status(self, workflow_id: str) -> WorkflowState\n    async def cancel_workflow(self, workflow_id: str) -> WorkflowState\n    async def pause_workflow(self, workflow_id: str) -> WorkflowState\n    async def resume_workflow(self, workflow_id: str) -> WorkflowState\n    async def rollback_workflow(self, workflow_id: str, version: int) -> WorkflowState'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_technical_orchestration_engine_28():
    """Test code snippet from technical/orchestration-engine.md (line 725)."""
    code = 'class StateManager:\n    def __init__(\n        self,\n        pool: Optional[Pool] = None,\n        connection_string: Optional[str] = None,\n    )\n\n    async def initialize() -> None\n    async def close() -> None\n\n    async def create_workflow(\n        self,\n        workflow_id: Optional[str] = None,\n        tasks: Optional[List[TaskState]] = None,\n        metadata: Optional[Dict[str, Any]] = None,\n    ) -> WorkflowState\n\n    async def get_workflow(self, workflow_id: str) -> WorkflowState\n    async def update_workflow(self, state: WorkflowState) -> WorkflowState\n    async def update_task(\n        self,\n        workflow_id: str,\n        task_id: str,\n        status: Optional[TaskStatus] = None,\n        result: Optional[Dict[str, Any]] = None,\n        error: Optional[Dict[str, Any]] = None,\n        execution_time: Optional[float] = None,\n    ) -> WorkflowState\n\n    async def rollback_workflow(self, workflow_id: str, version: int) -> WorkflowState\n    async def delete_workflow(self, workflow_id: str) -> None\n    async def list_workflows(\n        self,\n        status: Optional[WorkflowStatus] = None,\n        limit: int = 100,\n    ) -> List[WorkflowState]'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_telemetry_configuration_1():
    """Test code snippet from telemetry-configuration.md (line 226)."""
    code = 'from telemetry import TelemetryClient\n\n# Client automatically loads configuration from environment\nclient = TelemetryClient()\n\n# Track agent usage\nclient.track_agent_usage(\n    agent_id="backend-developer",\n    operation="discover",\n    metadata={"duration_ms": 150, "success": True}\n)\n\n# Track performance metrics\nclient.track_performance(\n    metric_name="query_latency",\n    value=95.5,\n    unit="ms",\n    tags={"operation": "search"}\n)\n\n# Track errors\nclient.track_error(\n    error_type="ConnectionError",\n    error_message="Failed to connect",\n    stack_trace=traceback.format_exc()\n)\n\n# Graceful shutdown\nclient.shutdown()'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_telemetry_configuration_2():
    """Test code snippet from telemetry-configuration.md (line 260)."""
    code = 'from telemetry import TelemetryClient\n\nwith TelemetryClient() as client:\n    client.track_agent_usage("agent-id", "operation")\n    # Client automatically shuts down when exiting context'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_telemetry_configuration_3():
    """Test code snippet from telemetry-configuration.md (line 270)."""
    code = 'from telemetry import TelemetryClient, TelemetryConfig\n\n# Custom configuration\nconfig = TelemetryConfig(\n    enabled=True,\n    endpoint="https://my-endpoint.com",\n    timeout=10,\n    batch_size=50\n)\n\nclient = TelemetryClient(config=config)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_telemetry_configuration_4():
    """Test code snippet from telemetry-configuration.md (line 360)."""
    code = '   from telemetry import TelemetryConfig\n\n   config = TelemetryConfig.from_env()\n   print(f"Enabled: {config.enabled}")\n   print(f"Endpoint: {config.endpoint}")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_telemetry_configuration_5():
    """Test code snippet from telemetry-configuration.md (line 382)."""
    code = '   client = TelemetryClient()\n   print(f"Queue size: {client._event_queue.qsize()}")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_telemetry_configuration_6():
    """Test code snippet from telemetry-configuration.md (line 408)."""
    code = 'import logging\nlogging.getLogger("plugins.mycelium_core.telemetry").setLevel(logging.DEBUG)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_troubleshooting_discovery_coordination_1():
    """Test code snippet from troubleshooting/discovery-coordination.md (line 27)."""
    code = 'result = discover_agents("my query")\n# result["agents"] == []\n# result["total_count"] == 0'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_troubleshooting_discovery_coordination_2():
    """Test code snippet from troubleshooting/discovery-coordination.md (line 42)."""
    code = '# Step 1: Check registry health\nfrom agent_discovery import check_discovery_health\n\nhealth = check_discovery_health()\nprint(f"Agent Count: {health[\'agent_count\']}")\nprint(f"API Status: {health[\'status\']}")\n\n# If agent_count == 0 → Registry not loaded\n# If status != \'healthy\' → API issue\n\n# Step 2: Try broader query with lower threshold\nresult = discover_agents(\n    query="general category",  # Broader\n    threshold=0.3,  # Lower\n    limit=20  # More results\n)\n\n# Step 3: Check if any agents match at all\nresult = discover_agents(query="agent", limit=100, threshold=0.0)\nprint(f"Found {len(result[\'agents\'])} agents total")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_troubleshooting_discovery_coordination_3():
    """Test code snippet from troubleshooting/discovery-coordination.md (line 67)."""
    code = '# Solution 1: Broaden query\n# Instead of: "PostgreSQL 15.2 pg_stat_statements performance tuning"\n# Try: "database optimization" or "PostgreSQL performance"\n\n# Solution 2: Lower threshold\nresult = discover_agents(query="your query", threshold=0.4)\n\n# Solution 3: Reload registry\nfrom agent_discovery import reload_registry\nreload_registry()\n\n# Solution 4: Check API configuration\nimport os\nprint(f"Discovery API URL: {os.getenv(\'DISCOVERY_API_URL\')}")\n# Default should be: http://localhost:8000'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_troubleshooting_discovery_coordination_4():
    """Test code snippet from troubleshooting/discovery-coordination.md (line 88)."""
    code = 'result = discover_agents("machine learning deployment")\n# All agents have confidence < 0.5'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_troubleshooting_discovery_coordination_5():
    """Test code snippet from troubleshooting/discovery-coordination.md (line 101)."""
    code = '# Check what keywords agents actually have\nfrom agent_discovery import get_agent_details\n\nfor agent in result["agents"]:\n    details = get_agent_details(agent["id"])\n    print(f"\\n{agent[\'name\']}:")\n    print(f"  Keywords: {details[\'agent\'][\'keywords\']}")\n    print(f"  Description: {details[\'agent\'][\'description\'][:100]}...")\n    print(f"  Confidence: {agent[\'confidence\']}")\n\n# Compare your query terms with agent keywords'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_troubleshooting_discovery_coordination_6():
    """Test code snippet from troubleshooting/discovery-coordination.md (line 117)."""
    code = '# Solution 1: Use agent\'s actual keywords\n# If agent has keywords: ["ML", "model", "serving"]\n# Query: "ML model serving" instead of "machine learning deployment"\n\n# Solution 2: Try multiple query variations\nqueries = [\n    "machine learning deployment",\n    "ML model serving",\n    "model inference production",\n    "deploy ML models"\n]\n\nbest_result = None\nbest_confidence = 0\n\nfor query in queries:\n    result = discover_agents(query, limit=3)\n    if result["agents"] and result["agents"][0]["confidence"] > best_confidence:\n        best_result = result\n        best_confidence = result["agents"][0]["confidence"]\n\nprint(f"Best match: {best_result[\'agents\'][0][\'name\']} ({best_confidence})")\n\n# Solution 3: Request agent description update\n# File issue or update agent description to include relevant keywords'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_troubleshooting_discovery_coordination_7():
    """Test code snippet from troubleshooting/discovery-coordination.md (line 148)."""
    code = 'result = discover_agents("Python backend development")\n# Returns: frontend-developer, data-scientist, devops-engineer\n# Expected: backend-developer, python-pro, api-designer'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_troubleshooting_discovery_coordination_8():
    """Test code snippet from troubleshooting/discovery-coordination.md (line 156)."""
    code = '# Check match reasons\nfor agent in result["agents"]:\n    print(f"{agent[\'name\']}: {agent[\'match_reason\']}")\n\n# Example output:\n# frontend-developer: Matches keyword \'development\'\n# data-scientist: Matches keyword \'Python\'\n# devops-engineer: Matches keyword \'backend\'\n\n# The matching is too broad!'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_troubleshooting_discovery_coordination_9():
    """Test code snippet from troubleshooting/discovery-coordination.md (line 171)."""
    code = '# Solution 1: More specific query\nresult = discover_agents(\n    query="Python backend API development REST FastAPI",\n    threshold=0.7  # Higher threshold filters out weak matches\n)\n\n# Solution 2: Category filtering\nresult = discover_agents(\n    query="Python development",\n    category_filter="backend"  # Limit to backend category\n)\n\n# Solution 3: Multi-stage discovery\n# Stage 1: Find primary agent\nprimary = discover_agents("backend development", limit=1)\n\n# Stage 2: Find complementary agents\ndetails = get_agent_details(primary["agents"][0]["id"])\nif "Python" in details["agent"]["capabilities"]:\n    # This is right agent\n    pass\nelse:\n    # Try next agent\n    pass'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_troubleshooting_discovery_coordination_10():
    """Test code snippet from troubleshooting/discovery-coordination.md (line 201)."""
    code = 'result = discover_agents("query")\n# DiscoveryTimeoutError: Request timed out after 30s'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_troubleshooting_discovery_coordination_11():
    """Test code snippet from troubleshooting/discovery-coordination.md (line 208)."""
    code = '# Check API health\nimport requests\nimport time\n\nstart = time.time()\ntry:\n    response = requests.get(\n        "http://localhost:8000/health",\n        timeout=5\n    )\n    print(f"API Health: {response.json()}")\n    print(f"Response Time: {(time.time() - start)*1000}ms")\nexcept requests.exceptions.Timeout:\n    print("API not responding")\nexcept requests.exceptions.ConnectionError:\n    print("Cannot connect to API")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_troubleshooting_discovery_coordination_12():
    """Test code snippet from troubleshooting/discovery-coordination.md (line 229)."""
    code = '# Solution 1: Increase timeout\nimport os\nos.environ["DISCOVERY_TIMEOUT_SECONDS"] = "60"\n\nresult = discover_agents("query")\n\n# Solution 2: Check API server\n# Restart API server if needed\n# Check logs: tail -f logs/discovery-api.log\n\n# Solution 3: Use cached results if available\ntry:\n    result = discover_agents("query")\nexcept DiscoveryTimeoutError:\n    # Fallback to previously cached agents\n    from agent_discovery import get_cached_results\n    result = get_cached_results("query")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_troubleshooting_discovery_coordination_13():
    """Test code snippet from troubleshooting/discovery-coordination.md (line 256)."""
    code = 'workflow = coordinate_workflow(steps=[...])\ntime.sleep(60)\nstatus = get_workflow_status(workflow["workflow_id"])\n# status["status"] == "in_progress"\n# No progress for extended time'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_troubleshooting_discovery_coordination_14():
    """Test code snippet from troubleshooting/discovery-coordination.md (line 266)."""
    code = '# Check detailed status\nstatus = get_workflow_status(workflow["workflow_id"], include_steps=True)\n\nprint(f"Current Step: {status[\'current_step\']}")\nprint(f"Steps Completed: {status[\'steps_completed\']}/{status[\'steps_total\']}")\n\n# Check which step is stuck\nfor step in status["steps"]:\n    if step["status"] == "in_progress":\n        print(f"\\nStuck at step {step[\'step\']}:")\n        print(f"  Agent: {step[\'agent\']}")\n        print(f"  Started: {step[\'started_at\']}")\n        print(f"  Duration so far: {calculate_duration(step[\'started_at\'])}s")\n\n# Check coordination events\nevents = get_coordination_events(\n    workflow_id=workflow["workflow_id"],\n    limit=50\n)\n\n# Look for errors or warnings\nfor event in events["events"]:\n    if event["event_type"] in ["failure", "warning", "timeout"]:\n        print(f"\\n{event[\'event_type\']}: {event[\'metadata\']}")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_troubleshooting_discovery_coordination_15():
    """Test code snippet from troubleshooting/discovery-coordination.md (line 295)."""
    code = '# Solution 1: Abort and restart\nfrom coordination import abort_workflow\n\nabort_workflow(workflow["workflow_id"], reason="Stuck, restarting")\n\n# Restart with adjusted parameters\nworkflow = coordinate_workflow(\n    steps=[...],\n    timeout_per_step_seconds=300  # Increased timeout\n)\n\n# Solution 2: Skip problematic step\n# If step is optional, mark as skipped and continue\nfrom coordination import skip_workflow_step\n\nskip_workflow_step(\n    workflow_id=workflow["workflow_id"],\n    step_index=2,\n    reason="Agent unavailable"\n)\n\n# Solution 3: Check agent availability\nfrom agent_discovery import check_agent_health\n\nagent_id = status["steps"][status["current_step"]]["agent"]\nagent_health = check_agent_health(agent_id)\n\nif not agent_health["available"]:\n    print(f"Agent {agent_id} is unavailable")\n    # Use alternative agent'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_troubleshooting_discovery_coordination_16():
    """Test code snippet from troubleshooting/discovery-coordination.md (line 331)."""
    code = 'workflow = coordinate_workflow(steps=[...])\n# workflow["status"] == "failed"\n# workflow["steps_completed"] == 0'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_troubleshooting_discovery_coordination_17():
    """Test code snippet from troubleshooting/discovery-coordination.md (line 339)."""
    code = '# Check failure reason\nprint(f"Status: {workflow[\'status\']}")\n\n# Get failure events\nevents = get_coordination_events(\n    workflow_id=workflow["workflow_id"],\n    event_type="failure"\n)\n\nfor event in events["events"]:\n    print(f"\\nFailure at step {event[\'metadata\'][\'step\']}:")\n    print(f"  Error: {event[\'metadata\'][\'error\']}")\n    print(f"  Details: {event[\'metadata\'].get(\'details\', \'N/A\')}")\n\n# Common error types:\n# - ValueError: Invalid workflow structure\n# - DependencyError: Unresolved dependencies\n# - ValidationError: Invalid parameters'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_troubleshooting_discovery_coordination_18():
    """Test code snippet from troubleshooting/discovery-coordination.md (line 362)."""
    code = '# Solution 1: Validate workflow before execution\ndef validate_workflow(steps):\n    # Check required fields\n    for i, step in enumerate(steps):\n        if "agent" not in step:\n            raise ValueError(f"Step {i} missing \'agent\' field")\n        if "task" not in step:\n            raise ValueError(f"Step {i} missing \'task\' field")\n\n    # Check dependencies\n    step_ids = {f"step-{i}" for i in range(len(steps))}\n    for i, step in enumerate(steps):\n        for dep in step.get("depends_on", []):\n            if dep not in step_ids:\n                raise ValueError(f"Step {i} has invalid dependency: {dep}")\n\nvalidate_workflow(steps)  # Validate before executing\nworkflow = coordinate_workflow(steps=steps)\n\n# Solution 2: Fix dependency issues\n# Check for circular dependencies\ndef find_circular_dependencies(steps):\n    # Build dependency graph\n    graph = {f"step-{i}": step.get("depends_on", [])\n             for i, step in enumerate(steps)}\n\n    # Detect cycles\n    visited = set()\n    path = set()\n\n    def has_cycle(node):\n        if node in path:\n            return True\n        if node in visited:\n            return False\n\n        visited.add(node)\n        path.add(node)\n\n        for neighbor in graph.get(node, []):\n            if has_cycle(neighbor):\n                return True\n\n        path.remove(node)\n        return False\n\n    for node in graph:\n        if has_cycle(node):\n            return True\n\n    return False\n\nif find_circular_dependencies(steps):\n    print("Circular dependency detected!")\n    # Fix dependencies before retrying\n\n# Solution 3: Simplify workflow\n# Start with minimal workflow and add steps incrementally\nworkflow = coordinate_workflow(\n    steps=[steps[0]]  # Just first step\n)\n\nif workflow["status"] == "completed":\n    # First step works, add second\n    workflow = coordinate_workflow(\n        steps=[steps[0], steps[1]]\n    )\n    # Continue adding steps'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_troubleshooting_discovery_coordination_19():
    """Test code snippet from troubleshooting/discovery-coordination.md (line 436)."""
    code = 'result = handoff_to_agent(\n    target_agent="security-expert",\n    task="Review auth.py",\n    context={"file": "auth.py", "issues": [...]}\n)\n# result["context_preserved"] == False\n# Or target agent doesn\'t have expected information'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_troubleshooting_discovery_coordination_20():
    """Test code snippet from troubleshooting/discovery-coordination.md (line 448)."""
    code = '# Check handoff events\nevents = get_coordination_events(event_type="handoff", limit=10)\n\nfor event in events["events"]:\n    if not event["metadata"].get("context_preserved", True):\n        print(f"\\nHandoff failed to preserve context:")\n        print(f"  Source: {event[\'source_agent\']}")\n        print(f"  Target: {event[\'target_agent\']}")\n        print(f"  Reason: {event[\'metadata\'].get(\'failure_reason\', \'Unknown\')}")\n        print(f"  Context Size: {event[\'metadata\'].get(\'context_size_bytes\', 0)} bytes")\n\n# Common issues:\n# - Context too large (>1MB)\n# - Context contains non-serializable objects\n# - Context schema mismatch'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_troubleshooting_discovery_coordination_21():
    """Test code snippet from troubleshooting/discovery-coordination.md (line 468)."""
    code = '# Solution 1: Reduce context size\n# Instead of embedding large data:\ncontext = {\n    "full_codebase": read_all_files(),  # Too large!\n    "git_history": get_git_log()  # Too large!\n}\n\n# Use references:\ncontext = {\n    "files": ["auth.py", "models/user.py"],  # File paths only\n    "summary": "Authentication system with JWT tokens",\n    "known_issues": [\n        {"type": "security", "file": "auth.py", "line": 42}\n    ]\n}\n\n# Solution 2: Validate context is serializable\nimport json\n\ntry:\n    json.dumps(context)  # Will fail if not serializable\nexcept TypeError as e:\n    print(f"Context not serializable: {e}")\n    # Fix non-serializable objects\n\n# Solution 3: Use schema validation\nfrom jsonschema import validate, ValidationError\n\nHANDOFF_CONTEXT_SCHEMA = {\n    "type": "object",\n    "properties": {\n        "files": {"type": "array", "items": {"type": "string"}},\n        "summary": {"type": "string"},\n        "metadata": {"type": "object"}\n    },\n    "additionalProperties": False\n}\n\ntry:\n    validate(instance=context, schema=HANDOFF_CONTEXT_SCHEMA)\nexcept ValidationError as e:\n    print(f"Invalid context schema: {e}")\n\n# Solution 4: Check handoff result\nresult = handoff_to_agent(\n    target_agent="security-expert",\n    task="Review auth.py",\n    context=context\n)\n\nif not result.get("context_preserved", False):\n    print(f"Warning: Context not fully preserved")\n    print(f"Reason: {result.get(\'preservation_status\', {})}")\n    # Retry with reduced context or different format'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_troubleshooting_discovery_coordination_22():
    """Test code snippet from troubleshooting/discovery-coordination.md (line 528)."""
    code = 'result = handoff_to_agent(target_agent="slow-agent", task="complex task")\n# HandoffTimeoutError: Handoff did not complete within 30s'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_troubleshooting_discovery_coordination_23():
    """Test code snippet from troubleshooting/discovery-coordination.md (line 535)."""
    code = '# Check agent performance history\nfrom agent_discovery import get_agent_details\n\ndetails = get_agent_details("slow-agent")\nprint(f"Average Response Time: {details[\'agent\'][\'avg_response_time_ms\']}ms")\n\n# If avg_response_time_ms > 10000 → Agent is consistently slow\n\n# Check recent handoffs\nevents = get_coordination_events(\n    agent_id="slow-agent",\n    event_type="handoff",\n    limit=20\n)\n\ndurations = [e["metadata"]["duration_ms"] for e in events["events"]]\nprint(f"Handoff durations: p50={percentile(durations, 50)}ms, "\n      f"p95={percentile(durations, 95)}ms")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_troubleshooting_discovery_coordination_24():
    """Test code snippet from troubleshooting/discovery-coordination.md (line 558)."""
    code = '# Solution 1: Increase timeout\nresult = handoff_to_agent(\n    target_agent="slow-agent",\n    task="complex task",\n    timeout_seconds=120  # Increased timeout\n)\n\n# Solution 2: Async handoff (don\'t wait)\nresult = handoff_to_agent(\n    target_agent="slow-agent",\n    task="complex task",\n    wait_for_completion=False  # Returns immediately\n)\n\n# Check status later\nhandoff_id = result["handoff_id"]\ntime.sleep(60)\nstatus = get_handoff_status(handoff_id)\n\n# Solution 3: Use faster alternative agent\nagents = discover_agents("task description", limit=5)\n\n# Filter by response time\nfast_agents = [\n    a for a in agents["agents"]\n    if get_agent_details(a["id"])["agent"]["avg_response_time_ms"] < 5000\n]\n\nresult = handoff_to_agent(\n    target_agent=fast_agents[0]["id"],\n    task="complex task"\n)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_troubleshooting_discovery_coordination_25():
    """Test code snippet from troubleshooting/discovery-coordination.md (line 600)."""
    code = 'workflow = coordinate_workflow(steps=[...])\n# workflow["total_duration_ms"] > expected\n# P95 latency exceeds targets'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_troubleshooting_discovery_coordination_26():
    """Test code snippet from troubleshooting/discovery-coordination.md (line 608)."""
    code = '# Analyze workflow performance\nworkflow_id = workflow["workflow_id"]\n\n# Get detailed timing\nevents = get_coordination_events(workflow_id=workflow_id)\n\n# Calculate overhead\ntotal_time = workflow["total_duration_ms"]\nagent_time = sum(r["duration_ms"] for r in workflow["results"])\ncoordination_overhead = total_time - agent_time\n\nprint(f"Total Time: {total_time}ms")\nprint(f"Agent Time: {agent_time}ms")\nprint(f"Coordination Overhead: {coordination_overhead}ms "\n      f"({(coordination_overhead/total_time)*100:.1f}%)")\n\n# Breakdown by step\nfor result in workflow["results"]:\n    print(f"\\nStep {result[\'step\']}: {result[\'agent\']}")\n    print(f"  Duration: {result[\'duration_ms\']}ms")\n    print(f"  % of Total: {(result[\'duration_ms\']/total_time)*100:.1f}%")\n\n# Identify bottlenecks\nslowest = max(workflow["results"], key=lambda r: r["duration_ms"])\nprint(f"\\nBottleneck: {slowest[\'agent\']} ({slowest[\'duration_ms\']}ms)")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_troubleshooting_discovery_coordination_27():
    """Test code snippet from troubleshooting/discovery-coordination.md (line 638)."""
    code = '# Solution 1: Parallelize independent steps\n# Before (sequential):\nworkflow = coordinate_workflow(\n    steps=[\n        {"agent": "frontend", "task": "Build UI"},\n        {"agent": "backend", "task": "Build API"},  # Could be parallel!\n        {"agent": "database", "task": "Setup DB"},  # Could be parallel!\n        {"agent": "integration", "task": "Connect all",\n         "depends_on": ["step-0", "step-1", "step-2"]}\n    ],\n    execution_mode="sequential"\n)\n\n# After (parallel):\nworkflow = coordinate_workflow(\n    steps=[\n        {"agent": "frontend", "task": "Build UI"},\n        {"agent": "backend", "task": "Build API"},\n        {"agent": "database", "task": "Setup DB"},\n        {"agent": "integration", "task": "Connect all",\n         "depends_on": ["step-0", "step-1", "step-2"]}\n    ],\n    execution_mode="parallel"  # Steps 0-2 run in parallel\n)\n\n# Solution 2: Batch similar operations\n# Before (multiple workflows):\nfor file in files:\n    coordinate_workflow(steps=[\n        {"agent": "analyzer", "task": f"Analyze {file}"}\n    ])\n\n# After (single batched workflow):\ncoordinate_workflow(steps=[\n    {"agent": "analyzer", "task": "Analyze all files",\n     "params": {"files": files}}\n])\n\n# Solution 3: Use faster agents\n# Replace slow agent with faster alternative\nagents = discover_agents("task description")\ndetails = [get_agent_details(a["id"]) for a in agents["agents"]]\n\n# Sort by speed\nsorted_agents = sorted(\n    details,\n    key=lambda d: d["agent"]["avg_response_time_ms"]\n)\n\nfastest = sorted_agents[0]\nprint(f"Using {fastest[\'agent\'][\'name\']} "\n      f"({fastest[\'agent\'][\'avg_response_time_ms\']}ms avg)")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_troubleshooting_discovery_coordination_28():
    """Test code snippet from troubleshooting/discovery-coordination.md (line 696)."""
    code = '# System monitoring shows high memory usage during workflows\n# Memory usage > 500MB per workflow'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_troubleshooting_discovery_coordination_29():
    """Test code snippet from troubleshooting/discovery-coordination.md (line 703)."""
    code = '# Check workflow state size\nimport sys\n\nworkflow = coordinate_workflow(steps=[...])\nworkflow_size = sys.getsizeof(workflow)\n\nprint(f"Workflow State Size: {workflow_size / 1024 / 1024:.2f}MB")\n\n# Check context sizes\nevents = get_coordination_events(workflow_id=workflow["workflow_id"])\n\nfor event in events["events"]:\n    if event["event_type"] == "handoff":\n        context_size = event["metadata"].get("context_size_bytes", 0)\n        print(f"Handoff context: {context_size / 1024:.2f}KB")\n\n# If context sizes > 100KB → Contexts too large'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_troubleshooting_discovery_coordination_30():
    """Test code snippet from troubleshooting/discovery-coordination.md (line 725)."""
    code = '# Solution 1: Reduce context size\n# Before:\ncontext = {\n    "entire_file": read_file("large_file.txt"),  # 5MB\n    "all_data": load_all_data()  # 10MB\n}\n\n# After:\ncontext = {\n    "file_path": "large_file.txt",  # Reference\n    "data_summary": {\n        "row_count": 10000,\n        "columns": ["id", "name", "email"],\n        "sample": data[:100]  # Small sample\n    }\n}\n\n# Solution 2: Clear completed workflows\nfrom coordination import cleanup_workflows\n\n# Clean up workflows older than 24 hours\ncleanup_workflows(older_than_hours=24)\n\n# Solution 3: Use workflow checkpoints\n# Enable checkpointing to disk instead of keeping in memory\nworkflow = coordinate_workflow(\n    steps=[...],\n    checkpoint_to_disk=True  # Reduces memory usage\n)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_troubleshooting_discovery_coordination_31():
    """Test code snippet from troubleshooting/discovery-coordination.md (line 760)."""
    code = '# Repeated discovery calls have low cache hit rate\n# Every call takes 50-100ms instead of <10ms'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_troubleshooting_discovery_coordination_32():
    """Test code snippet from troubleshooting/discovery-coordination.md (line 767)."""
    code = '# Check cache statistics\nfrom agent_discovery import get_cache_stats\n\nstats = get_cache_stats()\nprint(f"Cache Hit Rate: {stats[\'hit_rate\']}%")\nprint(f"Cache Size: {stats[\'size\']} / {stats[\'max_size\']}")\nprint(f"Total Queries: {stats[\'total_queries\']}")\n\n# If hit_rate < 50% → Cache not being utilized effectively'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_troubleshooting_discovery_coordination_33():
    """Test code snippet from troubleshooting/discovery-coordination.md (line 781)."""
    code = '# Solution 1: Reuse agents instead of rediscovering\n# Before (rediscover each time):\nfor task in tasks:\n    agents = discover_agents("Python development")\n    process_task(task, agents["agents"][0])\n\n# After (discover once):\nagents = discover_agents("Python development")\npython_dev = agents["agents"][0]\n\nfor task in tasks:\n    process_task(task, python_dev)\n\n# Solution 2: Increase cache size\nimport os\nos.environ["DISCOVERY_CACHE_SIZE"] = "200"  # Default: 100\n\n# Solution 3: Warm up cache\n# Pre-populate cache with common queries\ncommon_queries = [\n    "Python development",\n    "database optimization",\n    "security audit",\n    "frontend development",\n    "API design"\n]\n\nfor query in common_queries:\n    discover_agents(query)  # Warm cache\n\n# Now actual queries will hit cache'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_troubleshooting_discovery_coordination_34():
    """Test code snippet from troubleshooting/discovery-coordination.md (line 822)."""
    code = 'context = {"large_data": [...]}\nresult = handoff_to_agent("agent", "task", context=context)\n# ContextSerializationError: Context too large to serialize'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_troubleshooting_discovery_coordination_35():
    """Test code snippet from troubleshooting/discovery-coordination.md (line 830)."""
    code = '# Solution 1: Use file references\n# Before:\ncontext = {\n    "data": read_large_file()  # 50MB\n}\n\n# After:\ncontext = {\n    "data_path": "/path/to/large_file.txt",\n    "data_format": "CSV",\n    "row_count": 1000000\n}\n\n# Solution 2: Compress context\nimport gzip\nimport json\nimport base64\n\ndef compress_context(context):\n    json_data = json.dumps(context).encode(\'utf-8\')\n    compressed = gzip.compress(json_data)\n    return base64.b64encode(compressed).decode(\'utf-8\')\n\ndef decompress_context(compressed):\n    decoded = base64.b64decode(compressed.encode(\'utf-8\'))\n    decompressed = gzip.decompress(decoded)\n    return json.loads(decompressed.decode(\'utf-8\'))\n\n# Use compressed context\ncompressed = compress_context(large_context)\nresult = handoff_to_agent(\n    "agent",\n    "task",\n    context={"compressed_data": compressed}\n)\n\n# Solution 3: Stream large data\n# Instead of passing all at once, stream in chunks\ndef stream_data_to_agent(agent_id, data_chunks):\n    handoff_id = initiate_streaming_handoff(agent_id)\n\n    for chunk in data_chunks:\n        send_chunk(handoff_id, chunk)\n\n    finalize_handoff(handoff_id)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_troubleshooting_discovery_coordination_36():
    """Test code snippet from troubleshooting/discovery-coordination.md (line 881)."""
    code = 'result = handoff_to_agent("agent", "task", context={"foo": "bar"})\n# Agent expects different context structure\n# Agent returns error or incomplete results'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_troubleshooting_discovery_coordination_37():
    """Test code snippet from troubleshooting/discovery-coordination.md (line 889)."""
    code = '# Solution 1: Validate context against schema\nfrom jsonschema import validate, ValidationError\n\n# Get agent\'s expected context schema\ndetails = get_agent_details("security-expert")\nexpected_schema = details["metadata"].get("context_schema")\n\nif expected_schema:\n    try:\n        validate(instance=context, schema=expected_schema)\n    except ValidationError as e:\n        print(f"Context validation failed: {e}")\n        # Fix context structure before retrying\n\n# Solution 2: Use standard context templates\nSTANDARD_CONTEXT_TEMPLATES = {\n    "code_review": {\n        "files": List[str],\n        "focus_areas": List[str],\n        "standards": str\n    },\n    "security_audit": {\n        "files": List[str],\n        "focus_areas": List[str],\n        "compliance": str,\n        "known_issues": List[Dict]\n    },\n    # ... more templates\n}\n\n# Build context from template\ncontext = build_context_from_template(\n    template="security_audit",\n    files=["auth.py"],\n    focus_areas=["authentication"],\n    compliance="OWASP_ASVS_4.0"\n)\n\n# Solution 3: Get context example from agent\ndetails = get_agent_details("security-expert")\ncontext_example = details["metadata"].get("context_example")\n\n# Use example as guide for structure'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_troubleshooting_discovery_coordination_38():
    """Test code snippet from troubleshooting/discovery-coordination.md (line 942)."""
    code = 'health = check_discovery_health()\n# health["status"] == "unhealthy"'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_troubleshooting_discovery_coordination_39():
    """Test code snippet from troubleshooting/discovery-coordination.md (line 949)."""
    code = '# Check detailed health\nprint(f"Status: {health[\'status\']}")\nprint(f"Agent Count: {health[\'agent_count\']}")\nprint(f"Last Updated: {health.get(\'last_updated\', \'Unknown\')}")\nprint(f"Errors: {health.get(\'errors\', [])}")\n\n# Check API logs\n# tail -f logs/discovery-api.log'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_troubleshooting_discovery_coordination_40():
    """Test code snippet from troubleshooting/discovery-coordination.md (line 962)."""
    code = '# Solution 1: Restart API service\nimport subprocess\nsubprocess.run(["systemctl", "restart", "mycelium-discovery-api"])\n\n# Solution 2: Reload registry\nfrom agent_discovery import reload_registry\n\nreload_registry(force=True)\n\n# Solution 3: Check database connection\nfrom registry import check_database_health\n\ndb_health = check_database_health()\nif not db_health["connected"]:\n    print(f"Database connection failed: {db_health[\'error\']}")\n    # Fix database connection\n\n# Solution 4: Rebuild registry\nfrom registry import rebuild_registry\n\nrebuild_registry(\n    source="plugins/mycelium-core/agents/index.json"\n)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_troubleshooting_discovery_coordination_41():
    """Test code snippet from troubleshooting/discovery-coordination.md (line 991)."""
    code = 'workflow = coordinate_workflow(steps=[...])\n# CoordinationServiceError: Service unavailable'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_troubleshooting_discovery_coordination_42():
    """Test code snippet from troubleshooting/discovery-coordination.md (line 998)."""
    code = '# Check coordination service health\nfrom coordination import check_coordination_health\n\nhealth = check_coordination_health()\nprint(f"Status: {health[\'status\']}")\nprint(f"Active Workflows: {health.get(\'active_workflows\', 0)}")\nprint(f"Queue Depth: {health.get(\'queue_depth\', 0)}")\nprint(f"Errors: {health.get(\'errors\', [])}")\n\n# If queue_depth > 100 → Service overloaded\n# If active_workflows > 50 → At capacity'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_troubleshooting_discovery_coordination_43():
    """Test code snippet from troubleshooting/discovery-coordination.md (line 1014)."""
    code = '# Solution 1: Wait for queue to drain\nimport time\n\nwhile True:\n    health = check_coordination_health()\n    if health["queue_depth"] < 10:\n        break\n    print(f"Waiting for queue to drain: {health[\'queue_depth\']} items")\n    time.sleep(5)\n\nworkflow = coordinate_workflow(steps=[...])\n\n# Solution 2: Increase service capacity\n# In configuration:\n# MAX_CONCURRENT_WORKFLOWS=100  # Increase from 50\n# WORKER_THREADS=8  # Increase from 4\n\n# Solution 3: Clean up stuck workflows\nfrom coordination import cleanup_stuck_workflows\n\ncleanup_stuck_workflows(stuck_for_hours=2)\n\n# Solution 4: Use fallback mode\n# If coordination service unavailable, execute steps manually\ntry:\n    workflow = coordinate_workflow(steps=[...])\nexcept CoordinationServiceError:\n    # Manual execution fallback\n    results = []\n    for step in steps:\n        result = handoff_to_agent(\n            step["agent"],\n            step["task"],\n            context=step.get("params", {})\n        )\n        results.append(result)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_troubleshooting_discovery_coordination_44():
    """Test code snippet from troubleshooting/discovery-coordination.md (line 1079)."""
    code = '# Benchmark discovery performance\nimport time\n\nqueries = ["Python development", "database optimization", "security audit"]\nlatencies = []\n\nfor query in queries:\n    start = time.time()\n    result = discover_agents(query)\n    latency = (time.time() - start) * 1000\n    latencies.append(latency)\n    print(f"{query}: {latency:.2f}ms")\n\nprint(f"\\nP50: {sorted(latencies)[len(latencies)//2]:.2f}ms")\nprint(f"P95: {sorted(latencies)[int(len(latencies)*0.95)]:.2f}ms")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_troubleshooting_discovery_coordination_45():
    """Test code snippet from troubleshooting/discovery-coordination.md (line 1099)."""
    code = '# Analyze recent coordination events\nevents = get_coordination_events(limit=1000)\n\n# Count by type\nfrom collections import Counter\nevent_types = Counter(e["event_type"] for e in events["events"])\nprint(f"Event Types: {dict(event_types)}")\n\n# Find failures\nfailures = [e for e in events["events"] if e["event_type"] == "failure"]\nprint(f"\\nFailures: {len(failures)}")\nfor failure in failures[:5]:\n    print(f"  {failure[\'timestamp\']}: {failure[\'metadata\'][\'error\']}")\n\n# Average handoff time\nhandoffs = [e for e in events["events"] if e["event_type"] == "handoff"]\navg_handoff = sum(e["metadata"]["duration_ms"] for e in handoffs) / len(handoffs)\nprint(f"\\nAverage Handoff Time: {avg_handoff:.2f}ms")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_flow_diagram_1():
    """Test code snippet from wizard-flow-diagram.md (line 359)."""
    code = 'class WizardFlow:\n    def __init__(self, state: WizardState = None):\n        self.state = state or WizardState()\n\n    def advance(self) -> WizardStep:\n        """Move to next step"""\n        next_step = self.state.get_next_step()\n        if next_step:\n            self.state.current_step = next_step\n        return self.state.current_step\n\n    def go_back(self) -> WizardStep:\n        """Move to previous step"""\n        prev_step = self.state.get_previous_step()\n        if prev_step:\n            self.state.current_step = prev_step\n        return self.state.current_step\n\n    def jump_to(self, step: WizardStep) -> WizardStep:\n        """Jump to specific step (from review)"""\n        if self.state.can_proceed_to(step):\n            self.state.current_step = step\n        return self.state.current_step'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_flow_diagram_2():
    """Test code snippet from wizard-flow-diagram.md (line 388)."""
    code = 'def can_proceed_to(self, step: WizardStep) -> bool:\n    if step == WizardStep.SERVICES:\n        return self.detection_results is not None\n\n    if step == WizardStep.REVIEW:\n        return (\n            bool(self.project_name) and\n            any(self.services_enabled.values())\n        )\n\n    if step == WizardStep.COMPLETE:\n        return self.completed\n\n    return True'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_flow_diagram_3():
    """Test code snippet from wizard-flow-diagram.md (line 408)."""
    code = 'def get_next_step(self) -> Optional[WizardStep]:\n    if (self.setup_mode == "quick" and\n        self.current_step == WizardStep.DEPLOYMENT):\n        return WizardStep.REVIEW  # Skip ADVANCED\n\n    # Normal progression\n    step_order = list(WizardStep)\n    current_index = step_order.index(self.current_step)\n    return step_order[current_index + 1]'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_flow_diagram_4():
    """Test code snippet from wizard-flow-diagram.md (line 424)."""
    code = 'def test_advance_from_welcome():\n    flow = WizardFlow()\n    assert flow.state.current_step == WizardStep.WELCOME\n\n    flow.advance()\n    assert flow.state.current_step == WizardStep.DETECTION\n\ndef test_quick_mode_skips_advanced():\n    flow = WizardFlow()\n    flow.state.setup_mode = "quick"\n    flow.state.current_step = WizardStep.DEPLOYMENT\n\n    next_step = flow.state.get_next_step()\n    assert next_step == WizardStep.REVIEW'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_flow_diagram_5():
    """Test code snippet from wizard-flow-diagram.md (line 443)."""
    code = 'def test_quick_setup_flow():\n    flow = WizardFlow()\n    steps = [WizardStep.WELCOME, WizardStep.DETECTION,\n             WizardStep.SERVICES, WizardStep.DEPLOYMENT,\n             WizardStep.REVIEW, WizardStep.COMPLETE]\n\n    for expected_step in steps:\n        assert flow.state.current_step == expected_step\n        if expected_step != WizardStep.COMPLETE:\n            flow.advance()'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_integration_1():
    """Test code snippet from wizard-integration.md (line 51)."""
    code = 'from mycelium_onboarding.wizard.flow import WizardFlow, WizardState, WizardStep\nfrom mycelium_onboarding.wizard.screens import WizardScreens\nfrom mycelium_onboarding.wizard.validation import WizardValidator\nfrom mycelium_onboarding.wizard.persistence import WizardStatePersistence\nfrom mycelium_onboarding.config.manager import ConfigManager\n\ndef run_wizard_programmatically():\n    """Run the wizard programmatically."""\n    # Initialize components\n    state = WizardState()\n    flow = WizardFlow(state)\n    screens = WizardScreens(state)\n    validator = WizardValidator(state)\n    persistence = WizardStatePersistence()\n\n    try:\n        # Check for saved state\n        if persistence.exists():\n            state = persistence.load()\n            if state:\n                flow = WizardFlow(state)\n                screens = WizardScreens(state)\n                validator = WizardValidator(state)\n                print(f"Resuming from {state.current_step}")\n\n        # Main wizard loop\n        while not state.is_complete():\n            # Persist state\n            persistence.save(state)\n\n            # Execute current step\n            current_step = state.current_step\n\n            if current_step == WizardStep.WELCOME:\n                setup_mode = screens.show_welcome()\n                state.setup_mode = setup_mode\n                flow.advance()\n\n            elif current_step == WizardStep.DETECTION:\n                summary = screens.show_detection()\n                state.detection_results = summary\n                flow.advance()\n\n            elif current_step == WizardStep.SERVICES:\n                # Prompt for project name if not set\n                if not state.project_name:\n                    state.project_name = input("Project name: ").strip()\n\n                services = screens.show_services()\n                state.services_enabled = services\n                flow.advance()\n\n            elif current_step == WizardStep.DEPLOYMENT:\n                deployment = screens.show_deployment()\n                state.deployment_method = deployment\n\n                # Handle mode-specific flow\n                if state.setup_mode == "quick":\n                    state.current_step = WizardStep.REVIEW\n                else:\n                    flow.advance()\n\n            elif current_step == WizardStep.ADVANCED:\n                screens.show_advanced()\n                flow.advance()\n\n            elif current_step == WizardStep.REVIEW:\n                action = screens.show_review()\n\n                if action == "confirm":\n                    # Validate before saving\n                    if not validator.validate_state():\n                        print("Validation errors:")\n                        for error in validator.get_error_messages():\n                            print(f"  - {error}")\n                        continue\n\n                    # Generate and save configuration\n                    config = state.to_config()\n                    manager = ConfigManager()\n                    manager.save(config)\n\n                    # Mark complete\n                    state.completed = True\n                    state.current_step = WizardStep.COMPLETE\n                    flow.advance()\n\n                elif action.startswith("edit:"):\n                    # Jump to step for editing\n                    edit_step = action.split(":")[1]\n                    state.current_step = WizardStep(edit_step)\n\n                elif action == "cancel":\n                    print("Wizard cancelled")\n                    return None\n\n            elif current_step == WizardStep.COMPLETE:\n                config_path = manager._determine_save_path()\n                screens.show_complete(str(config_path))\n                break\n\n        # Clear saved state on success\n        persistence.clear()\n        return state\n\n    except KeyboardInterrupt:\n        print("\\nWizard interrupted. Run again with resume.")\n        persistence.save(state)\n        return None\n    except Exception as e:\n        print(f"Error: {e}")\n        persistence.save(state)\n        raise\n\n# Usage\nif __name__ == "__main__":\n    final_state = run_wizard_programmatically()\n    if final_state:\n        print(f"Wizard completed! Project: {final_state.project_name}")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_integration_2():
    """Test code snippet from wizard-integration.md (line 177)."""
    code = 'from mycelium_onboarding.wizard.flow import WizardState\nfrom mycelium_onboarding.wizard.validation import WizardValidator\nfrom mycelium_onboarding.config.manager import ConfigManager\n\ndef create_config_from_template(template_name: str):\n    """Create configuration from predefined template."""\n    # Define templates\n    templates = {\n        "minimal": {\n            "project_name": "minimal-project",\n            "services": {"redis": True, "postgres": False, "temporal": False},\n            "deployment": "docker-compose",\n        },\n        "full-stack": {\n            "project_name": "full-stack-project",\n            "services": {"redis": True, "postgres": True, "temporal": True},\n            "deployment": "kubernetes",\n            "postgres_database": "fullstack_db",\n            "temporal_namespace": "production",\n        },\n        "development": {\n            "project_name": "dev-project",\n            "services": {"redis": True, "postgres": True, "temporal": False},\n            "deployment": "docker-compose",\n            "postgres_database": "dev_db",\n            "auto_start": False,\n        },\n    }\n\n    if template_name not in templates:\n        raise ValueError(f"Unknown template: {template_name}")\n\n    template = templates[template_name]\n\n    # Build state\n    state = WizardState()\n    state.project_name = template["project_name"]\n    state.services_enabled = template["services"]\n    state.deployment_method = template["deployment"]\n\n    if "postgres_database" in template:\n        state.postgres_database = template["postgres_database"]\n    if "temporal_namespace" in template:\n        state.temporal_namespace = template["temporal_namespace"]\n    if "auto_start" in template:\n        state.auto_start = template["auto_start"]\n\n    # Validate\n    validator = WizardValidator(state)\n    if not validator.validate_state():\n        raise ValueError(f"Invalid template: {validator.get_error_messages()}")\n\n    # Convert to config\n    config = state.to_config()\n\n    # Save\n    manager = ConfigManager()\n    manager.save(config)\n\n    return config\n\n# Usage\nconfig = create_config_from_template("full-stack")\nprint(f"Created config: {config.project_name}")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_integration_3():
    """Test code snippet from wizard-integration.md (line 248)."""
    code = 'from mycelium_onboarding.wizard.flow import WizardState, WizardStep\nfrom mycelium_onboarding.wizard.validation import WizardValidator\n\ndef headless_wizard(answers: dict):\n    """Run wizard with predefined answers (for CI/CD)."""\n    state = WizardState()\n\n    # Apply answers\n    state.project_name = answers.get("project_name", "mycelium-project")\n    state.setup_mode = answers.get("setup_mode", "quick")\n    state.services_enabled = answers.get("services", {\n        "redis": True,\n        "postgres": True,\n        "temporal": False,\n    })\n    state.deployment_method = answers.get("deployment", "docker-compose")\n    state.postgres_database = answers.get("postgres_database", "mycelium")\n    state.auto_start = answers.get("auto_start", True)\n    state.enable_persistence = answers.get("enable_persistence", True)\n\n    # Advanced settings\n    if "redis_port" in answers:\n        state.redis_port = answers["redis_port"]\n    if "postgres_port" in answers:\n        state.postgres_port = answers["postgres_port"]\n\n    # Validate\n    validator = WizardValidator(state)\n    if not validator.validate_state():\n        raise ValueError(f"Invalid configuration: {validator.get_error_messages()}")\n\n    # Convert and return\n    return state.to_config()\n\n# Usage in CI/CD\nanswers = {\n    "project_name": "ci-test-project",\n    "services": {"redis": True, "postgres": False, "temporal": False},\n    "deployment": "systemd",\n}\n\nconfig = headless_wizard(answers)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_integration_4():
    """Test code snippet from wizard-integration.md (line 299)."""
    code = 'from mycelium_onboarding.wizard.screens import WizardScreens\nfrom mycelium_onboarding.wizard.flow import WizardStep\nfrom InquirerPy import inquirer\nfrom rich.console import Console\n\nconsole = Console()\n\nclass ExtendedWizardScreens(WizardScreens):\n    """Extended wizard screens with custom functionality."""\n\n    def show_monitoring(self) -> dict[str, any]:\n        """Show custom monitoring configuration screen."""\n        console.print("\\n[bold]Monitoring Configuration[/bold]\\n")\n\n        # Monitoring provider selection\n        provider = inquirer.select(\n            message="Select monitoring provider:",\n            choices=[\n                {"value": "prometheus", "name": "Prometheus + Grafana"},\n                {"value": "datadog", "name": "Datadog"},\n                {"value": "none", "name": "No monitoring"},\n            ],\n            default="prometheus",\n        ).execute()\n\n        config = {"provider": provider}\n\n        if provider == "prometheus":\n            # Prometheus-specific config\n            port = inquirer.number(\n                message="Prometheus port:",\n                default=9090,\n                min_allowed=1024,\n                max_allowed=65535,\n            ).execute()\n            config["prometheus_port"] = port\n\n        elif provider == "datadog":\n            # Datadog-specific config\n            api_key = inquirer.secret(\n                message="Datadog API key:",\n            ).execute()\n            config["datadog_api_key"] = api_key\n\n        return config\n\n# Usage\nstate = WizardState()\nscreens = ExtendedWizardScreens(state)\nmonitoring_config = screens.show_monitoring()'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_integration_5():
    """Test code snippet from wizard-integration.md (line 356)."""
    code = 'from mycelium_onboarding.wizard.validation import WizardValidator, ValidationError\n\nclass ExtendedWizardValidator(WizardValidator):\n    """Extended validator with custom rules."""\n\n    def validate_custom_naming_convention(self, name: str) -> bool:\n        """Validate project name follows company naming convention."""\n        # Example: Must start with "proj-" or "svc-"\n        valid_prefixes = ["proj-", "svc-"]\n\n        if not any(name.startswith(prefix) for prefix in valid_prefixes):\n            self.errors.append(\n                ValidationError(\n                    field="project_name",\n                    message=f"Project name must start with one of: {\', \'.join(valid_prefixes)}",\n                    severity="error",\n                )\n            )\n            return False\n        return True\n\n    def validate_production_requirements(self) -> bool:\n        """Validate production deployment requirements."""\n        if self.state.deployment_method == "kubernetes":\n            # Require persistence for production\n            if not self.state.enable_persistence:\n                self.errors.append(\n                    ValidationError(\n                        field="enable_persistence",\n                        message="Persistence must be enabled for Kubernetes deployment",\n                        severity="error",\n                    )\n                )\n                return False\n        return True\n\n    def validate_state(self) -> bool:\n        """Override to include custom validations."""\n        # Run base validations\n        if not super().validate_state():\n            return False\n\n        # Add custom validations\n        if self.state.project_name:\n            self.validate_custom_naming_convention(self.state.project_name)\n\n        self.validate_production_requirements()\n\n        return len(self.errors) == 0\n\n# Usage\nstate = WizardState()\nstate.project_name = "proj-myapp"\nvalidator = ExtendedWizardValidator(state)\nif validator.validate_state():\n    print("Validation passed!")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_integration_6():
    """Test code snippet from wizard-integration.md (line 419)."""
    code = 'from mycelium_onboarding.wizard.persistence import WizardStatePersistence\nfrom mycelium_onboarding.wizard.flow import WizardState\nimport redis\nimport pickle\n\nclass RedisWizardPersistence(WizardStatePersistence):\n    """Persist wizard state in Redis."""\n\n    def __init__(self, redis_url: str = "redis://localhost:6379"):\n        """Initialize Redis persistence."""\n        self.redis_client = redis.from_url(redis_url)\n        self.state_key = "mycelium:wizard:state"\n\n    def save(self, state: WizardState) -> None:\n        """Save state to Redis."""\n        state_bytes = pickle.dumps(state)\n        self.redis_client.set(self.state_key, state_bytes)\n        # Set TTL: expire after 24 hours\n        self.redis_client.expire(self.state_key, 86400)\n\n    def load(self) -> WizardState | None:\n        """Load state from Redis."""\n        state_bytes = self.redis_client.get(self.state_key)\n        if state_bytes:\n            return pickle.loads(state_bytes)\n        return None\n\n    def clear(self) -> None:\n        """Clear state from Redis."""\n        self.redis_client.delete(self.state_key)\n\n    def exists(self) -> bool:\n        """Check if state exists in Redis."""\n        return self.redis_client.exists(self.state_key) > 0\n\n# Usage\npersistence = RedisWizardPersistence()\nstate = WizardState()\npersistence.save(state)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_integration_7():
    """Test code snippet from wizard-integration.md (line 467)."""
    code = 'import pytest\nfrom unittest.mock import MagicMock, patch\nfrom mycelium_onboarding.wizard.screens import WizardScreens\nfrom mycelium_onboarding.wizard.flow import WizardState\n\ndef test_services_screen_with_mocks():\n    """Test services screen with mocked InquirerPy."""\n    state = WizardState()\n    screens = WizardScreens(state)\n\n    # Mock InquirerPy\n    with patch("mycelium_onboarding.wizard.screens.inquirer") as mock_inquirer:\n        # Mock checkbox for service selection\n        mock_inquirer.checkbox.return_value = MagicMock(\n            execute=lambda: ["redis", "postgres"]\n        )\n\n        # Mock text input for database name\n        mock_inquirer.text.return_value = MagicMock(\n            execute=lambda: "test_db"\n        )\n\n        # Execute\n        services = screens.show_services()\n\n        # Assert\n        assert services == {"redis": True, "postgres": True, "temporal": False}\n        assert state.postgres_database == "test_db"\n\ndef test_wizard_flow_with_mock_detection():\n    """Test complete wizard flow with mocked detection."""\n    from mycelium_onboarding.detection.orchestrator import DetectionSummary\n    from mycelium_onboarding.wizard.flow import WizardFlow\n    from unittest.mock import Mock\n\n    # Create mock detection\n    mock_detection = Mock(spec=DetectionSummary)\n    mock_detection.has_docker = True\n    mock_detection.has_redis = True\n    mock_detection.has_postgres = False\n\n    # Create state\n    state = WizardState()\n    state.detection_results = mock_detection\n\n    flow = WizardFlow(state)\n\n    # Test flow can proceed with detection\n    assert state.can_proceed_to(WizardStep.SERVICES)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_integration_8():
    """Test code snippet from wizard-integration.md (line 523)."""
    code = 'import pytest\nfrom click.testing import CliRunner\nfrom unittest.mock import MagicMock, patch\nfrom pathlib import Path\n\nfrom mycelium_onboarding.cli import cli\nfrom mycelium_onboarding.wizard.flow import WizardState\n\ndef test_wizard_quick_mode_e2e(tmp_path: Path):\n    """End-to-end test for quick mode wizard."""\n    runner = CliRunner()\n\n    with patch("mycelium_onboarding.wizard.persistence.WizardStatePersistence") as mock_pers:\n        # Setup persistence mock\n        mock_persistence = MagicMock()\n        mock_persistence.exists.return_value = False\n        mock_pers.return_value = mock_persistence\n\n        # Mock all prompts\n        with patch("mycelium_onboarding.wizard.screens.inquirer") as mock_inquirer:\n            mock_inquirer.select.side_effect = [\n                MagicMock(execute=lambda: "quick"),  # Setup mode\n                MagicMock(execute=lambda: "docker-compose"),  # Deployment\n                MagicMock(execute=lambda: "confirm"),  # Review\n            ]\n\n            mock_inquirer.confirm.side_effect = [\n                MagicMock(execute=lambda: False),  # Don\'t re-run detection\n                MagicMock(execute=lambda: True),  # Auto-start\n            ]\n\n            mock_inquirer.checkbox.return_value = MagicMock(\n                execute=lambda: ["redis", "postgres"]\n            )\n\n            mock_inquirer.text.return_value = MagicMock(\n                execute=lambda: "test_db"\n            )\n\n            # Mock detection\n            with patch("mycelium_onboarding.wizard.screens.detect_all") as mock_detect:\n                mock_detect.return_value = Mock()\n\n                # Mock config manager\n                with patch("mycelium_onboarding.config.manager.ConfigManager") as mock_cfg:\n                    mock_config = MagicMock()\n                    mock_config._determine_save_path.return_value = tmp_path / "config.yaml"\n                    mock_cfg.return_value = mock_config\n\n                    # Mock project name prompt\n                    with patch("click.prompt", return_value="test-project"):\n                        # Execute wizard\n                        result = runner.invoke(cli, ["init", "--no-resume"])\n\n                    # Verify\n                    assert result.exit_code == 0\n                    mock_config.save.assert_called_once()'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_integration_9():
    """Test code snippet from wizard-integration.md (line 589)."""
    code = 'from mycelium_onboarding.config.schema import DeploymentMethod\nfrom enum import Enum\n\n# Extend DeploymentMethod enum (in config/schema.py)\nclass ExtendedDeploymentMethod(str, Enum):\n    """Extended deployment methods."""\n    DOCKER_COMPOSE = "docker-compose"\n    KUBERNETES = "kubernetes"\n    SYSTEMD = "systemd"\n    MANUAL = "manual"\n    NOMAD = "nomad"  # New method\n    DOCKER_SWARM = "docker-swarm"  # New method\n\n# Add to validator\ndef validate_deployment_method_extended(method: str) -> bool:\n    """Validate extended deployment methods."""\n    valid = [m.value for m in ExtendedDeploymentMethod]\n    return method in valid\n\n# Update screens to show new options\ndef show_extended_deployment(self) -> str:\n    """Show deployment screen with extended options."""\n    choices = [\n        {"value": "docker-compose", "name": "Docker Compose"},\n        {"value": "kubernetes", "name": "Kubernetes"},\n        {"value": "systemd", "name": "systemd"},\n        {"value": "nomad", "name": "HashiCorp Nomad"},\n        {"value": "docker-swarm", "name": "Docker Swarm"},\n    ]\n\n    deployment = inquirer.select(\n        message="Select deployment method:",\n        choices=choices,\n    ).execute()\n\n    return deployment'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_integration_10():
    """Test code snippet from wizard-integration.md (line 633)."""
    code = '# Always save state before potentially failing operations\npersistence.save(state)\ntry:\n    risky_operation()\nexcept Exception:\n    # State is already saved for resume\n    raise'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_integration_11():
    """Test code snippet from wizard-integration.md (line 644)."""
    code = "# Don't modify state without validation\nstate.postgres_database = user_input  # Could be invalid!\n\n# DO validate first\nvalidator = WizardValidator(state)\nif validator.validate_postgres_database(user_input):\n    state.postgres_database = user_input"

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_integration_12():
    """Test code snippet from wizard-integration.md (line 657)."""
    code = '# Provide helpful error messages\ntry:\n    config = state.to_config()\nexcept ValueError as e:\n    print(f"Configuration error: {e}")\n    print("Please check your settings and try again.")\n    # Keep state for retry'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_integration_13():
    """Test code snippet from wizard-integration.md (line 668)."""
    code = "# Don't silently fail\ntry:\n    config = state.to_config()\nexcept ValueError:\n    pass  # User has no idea what went wrong!"

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_integration_14():
    """Test code snippet from wizard-integration.md (line 679)."""
    code = '# Provide defaults based on context\ndefault_db = state.project_name.lower().replace("-", "_")\ndb_name = inquirer.text(\n    message="Database name:",\n    default=default_db,\n).execute()'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_integration_15():
    """Test code snippet from wizard-integration.md (line 689)."""
    code = '# Don\'t make users type everything\ndb_name = inquirer.text(\n    message="Database name:",\n    # No default - forces manual input\n).execute()'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_integration_16():
    """Test code snippet from wizard-integration.md (line 700)."""
    code = '# Test with realistic mock data\nmock_detection = Mock(spec=DetectionSummary)\nmock_detection.has_docker = True\nmock_detection.docker = Mock(version="24.0.0")\n\n# Test error paths\ndef test_validation_failure():\n    state = WizardState()\n    state.project_name = ""  # Invalid\n    validator = WizardValidator(state)\n    assert not validator.validate_state()'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_integration_17():
    """Test code snippet from wizard-integration.md (line 715)."""
    code = "# Don't only test happy paths\ndef test_wizard():\n    # Only tests successful completion\n    assert wizard_completes_successfully()"

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_integration_18():
    """Test code snippet from wizard-integration.md (line 725)."""
    code = 'def custom_screen(self) -> dict:\n    """Show custom configuration screen.\n\n    Returns:\n        dict: Configuration with keys:\n            - option1 (str): Description\n            - option2 (bool): Description\n\n    Example:\n        >>> screens = CustomScreens(state)\n        >>> config = screens.custom_screen()\n        >>> print(config["option1"])\n    """'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_integration_19():
    """Test code snippet from wizard-integration.md (line 744)."""
    code = '# Handle old state format gracefully\ndef _deserialize_state(self, data: dict) -> WizardState:\n    # Provide defaults for new fields\n    auto_start = data.get("auto_start", True)  # Default if missing\n    enable_persistence = data.get("enable_persistence", True)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_integration_20():
    """Test code snippet from wizard-integration.md (line 758)."""
    code = 'from fastapi import FastAPI, WebSocket\nfrom mycelium_onboarding.wizard.flow import WizardState, WizardFlow\n\napp = FastAPI()\n\n# Store active wizard sessions\nsessions = {}\n\n@app.websocket("/ws/wizard/{session_id}")\nasync def wizard_websocket(websocket: WebSocket, session_id: str):\n    """WebSocket endpoint for interactive wizard."""\n    await websocket.accept()\n\n    # Create or resume session\n    if session_id in sessions:\n        state = sessions[session_id]\n    else:\n        state = WizardState()\n        sessions[session_id] = state\n\n    flow = WizardFlow(state)\n\n    try:\n        while not state.is_complete():\n            # Send current step info\n            await websocket.send_json({\n                "step": state.current_step.value,\n                "state": state.to_dict(),\n            })\n\n            # Receive user input\n            data = await websocket.receive_json()\n\n            # Process input based on current step\n            # ... handle step logic ...\n\n            # Advance\n            flow.advance()\n\n        # Send completion\n        await websocket.send_json({"status": "complete"})\n\n    except WebSocketDisconnect:\n        # Save state for resume\n        pass'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_integration_21():
    """Test code snippet from wizard-integration.md (line 810)."""
    code = 'from mycelium_onboarding.wizard.flow import WizardState\n\nclass WizardOrchestrator:\n    """Orchestrate multiple related wizards."""\n\n    def __init__(self):\n        self.wizards = {}\n\n    def run_sequential_wizards(self, wizard_specs: list[dict]):\n        """Run multiple wizards in sequence, passing state."""\n        results = []\n\n        for spec in wizard_specs:\n            wizard_type = spec["type"]\n            state = self.create_wizard_state(wizard_type)\n\n            # Pass data from previous wizard\n            if results:\n                self.apply_previous_results(state, results[-1])\n\n            # Run wizard\n            result = self.run_wizard(state)\n            results.append(result)\n\n        return results\n\n    def create_wizard_state(self, wizard_type: str) -> WizardState:\n        """Create wizard state based on type."""\n        # Factory pattern for different wizard types\n        pass\n\n    def apply_previous_results(self, state: WizardState, previous: dict):\n        """Apply results from previous wizard to current state."""\n        # Data flow between wizards\n        pass'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_integration_22():
    """Test code snippet from wizard-integration.md (line 852)."""
    code = 'from abc import ABC, abstractmethod\n\nclass WizardPlugin(ABC):\n    """Base class for wizard plugins."""\n\n    @abstractmethod\n    def get_screen_name(self) -> str:\n        """Get plugin screen name."""\n        pass\n\n    @abstractmethod\n    def show_screen(self, state: WizardState) -> dict:\n        """Show plugin screen and return data."""\n        pass\n\n    @abstractmethod\n    def validate(self, state: WizardState) -> list[ValidationError]:\n        """Validate plugin-specific state."""\n        pass\n\nclass MonitoringPlugin(WizardPlugin):\n    """Plugin for monitoring configuration."""\n\n    def get_screen_name(self) -> str:\n        return "monitoring"\n\n    def show_screen(self, state: WizardState) -> dict:\n        # Show monitoring configuration screen\n        return {"provider": "prometheus", "port": 9090}\n\n    def validate(self, state: WizardState) -> list[ValidationError]:\n        # Validate monitoring settings\n        return []\n\n# Plugin registry\nclass WizardPluginRegistry:\n    def __init__(self):\n        self.plugins = {}\n\n    def register(self, plugin: WizardPlugin):\n        self.plugins[plugin.get_screen_name()] = plugin\n\n    def get_plugin(self, name: str) -> WizardPlugin:\n        return self.plugins.get(name)\n\n# Usage\nregistry = WizardPluginRegistry()\nregistry.register(MonitoringPlugin())'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_reference_1():
    """Test code snippet from wizard-reference.md (line 44)."""
    code = 'class WizardStep(str, Enum):\n    """Wizard steps in order."""\n    WELCOME = "welcome"\n    DETECTION = "detection"\n    SERVICES = "services"\n    DEPLOYMENT = "deployment"\n    ADVANCED = "advanced"\n    REVIEW = "review"\n    COMPLETE = "complete"'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_reference_2():
    """Test code snippet from wizard-reference.md (line 66)."""
    code = 'from mycelium_onboarding.wizard.flow import WizardStep\n\ncurrent_step = WizardStep.WELCOME\nif current_step == WizardStep.WELCOME:\n    print("Starting wizard")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_reference_3():
    """Test code snippet from wizard-reference.md (line 78)."""
    code = '@dataclass\nclass WizardState:\n    """Complete wizard state with user selections."""\n\n    # Step tracking\n    current_step: WizardStep = WizardStep.WELCOME\n    started_at: datetime = field(default_factory=datetime.now)\n\n    # Detection results (from M03)\n    detection_results: dict[str, Any] | None = None\n\n    # User selections\n    project_name: str = ""\n    services_enabled: dict[str, bool] = field(default_factory=dict)\n    deployment_method: str = "docker-compose"\n\n    # Service-specific settings\n    redis_port: int = 6379\n    postgres_port: int = 5432\n    postgres_database: str = ""\n    temporal_namespace: str = "default"\n    temporal_ui_port: int = 8080\n    temporal_frontend_port: int = 7233\n\n    # Advanced settings\n    auto_start: bool = True\n    enable_persistence: bool = True\n\n    # Wizard metadata\n    setup_mode: str = "quick"  # "quick" or "custom"\n    completed: bool = False\n    resumed: bool = False'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_reference_4():
    """Test code snippet from wizard-reference.md (line 157)."""
    code = 'state = WizardState()\nstate.detection_results = summary\n\nif state.can_proceed_to(WizardStep.SERVICES):\n    print("Can proceed to services")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_reference_5():
    """Test code snippet from wizard-reference.md (line 187)."""
    code = 'state = WizardState()\nstate.setup_mode = "quick"\nstate.current_step = WizardStep.DEPLOYMENT\n\nnext_step = state.get_next_step()\n# Returns WizardStep.REVIEW (skips ADVANCED)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_reference_6():
    """Test code snippet from wizard-reference.md (line 209)."""
    code = 'state = WizardState()\nstate.current_step = WizardStep.SERVICES\n\nprev_step = state.get_previous_step()\n# Returns WizardStep.DETECTION'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_reference_7():
    """Test code snippet from wizard-reference.md (line 225)."""
    code = 'state = WizardState()\nstate.current_step = WizardStep.COMPLETE\nstate.completed = True\n\nif state.is_complete():\n    print("Wizard is complete!")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_reference_8():
    """Test code snippet from wizard-reference.md (line 250)."""
    code = 'state = WizardState()\nstate.project_name = "my-project"\nstate.services_enabled = {"redis": True, "postgres": True, "temporal": False}\nstate.postgres_database = "my_db"\n\nconfig = state.to_config()\n# Returns MyceliumConfig instance'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_reference_9():
    """Test code snippet from wizard-reference.md (line 273)."""
    code = 'state = WizardState()\nstate_dict = state.to_dict()\n# Returns: {"current_step": "welcome", "started_at": "2025-10-14T...", ...}'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_reference_10():
    """Test code snippet from wizard-reference.md (line 293)."""
    code = 'data = {"current_step": "services", "project_name": "test"}\nstate = WizardState.from_dict(data)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_reference_11():
    """Test code snippet from wizard-reference.md (line 302)."""
    code = 'class WizardFlow:\n    """Manages wizard flow logic."""\n\n    def __init__(self, state: WizardState | None = None) -> None:\n        """Initialize wizard flow."""\n        self.state = state or WizardState()'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_reference_12():
    """Test code snippet from wizard-reference.md (line 325)."""
    code = '# New flow\nflow = WizardFlow()\n\n# With existing state\nstate = WizardState()\nflow = WizardFlow(state)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_reference_13():
    """Test code snippet from wizard-reference.md (line 345)."""
    code = 'flow = WizardFlow()\ntry:\n    next_step = flow.advance()\n    print(f"Advanced to {next_step}")\nexcept ValueError as e:\n    print(f"Cannot advance: {e}")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_reference_14():
    """Test code snippet from wizard-reference.md (line 365)."""
    code = 'flow = WizardFlow()\nflow.state.current_step = WizardStep.SERVICES\n\nprev_step = flow.go_back()\n# Returns WizardStep.DETECTION'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_reference_15():
    """Test code snippet from wizard-reference.md (line 387)."""
    code = 'flow = WizardFlow()\nflow.state.current_step = WizardStep.REVIEW\n\n# Jump back to edit services\nflow.jump_to(WizardStep.SERVICES)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_reference_16():
    """Test code snippet from wizard-reference.md (line 403)."""
    code = 'flow = WizardFlow()\nflow.save_state("/tmp/wizard_state.json")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_reference_17():
    """Test code snippet from wizard-reference.md (line 423)."""
    code = 'flow = WizardFlow.load_state("/tmp/wizard_state.json")\nprint(f"Resumed from {flow.state.current_step}")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_reference_18():
    """Test code snippet from wizard-reference.md (line 433)."""
    code = 'flow = WizardFlow()\nflow.mark_complete()\nassert flow.state.is_complete()'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_reference_19():
    """Test code snippet from wizard-reference.md (line 447)."""
    code = 'class WizardScreens:\n    """All wizard screen implementations."""\n\n    def __init__(self, state: WizardState) -> None:\n        """Initialize wizard screens with state."""\n        self.state = state'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_reference_20():
    """Test code snippet from wizard-reference.md (line 470)."""
    code = 'state = WizardState()\nscreens = WizardScreens(state)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_reference_21():
    """Test code snippet from wizard-reference.md (line 491)."""
    code = 'screens = WizardScreens(state)\nsetup_mode = screens.show_welcome()\n# Returns "quick" or "custom"'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_reference_22():
    """Test code snippet from wizard-reference.md (line 513)."""
    code = 'screens = WizardScreens(state)\nsummary = screens.show_detection()\nprint(f"Detected services: {summary.has_redis}, {summary.has_postgres}")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_reference_23():
    """Test code snippet from wizard-reference.md (line 541)."""
    code = 'screens = WizardScreens(state)\nservices = screens.show_services()\n# Returns: {"redis": True, "postgres": True, "temporal": False}'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_reference_24():
    """Test code snippet from wizard-reference.md (line 568)."""
    code = 'screens = WizardScreens(state)\ndeployment = screens.show_deployment()\n# Returns: "docker-compose"'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_reference_25():
    """Test code snippet from wizard-reference.md (line 595)."""
    code = 'screens = WizardScreens(state)\nstate.setup_mode = "custom"\nscreens.show_advanced()'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_reference_26():
    """Test code snippet from wizard-reference.md (line 621)."""
    code = 'screens = WizardScreens(state)\naction = screens.show_review()\n\nif action == "confirm":\n    # Save configuration\nelif action.startswith("edit:"):\n    step = action.split(":")[1]\n    # Jump to step for editing'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_reference_27():
    """Test code snippet from wizard-reference.md (line 648)."""
    code = 'screens = WizardScreens(state)\nscreens.show_complete("/home/user/.config/mycelium/config.yaml")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_reference_28():
    """Test code snippet from wizard-reference.md (line 661)."""
    code = '@dataclass\nclass ValidationError:\n    """Validation error with field and message."""\n    field: str\n    message: str\n    severity: str = "error"  # "error" or "warning"'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_reference_29():
    """Test code snippet from wizard-reference.md (line 686)."""
    code = 'error = ValidationError("project_name", "Cannot be empty")\nprint(error)  # Outputs: "project_name: Cannot be empty"'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_reference_30():
    """Test code snippet from wizard-reference.md (line 695)."""
    code = 'class WizardValidator:\n    """Validates wizard state and user inputs."""\n\n    def __init__(self, state: WizardState) -> None:\n        """Initialize validator with wizard state."""\n        self.state = state\n        self.errors: list[ValidationError] = []'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_reference_31():
    """Test code snippet from wizard-reference.md (line 720)."""
    code = 'state = WizardState()\nvalidator = WizardValidator(state)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_reference_32():
    """Test code snippet from wizard-reference.md (line 741)."""
    code = 'validator = WizardValidator(state)\nif not validator.validate_project_name("my-project"):\n    print(validator.get_error_messages())'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_reference_33():
    """Test code snippet from wizard-reference.md (line 755)."""
    code = 'validator = WizardValidator(state)\nif not validator.validate_services():\n    print("No services enabled!")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_reference_34():
    """Test code snippet from wizard-reference.md (line 778)."""
    code = 'validator = WizardValidator(state)\nif not validator.validate_postgres_database("my_db"):\n    print("Invalid database name")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_reference_35():
    """Test code snippet from wizard-reference.md (line 799)."""
    code = 'validator = WizardValidator(state)\nif not validator.validate_port(6379, "redis"):\n    print("Invalid port")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_reference_36():
    """Test code snippet from wizard-reference.md (line 822)."""
    code = 'validator = WizardValidator(state)\nif not validator.validate_deployment_method("docker-compose"):\n    print("Invalid deployment method")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_reference_37():
    """Test code snippet from wizard-reference.md (line 844)."""
    code = 'validator = WizardValidator(state)\nif not validator.validate_temporal_namespace("production"):\n    print("Invalid namespace")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_reference_38():
    """Test code snippet from wizard-reference.md (line 862)."""
    code = 'validator = WizardValidator(state)\nif not validator.validate_port_conflicts():\n    print("Port conflicts detected!")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_reference_39():
    """Test code snippet from wizard-reference.md (line 881)."""
    code = 'validator = WizardValidator(state)\nif not validator.validate_state():\n    for error in validator.get_errors():\n        print(f"{error.field}: {error.message}")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_reference_40():
    """Test code snippet from wizard-reference.md (line 896)."""
    code = 'validator = WizardValidator(state)\nvalidator.validate_state()\nerrors = validator.get_errors()'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_reference_41():
    """Test code snippet from wizard-reference.md (line 910)."""
    code = 'validator = WizardValidator(state)\nvalidator.validate_state()\nfor msg in validator.get_error_messages():\n    print(msg)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_reference_42():
    """Test code snippet from wizard-reference.md (line 925)."""
    code = 'validator = WizardValidator(state)\nvalidator.validate_state()\nif validator.has_errors():\n    print("Validation failed!")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_reference_43():
    """Test code snippet from wizard-reference.md (line 940)."""
    code = 'class PersistenceError(Exception):\n    """Raised when state persistence operations fail."""\n    pass'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_reference_44():
    """Test code snippet from wizard-reference.md (line 950)."""
    code = 'class WizardStatePersistence:\n    """Manages saving and loading wizard state."""\n\n    def __init__(self, state_dir: Path | None = None) -> None:\n        """Initialize persistence manager."""\n        self.state_dir = state_dir or get_state_dir()\n        self.state_file = self.state_dir / "wizard_state.json"'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_reference_45():
    """Test code snippet from wizard-reference.md (line 975)."""
    code = '# Use default XDG location\npersistence = WizardStatePersistence()\n\n# Use custom location\npersistence = WizardStatePersistence(state_dir=Path("/tmp/state"))'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_reference_46():
    """Test code snippet from wizard-reference.md (line 999)."""
    code = 'persistence = WizardStatePersistence()\nstate = WizardState()\npersistence.save(state)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_reference_47():
    """Test code snippet from wizard-reference.md (line 1018)."""
    code = 'persistence = WizardStatePersistence()\nstate = persistence.load()\nif state:\n    print(f"Resuming from {state.current_step}")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_reference_48():
    """Test code snippet from wizard-reference.md (line 1033)."""
    code = 'persistence = WizardStatePersistence()\npersistence.clear()'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_reference_49():
    """Test code snippet from wizard-reference.md (line 1046)."""
    code = 'persistence = WizardStatePersistence()\nif persistence.exists():\n    print("Saved state found")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_reference_50():
    """Test code snippet from wizard-reference.md (line 1060)."""
    code = 'persistence = WizardStatePersistence()\npath = persistence.get_state_path()\nprint(f"State file: {path}")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_reference_51():
    """Test code snippet from wizard-reference.md (line 1077)."""
    code = 'persistence = WizardStatePersistence()\nbackup_path = persistence.backup()\nif backup_path:\n    print(f"Backed up to {backup_path}")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_reference_52():
    """Test code snippet from wizard-reference.md (line 1096)."""
    code = 'persistence = WizardStatePersistence()\npersistence.restore_from_backup(Path("/tmp/backup.json"))'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_reference_53():
    """Test code snippet from wizard-reference.md (line 1105)."""
    code = 'from mycelium_onboarding.wizard.flow import WizardFlow, WizardState, WizardStep\nfrom mycelium_onboarding.wizard.screens import WizardScreens\nfrom mycelium_onboarding.wizard.validation import WizardValidator\nfrom mycelium_onboarding.wizard.persistence import WizardStatePersistence\n\n# Initialize\nstate = WizardState()\nflow = WizardFlow(state)\nscreens = WizardScreens(state)\nvalidator = WizardValidator(state)\npersistence = WizardStatePersistence()\n\n# Main wizard loop\nwhile not state.is_complete():\n    # Save state for resume\n    persistence.save(state)\n\n    current_step = state.current_step\n\n    if current_step == WizardStep.WELCOME:\n        setup_mode = screens.show_welcome()\n        state.setup_mode = setup_mode\n        flow.advance()\n\n    elif current_step == WizardStep.DETECTION:\n        summary = screens.show_detection()\n        flow.advance()\n\n    elif current_step == WizardStep.SERVICES:\n        services = screens.show_services()\n        flow.advance()\n\n    elif current_step == WizardStep.REVIEW:\n        action = screens.show_review()\n        if action == "confirm":\n            if validator.validate_state():\n                config = state.to_config()\n                # Save config\n                flow.mark_complete()\n        elif action.startswith("edit:"):\n            step = action.split(":")[1]\n            flow.jump_to(WizardStep(step))\n\n# Clear saved state on completion\npersistence.clear()'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_reference_54():
    """Test code snippet from wizard-reference.md (line 1155)."""
    code = 'from mycelium_onboarding.wizard.persistence import WizardStatePersistence\n\npersistence = WizardStatePersistence()\n\nif persistence.exists():\n    state = persistence.load()\n    if state:\n        print(f"Resuming from {state.current_step}")\n        # Continue wizard with loaded state\n    else:\n        print("Saved state corrupted, starting fresh")\n        state = WizardState()\nelse:\n    state = WizardState()'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_reference_55():
    """Test code snippet from wizard-reference.md (line 1174)."""
    code = 'from mycelium_onboarding.wizard.validation import WizardValidator, ValidationError\n\nvalidator = WizardValidator(state)\n\n# Validate specific fields\nif not validator.validate_project_name(state.project_name):\n    print("Invalid project name")\n\n# Validate port range\nif not validator.validate_port(state.redis_port, "redis"):\n    print("Invalid Redis port")\n\n# Comprehensive validation\nif not validator.validate_state():\n    for error in validator.get_errors():\n        print(f"Error in {error.field}: {error.message}")'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_reference_56():
    """Test code snippet from wizard-reference.md (line 1195)."""
    code = 'from mycelium_onboarding.wizard.flow import WizardState\n\n# Build state programmatically\nstate = WizardState()\nstate.project_name = "my-project"\nstate.setup_mode = "quick"\nstate.services_enabled = {\n    "redis": True,\n    "postgres": True,\n    "temporal": False,\n}\nstate.deployment_method = "docker-compose"\nstate.postgres_database = "my_db"\nstate.auto_start = True\n\n# Convert to config\nconfig = state.to_config()\n\n# Save config\nfrom mycelium_onboarding.config.manager import ConfigManager\nmanager = ConfigManager()\nmanager.save(config)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_wizard_reference_57():
    """Test code snippet from wizard-reference.md (line 1222)."""
    code = 'from mycelium_onboarding.wizard.flow import WizardState\n\n# Serialize to dict\nstate = WizardState()\nstate_dict = state.to_dict()\n\n# Save to JSON\nimport json\nwith open("state.json", "w") as f:\n    json.dump(state_dict, f)\n\n# Load from dict\nwith open("state.json") as f:\n    loaded_dict = json.load(f)\nloaded_state = WizardState.from_dict(loaded_dict)'

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {e}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {e}")


def test_snippet_coverage():
    """Verify we extracted snippets from documentation."""
    total_snippets = 546
    valid_snippets = 482
    invalid_snippets = total_snippets - valid_snippets

    print("\nDocumentation snippet coverage:")
    print(f"  Total snippets: {total_snippets}")
    print(f"  Valid syntax: {valid_snippets}")
    print(f"  Invalid syntax: {invalid_snippets}")

    # At least 85% should have valid syntax (allows for pseudo-code and contextual examples)
    if total_snippets > 0:
        valid_percentage = (valid_snippets / total_snippets) * 100
        assert valid_percentage >= 85, (
            f"Only {valid_percentage:.1f}% of snippets have valid syntax. "
            f"Expected at least 85%."
        )
