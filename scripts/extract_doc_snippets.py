"""Extract and validate Python code snippets from markdown documentation.

This script parses markdown files in the docs/ directory, extracts Python code blocks,
and generates test files to validate that the examples are correct and runnable.
"""

import ast
import re
from dataclasses import dataclass
from pathlib import Path
from typing import Any


@dataclass
class CodeSnippet:
    """Represents a Python code snippet extracted from documentation."""

    content: str
    source_file: str
    line_number: int
    snippet_index: int
    is_valid_syntax: bool
    has_imports: bool
    has_assignments: bool
    error_message: str | None = None


class SnippetExtractor:
    """Extract Python code snippets from markdown files."""

    def __init__(self, docs_dir: Path, output_dir: Path | None = None) -> None:
        """Initialize the extractor.

        Args:
            docs_dir: Directory containing markdown documentation
            output_dir: Optional directory for extracted snippets (default: tests/docs/snippets)
        """
        self.docs_dir = docs_dir
        self.output_dir = output_dir or Path("tests/docs/snippets")
        self.snippets: list[CodeSnippet] = []

    def extract_from_file(self, md_file: Path) -> list[CodeSnippet]:
        """Extract all Python code blocks from a markdown file.

        Args:
            md_file: Path to markdown file

        Returns:
            List of extracted code snippets
        """
        content = md_file.read_text(encoding="utf-8")
        snippets = []

        # Pattern to match Python code blocks: ```python ... ```
        # Uses DOTALL flag to match across newlines
        pattern = r"```python\n(.*?)```"
        matches = re.finditer(pattern, content, re.DOTALL)

        for idx, match in enumerate(matches, start=1):
            code = match.group(1).rstrip()
            line_number = content[: match.start()].count("\n") + 1

            # Analyze the snippet
            is_valid, error_msg = self._check_syntax(code)
            has_imports = self._has_imports(code)
            has_assignments = self._has_assignments(code)

            snippet = CodeSnippet(
                content=code,
                source_file=str(md_file.relative_to(self.docs_dir)),
                line_number=line_number,
                snippet_index=idx,
                is_valid_syntax=is_valid,
                has_imports=has_imports,
                has_assignments=has_assignments,
                error_message=error_msg,
            )
            snippets.append(snippet)

        return snippets

    def extract_from_directory(self, pattern: str = "**/*.md") -> list[CodeSnippet]:
        """Extract snippets from all markdown files in directory.

        Args:
            pattern: Glob pattern for matching markdown files

        Returns:
            List of all extracted snippets
        """
        self.snippets = []

        for md_file in sorted(self.docs_dir.glob(pattern)):
            if md_file.is_file():
                file_snippets = self.extract_from_file(md_file)
                self.snippets.extend(file_snippets)

        return self.snippets

    def save_snippets(self) -> None:
        """Save extracted snippets as individual Python files."""
        self.output_dir.mkdir(parents=True, exist_ok=True)

        # Create __init__.py
        (self.output_dir / "__init__.py").write_text(
            '"""Auto-generated snippets from documentation."""\n'
        )

        for snippet in self.snippets:
            # Create a safe filename
            safe_filename = (
                snippet.source_file.replace("/", "_")
                .replace(".md", "")
                .replace(" ", "_")
            )
            snippet_file = (
                self.output_dir / f"{safe_filename}_snippet_{snippet.snippet_index}.py"
            )

            # Add metadata as comments
            header = f"""# Source: {snippet.source_file}
# Line: {snippet.line_number}
# Valid syntax: {snippet.is_valid_syntax}
# Has imports: {snippet.has_imports}
# Has assignments: {snippet.has_assignments}

"""
            if snippet.error_message:
                header += f"# Syntax error: {snippet.error_message}\n\n"

            snippet_file.write_text(header + snippet.content)

    def generate_pytest_file(self, output_file: Path) -> None:
        """Generate a pytest file that tests all snippets.

        Args:
            output_file: Path to output test file
        """
        test_code = '''"""Auto-generated tests for documentation code snippets.

This file is generated by scripts/extract_doc_snippets.py.
DO NOT EDIT MANUALLY - your changes will be overwritten.
"""

import ast
import importlib.util
import sys
from pathlib import Path

import pytest

'''

        # Group snippets by source file
        snippets_by_file: dict[str, list[CodeSnippet]] = {}
        for snippet in self.snippets:
            if snippet.source_file not in snippets_by_file:
                snippets_by_file[snippet.source_file] = []
            snippets_by_file[snippet.source_file].append(snippet)

        # Generate test functions
        for source_file, snippets in sorted(snippets_by_file.items()):
            safe_name = (
                source_file.replace("/", "_")
                .replace(".md", "")
                .replace(" ", "_")
                .replace("-", "_")
            )

            for snippet in snippets:
                test_name = f"test_snippet_{safe_name}_{snippet.snippet_index}"

                # Properly escape the snippet content using repr()
                escaped_content = repr(snippet.content)

                # Create test function
                test_code += f'''
def {test_name}():
    """Test code snippet from {source_file} (line {snippet.line_number})."""
    code = {escaped_content}

    # Test 1: Syntax validation
    try:
        ast.parse(code)
    except SyntaxError as e:
        pytest.fail(f"Syntax error in snippet: {{e}}")

    # Test 2: Import validation (check imports don't fail)
    try:
        compile(code, "<string>", "exec")
    except Exception as e:
        pytest.fail(f"Compilation error: {{e}}")

'''

        # Add a summary test with 85% threshold (allows for pseudo-code examples)
        test_code += f'''
def test_snippet_coverage():
    """Verify we extracted snippets from documentation."""
    total_snippets = {len(self.snippets)}
    valid_snippets = {sum(1 for s in self.snippets if s.is_valid_syntax)}
    invalid_snippets = total_snippets - valid_snippets

    print(f"\\nDocumentation snippet coverage:")
    print(f"  Total snippets: {{total_snippets}}")
    print(f"  Valid syntax: {{valid_snippets}}")
    print(f"  Invalid syntax: {{invalid_snippets}}")

    # At least 85% should have valid syntax (allows for pseudo-code and contextual examples)
    if total_snippets > 0:
        valid_percentage = (valid_snippets / total_snippets) * 100
        assert valid_percentage >= 85, (
            f"Only {{valid_percentage:.1f}}% of snippets have valid syntax. "
            f"Expected at least 85%."
        )
'''

        output_file.parent.mkdir(parents=True, exist_ok=True)
        output_file.write_text(test_code)

    def generate_report(self) -> str:
        """Generate a summary report of extracted snippets.

        Returns:
            Formatted report string
        """
        total = len(self.snippets)
        valid = sum(1 for s in self.snippets if s.is_valid_syntax)
        with_imports = sum(1 for s in self.snippets if s.has_imports)
        with_assignments = sum(1 for s in self.snippets if s.has_assignments)

        report = f"""
Documentation Snippet Extraction Report
========================================

Total snippets extracted: {total}
Valid Python syntax: {valid} ({valid/total*100:.1f}%)
Snippets with imports: {with_imports}
Snippets with assignments: {with_assignments}

Snippets by file:
"""

        # Group by file
        by_file: dict[str, int] = {}
        for snippet in self.snippets:
            by_file[snippet.source_file] = by_file.get(snippet.source_file, 0) + 1

        for file_path, count in sorted(by_file.items()):
            report += f"  {file_path}: {count} snippet(s)\n"

        # Add invalid snippets section
        invalid = [s for s in self.snippets if not s.is_valid_syntax]
        if invalid:
            report += f"\nInvalid snippets ({len(invalid)}):\n"
            for snippet in invalid:
                report += f"  {snippet.source_file}:{snippet.line_number} - {snippet.error_message}\n"

        return report

    def _check_syntax(self, code: str) -> tuple[bool, str | None]:
        """Check if code has valid Python syntax.

        Args:
            code: Python code to check

        Returns:
            Tuple of (is_valid, error_message)
        """
        try:
            ast.parse(code)
            return True, None
        except SyntaxError as e:
            return False, str(e)

    def _has_imports(self, code: str) -> bool:
        """Check if code contains import statements.

        Args:
            code: Python code to check

        Returns:
            True if code contains imports
        """
        try:
            tree = ast.parse(code)
            for node in ast.walk(tree):
                if isinstance(node, ast.Import | ast.ImportFrom):
                    return True
        except SyntaxError:
            pass
        return False

    def _has_assignments(self, code: str) -> bool:
        """Check if code contains variable assignments.

        Args:
            code: Python code to check

        Returns:
            True if code contains assignments
        """
        try:
            tree = ast.parse(code)
            for node in ast.walk(tree):
                if isinstance(node, ast.Assign | ast.AnnAssign | ast.AugAssign):
                    return True
        except SyntaxError:
            pass
        return False


def main() -> None:
    """Main entry point for snippet extraction."""
    import argparse

    parser = argparse.ArgumentParser(
        description="Extract Python code snippets from markdown documentation"
    )
    parser.add_argument(
        "--docs-dir",
        type=Path,
        default=Path("docs"),
        help="Directory containing markdown files (default: docs)",
    )
    parser.add_argument(
        "--output-dir",
        type=Path,
        default=Path("tests/docs/snippets"),
        help="Directory for extracted snippets (default: tests/docs/snippets)",
    )
    parser.add_argument(
        "--test-file",
        type=Path,
        default=Path("tests/docs/test_generated_snippets.py"),
        help="Output pytest file (default: tests/docs/test_generated_snippets.py)",
    )
    parser.add_argument(
        "--pattern",
        default="**/*.md",
        help="Glob pattern for markdown files (default: **/*.md)",
    )
    parser.add_argument(
        "--report",
        action="store_true",
        help="Print summary report",
    )

    args = parser.parse_args()

    # Create extractor
    extractor = SnippetExtractor(args.docs_dir, args.output_dir)

    # Extract snippets
    print(f"Extracting snippets from {args.docs_dir}...")
    snippets = extractor.extract_from_directory(args.pattern)
    print(f"Extracted {len(snippets)} snippets")

    # Save snippets
    print(f"Saving snippets to {args.output_dir}...")
    extractor.save_snippets()

    # Generate pytest file
    print(f"Generating test file {args.test_file}...")
    extractor.generate_pytest_file(args.test_file)

    # Print report
    if args.report:
        print(extractor.generate_report())

    print("\nDone! Run tests with: pytest tests/docs/test_generated_snippets.py")


if __name__ == "__main__":
    main()
